// Revanth Enhanced Trading System - MPL 2.0
// Murphy, de Prado, Link, Elder, Connors, O'Neil, Weinstein, Livermore methodologies
// @author Revanth Pobala

//@version=6
indicator('Rev - Enhanced v2', overlay = true, max_labels_count = 500, max_lines_count = 500)

import TradingView/RiskMetrics/3 as rm
import weak_hand/RiskManagement/1 as riskMgmt

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONFIGURATION - All tunable parameters in one place
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// --- Entry Filters ---
var bool requireWeinsteinStage = true

// --- Core Settings ---
var int scoreThreshold = 82
var int signalCooldown = 10
var bool showEntryExit = true
var bool showStopLoss = true
var bool requireConfluence = true
var int minSignalQuality = 35

// --- Top Detection ---
var int rsiTopThreshold = 65
var int rsiExtremeThreshold = 75
var bool enableRsiCascade = true
var string cascadeTimeframe = '60'
var bool enableScoreDivergence = true

// --- Institutional Tools ---
var bool enableAvwap = true
var bool enableGapZones = true

// --- Predictive Engine ---
var int erLength = 20
var int adxTrendThresh = 18
var int liqPivotLength = 10

// --- MTF Analysis ---
var bool enableMTF = true
var string htfTrend = 'W'
var bool mtfStrict = true
var bool useMtfConfirmation = true
var bool strictMtfMode = false

// --- Pattern Detection ---
var bool useSmartFiltering = true
var int minConfidenceScore = 75
var bool structurePriorityMode = true

// --- Trend / MA ---
var int maSprintLength = 5
var int maHullLength = 20
var int ma1Length = 20
var int ma2Length = 50
var int ma3Length = 200

// --- Momentum ---
var int rsiLength = 14
var int macdFast = 12
var int macdSlow = 26
var int macdSignal = 9

// --- Risk Management ---
var int atrLength = 14
var float riskRewardTF = 2.0
var float baseMaxRisk = (syminfo.type == "fund" or syminfo.type == "index") ? 0.03 : 0.05
var float riskFreeRate = 0.045
var int baseMaxRiskScore = 60

// --- Relative Strength ---
var bool enableRelativeStrength = true
var string benchmarkSymbol = 'SPY'
var int rsMinimum = 70
var bool requireNewHighs = false

// --- Fibonacci ---
var int fibLength = 50

// --- Visuals ---
var int maxLabelHistory = 50
var bool showCandlePatterns = true
var bool showChartPatterns = true
var bool showSR = true
var bool showGaps = true

isExpirationDay() => dayofweek == dayofweek.friday and month(time) % 3 == 0 and dayofmonth >= 15 and dayofmonth <= 21

createTableCell(tbl, col, row, txt, txtColor, bgColor, txtSize, tooltip = '') =>
    table.cell(tbl, col, row, txt, text_color = txtColor, bgcolor = bgColor, text_size = txtSize, tooltip = tooltip)
// --- FORMATTING HELPERS ---
fmt1(float val) => str.tostring(val, "#.##")
fmt2(float val) => str.tostring(val, format.mintick)
fmt0(float val) => str.tostring(val, '#')

checkVolumeQuality(float vol, float volAvg20, float pRange, bool isExp) =>
    float quality = 1.0
    if vol > volAvg20 * 2.0 and pRange < 1.0
        quality := 0.5
    if isExp
        quality := quality * 0.7
    quality

fmtSafe(float val, string fallback) =>
    na(val) ? fallback : str.tostring(val, format.mintick)
fmtSafeP(float val, string fallback) =>
    na(val) ? fallback : str.tostring(val, "#.##")

// --- SIGNAL LABELS (STATIC) ---
var buyLabelsTrend = array.from("‚Ä¢ MA X (T)", "‚Ä¢ Golden X (T)", "‚Ä¢ Str Trend (T 2pt)", "‚Ä¢ MTF Align (T 2pt)", "‚Ä¢ Maj MTF (T)", "‚Ä¢ Stage 2 (T 2pt)")
var buyLabelsMom   = array.from("‚Ä¢ RSI Pull (M)", "‚Ä¢ MACD X (M)", "‚Ä¢ Stoch X (M)", "‚Ä¢ Mom Str (M)", "‚Ä¢ MACD Cont (M)", "‚Ä¢ RSI Rise (M)", "‚Ä¢ Force (M 2pt)", "‚Ä¢ New Highs (M)", "‚Ä¢ Impulse (M)")
var buyLabelsSupp  = array.from("‚Ä¢ MA Bounce (S 2pt)", "‚Ä¢ PSAR (S)", "‚Ä¢ Fib Bounce (S)", "‚Ä¢ PSAR Cont (S)", "‚Ä¢ ADX Trend (S)", "‚Ä¢ Squeeze (S)", "‚Ä¢ Darvas (S)")
var buyLabelsVol   = array.from("‚Ä¢ OBV (V)", "‚Ä¢ Hi Vol (V)", "‚Ä¢ OBV Cont (V)", "‚Ä¢ A/D (V)")

var sellLabelsTrend = array.from("‚Ä¢ MA X (T)", "‚Ä¢ Death X (T)", "‚Ä¢ Str Trend (T)", "‚Ä¢ MTF Align (T 2pt)", "‚Ä¢ Maj MTF (T)", "‚Ä¢ Stage 4 (T 2pt)")
var sellLabelsMom   = array.from("‚Ä¢ RSI OB (M)", "‚Ä¢ MACD X (M)", "‚Ä¢ Stoch X (M)", "‚Ä¢ MACD Cont (M)", "‚Ä¢ Force (M 2pt)", "‚Ä¢ Impulse (M)")
var sellLabelsSupp  = array.from("‚Ä¢ BB Reject (R)", "‚Ä¢ PSAR (R)", "‚Ä¢ Fib Reject (R)", "‚Ä¢ PSAR Cont (R)", "‚Ä¢ ADX Trend (R)", "‚Ä¢ Darvas Brk (R)")
var sellLabelsVol   = array.from("‚Ä¢ OBV (V)", "‚Ä¢ Hi Vol (V)", "‚Ä¢ OBV Cont (V)", "‚Ä¢ A/D (V)")

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 1. GLOBAL INDICATORS & STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Centralized calculations for performance optimization and global access.
// Declared in global scope to be accessible by all functions
type AnchorData
    float dist
    string name
    float distCap

globalSma50 = ta.sma(close, 50)
globalSma100 = ta.sma(close, 100)
globalSma200 = ta.sma(close, 200)
globalEma13 = ta.ema(close, 13)
vwma200 = ta.vwma(close, 200)
volAvg20 = ta.sma(volume, 20)
// OPTIMIZATION: Global Bounding Box Pre-calculation for Evidence Score
// Using simple offset [1] to avoid repainting or lookahead
globalLow100 = ta.lowest(low, 100)[1]
globalHigh100 = ta.highest(high, 100)[1]

globalDayChanged = ta.change(time("D")) != 0
isVolConfident = volume > volAvg20 * 0.8
string longTooltip = ""
string shortTooltip = ""
// GLOBAL VISUAL STATE
int FUTURE_OFFSET = 25 // Increased from 15 for better Right-Side alignment stability on zoom
int labelOffset = 0
string labelStyleToUse = label.style_label_left
float longAlphaBox = 40.0
float shortAlphaBox = 40.0
float longAlphaLine = 60.0
float shortAlphaLine = 60.0
color longTextColor = color.white
color shortTextColor = color.white
color COL_ORANGE = color.orange
// AI-READABLE SIGNAL MATRIX COLORS (Premium Palette)
color COL_SIGNAL_BULL = color.rgb(16, 185, 129, 15)   // Emerald Green - Active Bullish
color COL_SIGNAL_BEAR = color.rgb(239, 68, 68, 15)    // Rose Red - Active Bearish  
color COL_SIGNAL_CAUTION = color.rgb(245, 158, 11, 20) // Amber Gold - Caution/Neutral
color COL_SIGNAL_INACTIVE = color.rgb(107, 114, 128, 60) // Slate Gray - Inactive
color COL_SIGNAL_INST = color.rgb(139, 92, 246, 25)   // Violet Purple - Institutional

float VERTICAL_SCALE_GUARD = 0.15 // Tightened from 0.40 to prevent Y-axis compression

float scaleGuardThreshold = close * VERTICAL_SCALE_GUARD

// 2. DASHBOARD HELPERS
// Consolidated row renderer with contrast and theme support.
renderDashRow(tab, row, valL, lbl, valS, colL=color.white, bgL=color.gray, colM=color.white, bgM=color.gray, colS=color.white, bgS=color.gray, toolL='', toolM='', toolS='') =>
    table.cell(tab, 0, row, valL, text_color=colL, bgcolor=bgL, text_size=size.tiny, tooltip=toolL)
    table.cell(tab, 1, row, lbl, text_color=colM, bgcolor=bgM, text_size=size.tiny, tooltip=toolM)
    table.cell(tab, 2, row, valS, text_color=colS, bgcolor=bgS, text_size=size.tiny, tooltip=toolS)

calcPatternConfidence(baseConf, bonus, trendBonus, inTrend) =>
    baseConf + bonus + (inTrend ? trendBonus : 0)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SCORE FINALIZATION ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Optimization: Adds Relative Strength and Acceleration bonuses
finalizeConsolidatedScores(float bS, float sS, bool bSw, bool bF, bool sSw, bool sF, bool isNH, int wStg, bool iG, bool hasRS, bool hasAccel) =>
    // Base Bonuses
    // PURE QUANT LOGIC: No arbitrary bonuses. Trust the Sigma.
    // Score Validation: We only apply Risk Caps (Negative Constraints).
    
    // Stage Constraints (Risk Management Only)
    // If Stage 2 (uptrend) and trying to Sell (Short), Cap score at 60.
    sFnl = (iG and sS > 60) ? 60 : sS
    
    // No "Bailouts" for Longs. If the score is low, it stays low.
    bFnl = bS

    [math.min(100, bFnl), math.min(100, sFnl)]

// Parallel-sorts level data (levels, weights, names, tags) by descending weight.
sortByWeight(float[] lvls, float[] wgts, string[] nms, bool[] tits) =>
    int n = array.size(lvls)
    if n > 1
        // Shell Sort gaps (Ciura sequence for small arrays)
        int[] gaps = array.from(23, 10, 4, 1)
        for g_idx = 0 to array.size(gaps) - 1
            int h = array.get(gaps, g_idx)
            if h < n
                for i = h to n - 1
                    float tW = array.get(wgts, i)
                    float tL = array.get(lvls, i)
                    string tN = array.get(nms, i)
                    bool tT = array.get(tits, i)
                    int j = i
                    for k = 0 to n // Use as while loop substitute
                        if j >= h and array.get(wgts, j - h) < tW
                            array.set(wgts, j, array.get(wgts, j - h))
                            array.set(lvls, j, array.get(lvls, j - h))
                            array.set(nms, j, array.get(nms, j - h))
                            array.set(tits, j, array.get(tits, j - h))
                            j := j - h
                        else
                            break
                    array.set(wgts, j, tW)
                    array.set(lvls, j, tL)
                    array.set(nms, j, tN)
                    array.set(tits, j, tT)

calcStopLoss(entryPrice, rawStop, maxRiskPct, isLong) =>
    if isLong
        math.max(rawStop, entryPrice * (1 - maxRiskPct))
    else
        math.min(rawStop, entryPrice * (1 + maxRiskPct))

// Real zone calculations happen in calcEntryExitLong/calcEntryExitShort

updateBestPattern(currentBest, currentConf, newPattern, newConf, useFilter, minConf) =>
    string best = currentBest
    int conf = currentConf
    if not useFilter or newConf >= minConf
        if newConf > currentConf
            best := newPattern
            conf := newConf
    [best, conf]

calcMTFQuality(bool m, bool w, bool d, bool h, bool en) =>
    en ? (m ? 30.0 : 0.0) + (w ? 30.0 : 0.0) + (d ? 20.0 : 0.0) + (h ? 20.0 : 0.0) : 100.0

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MEAN REVERSION SCORE CALCULATOR (Larry Connors Methodology)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Calculates reversal probability for Long (isLong=true) or Short (isLong=false)
// Returns a score from 0-30 based on oversold/overbought confluence

calcReversionScore(bool isLong, float rsi2Val, float rsiVal, float zElast, float zVol, float volRatio, bool rsiCascade, bool rsiDiv, bool stochCross, bool macdCross, bool obvDiv, bool pattern1, bool pattern2, bool near52W, bool nearLevel, bool belowBand, bool osc1, bool osc2, bool osc3, int consecDays, bool aboveSMA200) =>
    float score = 0.0
    
    // TIER 1: EXTREME (High Weight)
    score += isLong ? (rsi2Val < 10 ? 3.0 : rsi2Val < 15 ? 2.0 : rsi2Val < 25 ? 1.0 : 0.0) : (rsi2Val > 90 ? 3.0 : rsi2Val > 85 ? 2.0 : rsi2Val > 75 ? 1.0 : 0.0)
    score += isLong ? (rsiVal < 25 ? 2.0 : rsiVal < 30 ? 1.0 : 0.0) : (rsiVal > 75 ? 2.0 : rsiVal > 70 ? 1.0 : 0.0)
    score += rsiCascade ? 3.0 : 0.0
    score += rsiDiv ? 3.0 : 0.0
    
    // TIER 2: STRUCTURE
    score += near52W ? 2.0 : 0.0
    score += nearLevel ? 1.5 : 0.0
    score += belowBand ? 1.5 : 0.0
    score += isLong ? (zElast < -2.0 ? 2.0 : zElast < -1.5 ? 1.0 : 0.0) : (zElast > 2.0 ? 2.0 : zElast > 1.5 ? 1.0 : 0.0)
    
    // TIER 3: MOMENTUM
    score += stochCross ? 1.5 : 0.0
    score += macdCross ? 1.5 : 0.0
    score += obvDiv ? 1.0 : 0.0
    
    // TIER 4: PATTERNS
    score += pattern1 ? 1.5 : 0.0
    score += pattern2 ? 1.5 : 0.0
    
    // TIER 5: CAPITULATION/EUPHORIA
    score += consecDays >= 5 ? 2.0 : consecDays >= 4 ? 1.0 : 0.0
    score += volRatio > 2.0 ? 2.0 : zVol > 2.0 ? 1.0 : 0.0
    
    // TIER 6: OSCILLATORS
    score += osc1 ? 0.5 : 0.0
    score += osc2 ? 0.5 : 0.0
    score += osc3 ? 0.5 : 0.0
    
    // CONNORS TREND FILTER
    score += (isLong and aboveSMA200) or (not isLong and not aboveSMA200) ? 1.5 : 0.0
    
    score

    
// Helper for building signal lists via offsets (Size Optimization)
buildSignalList(bool[] masterSigs, string[] labels, int offset) =>
    txt = ""
    for i = 0 to array.size(labels) - 1
        if array.get(masterSigs, offset + i)
            txt := txt + array.get(labels, i) + "\n"
    txt

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HULL DMI - Faster trend detection (catches breakouts before standard ADX)
// Must be calculated BEFORE dashboard rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
var int hullLen = 15
var int hullDILen = 18
var int hullADXLen = 18
hullHigh = ta.wma(2 * ta.wma(high, hullLen / 2) - ta.wma(high, hullLen), math.floor(math.sqrt(hullLen)))
hullLow = ta.wma(2 * ta.wma(low, hullLen / 2) - ta.wma(low, hullLen), math.floor(math.sqrt(hullLen)))
hullUp = ta.change(hullHigh)
hullDown = -ta.change(hullLow)
hullPlusDM = na(hullUp) ? na : (hullUp > hullDown and hullUp > 0 ? hullUp : 0)
hullMinusDM = na(hullDown) ? na : (hullDown > hullUp and hullDown > 0 ? hullDown : 0)
hullTR = ta.rma(ta.tr, hullDILen)
hullPlusDI = fixnan(100 * ta.rma(hullPlusDM, hullDILen) / hullTR)
hullMinusDI = fixnan(100 * ta.rma(hullMinusDM, hullDILen) / hullTR)
hullSum = hullPlusDI + hullMinusDI
hullADX = 100 * ta.rma(math.abs(hullPlusDI - hullMinusDI) / (hullSum == 0 ? 1 : hullSum), hullADXLen)
hullADXRising = hullADX > nz(hullADX[1], hullADX)
hullDMIBull = hullPlusDI > hullMinusDI and hullADXRising  // Bullish: +DI > -DI and ADX rising
hullDMIBear = hullMinusDI > hullPlusDI  // Bearish: -DI > +DI
hullDMIDiff = hullPlusDI - hullMinusDI  // Positive = bullish, Negative = bearish

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN DASHBOARD RENDERING ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

renderMainDashboard(table dash, string trndT, string tfD, bool[] bSig, bool[] sSig, float[] mtr, float[] lvls, string[] strH, color decC, color mCL, color mCS, bool upT, bool downT, bool top, bool bot, bool iRKL, bool iRKS, bool lTargNear, bool sTargNear, string actStateLong, string actStateShort, string globalDec, bool isDanger, bool isSupW, bool isResW, float zVel, float zElast, int trendBars, float keySup, float keyRes, float revScL, float revScS, bool inLongZone, bool inShortZone) =>
    // Guard checked internally by wrapping logic in 'if barstate.islast'

    if barstate.islast
        // Unpack Metrics
        float bScore = array.get(mtr, 0), float sScore = array.get(mtr, 1), float sigQual = array.get(mtr, 2)
        float adxV = array.get(mtr, 3), float rsiV = array.get(mtr, 4), float rrTF = array.get(mtr, 5)
        float bTScore = array.get(mtr, 6), float bMScore = array.get(mtr, 7), float bVScore = array.get(mtr, 8), float bVoScore = array.get(mtr, 9), float bDScore = array.get(mtr, 10)
        float sTScore = array.get(mtr, 11), float sMScore = array.get(mtr, 12), float sVScore = array.get(mtr, 13), float sVoScore = array.get(mtr, 14), float sDScore = array.get(mtr, 15)
        float iVR = array.get(mtr, 16), float iV3 = array.get(mtr, 17), float ivS = array.get(mtr, 18), float tSig = array.get(mtr, 19)
        
        // Unpack Levels
        float lZL = array.get(lvls, 0), float lZH = array.get(lvls, 1), float fLZL = array.get(lvls, 2), float fLZH = array.get(lvls, 3)
        float sZL = array.get(lvls, 4), float sZH = array.get(lvls, 5), float fSZL = array.get(lvls, 6), float fSZH = array.get(lvls, 7)
        float sEL = array.get(lvls, 8), float sSL = array.get(lvls, 9), float sTPL = array.get(lvls, 10)
        float sES = array.get(lvls, 11), float sSS = array.get(lvls, 12), float sTPS = array.get(lvls, 13)
        float lZL2 = array.get(lvls, 14), float lZH2 = array.get(lvls, 15), float lZS2 = array.get(lvls, 16)
        float sZL2 = array.get(lvls, 17), float sZH2 = array.get(lvls, 18), float sZS2 = array.get(lvls, 19)

        // Unpack Strings
        string wStgL = array.get(strH, 0), string dStas = array.get(strH, 1) // globalDec replaces 'dec' (strH[2])
        string lAnc = array.get(strH, 3), string sAnc = array.get(strH, 4), string lTAnc = array.get(strH, 5), string sTAnc = array.get(strH, 6)
        string lAN2 = array.get(strH, 7), string sAN2 = array.get(strH, 8), string lDAnc = array.get(strH, 10), string sDAnc = array.get(strH, 11)
        string eRL = array.get(strH, 12), string eRS = array.get(strH, 13), string rWL = array.get(strH, 14), string rWS = array.get(strH, 15)
        string mTL = array.get(strH, 16), string mTS = array.get(strH, 17), string mTt = array.get(strH, 18)
        
        // Unpack Booleans (from bSig, sSig)
        bool actL = array.get(bSig, array.size(bSig)-1), bool actS = array.get(sSig, array.size(sSig)-1)
        
        // Re-calculate Confidence (Local scope)
        int bConf = math.min(100, math.round(bScore / math.max(1, scoreThreshold) * 100))
        int sConf = math.min(100, math.round(sScore / math.max(1, scoreThreshold) * 100))
        if iRKL == true
            bConf := math.min(65, bConf)
        if iRKS == true
            sConf := math.min(65, sConf)
            
        // Build Tooltips (Local)
        string ctxT = "Stg:" + wStgL + " Dvs:" + dStas + "\nConf:" + str.tostring(bConf) + "% Scr:" + str.tostring(bScore, "#") + "/" + str.tostring(sScore, "#") + "\nDMI:" + (hullDMIBull ? "+DI" : hullDMIBear ? "-DI" : "‚Äî") + " RSI:" + str.tostring(rsiV, "#.##")
        
        // Assemble Lists (Local)
        string bSigL = "ACTIVE BUY SIGNALS (" + str.tostring(bScore, "#") + "):\n"
        bSigL := bSigL + buildSignalList(bSig, buyLabelsTrend, 0)
        bSigL := bSigL + buildSignalList(bSig, buyLabelsMom, 6)
        bSigL := bSigL + buildSignalList(bSig, buyLabelsSupp, 15)
        bSigL := bSigL + buildSignalList(bSig, buyLabelsVol, 22)
        
        string sSigL = "ACTIVE SELL SIGNALS (" + str.tostring(sScore, "#") + "):\n"
        sSigL := sSigL + buildSignalList(sSig, sellLabelsTrend, 0)
        sSigL := sSigL + buildSignalList(sSig, sellLabelsMom, 6)
        sSigL := sSigL + buildSignalList(sSig, sellLabelsSupp, 12)
        sSigL := sSigL + buildSignalList(sSig, sellLabelsVol, 18)
        
        // Final Assemble
        // if barstate.islast check removed (already inside)
        headerLongOpacity = actL ? 0 : 80
        headerShortOpacity = actS ? 0 : 80
        renderDashRow(dash, 0, 'üü¢ LONG\n' + fmt1(tSig) + 'œÉ', tfD, 'üî¥ SHORT\n' + fmt1(tSig) + 'œÉ', color.white, color.new(color.green, headerLongOpacity), color.yellow, color.new(color.blue, 0), color.white, color.new(color.red, headerShortOpacity), '', '', '')
        // TOP ROW: TREND STATUS (BULL/BEAR)
        // Redundancy Fix: Removed signal logic from here. Only shows Trend Direction.
        lStatT = upT ? (top ? "BULL (EXT)" : "BULL") : "SIDE"
        lStatC = upT ? (top ? color.red : color.lime) : color.gray
        sStatT = downT ? (bot ? "BEAR (EXT)" : "BEAR") : "SIDE"
        sStatC = downT ? (bot ? color.red : color.lime) : color.gray
        // Dynamic decision color
        bool decIsSafe = str.contains(globalDec, "SAFE") or str.contains(globalDec, "POWER")
        bool decIsDanger = str.contains(globalDec, "TOXIC") or str.contains(globalDec, "DANGEROUS")
        color bgDecision = decIsSafe ? COL_SIGNAL_BULL : decIsDanger ? COL_SIGNAL_BEAR : COL_SIGNAL_CAUTION
        renderDashRow(dash, 1, lStatT, globalDec, sStatT, lStatC, color.new(color.gray, 80), color.white, bgDecision, sStatC, color.new(color.gray, 80), 'Trend', ctxT, 'Trend')

        // NET BIAS ENGINE (Jan 8 Optimized - Moved Up)
        netScore = bScore - sScore
        bool isStg2 = str.contains(wStgL, "2")
        bool isStg4 = str.contains(wStgL, "4")
        bool isStg1 = str.contains(wStgL, "1")
        // SMART SIDE GHOSTING (Jan 8 Standard)
        // If one side is strongly dominant (>25 score gap), fade the other side to prevent confusion.
        bool isBullDom = netScore > 25
        bool isBearDom = netScore < -25
        int lA = isBearDom ? 75 : 0 // Alpha for Long Side
        int rA = isBullDom ? 75 : 0 // Alpha for Short Side
        color txtLA = color.new(color.white, lA), color txtRA = color.new(color.white, rA)

        eZTL = (not na(fLZL) and not na(fLZH)) ? fmt2(fLZL) + '-' + fmt2(fLZH) : "NONE"
        eZTS = (not na(fSZL) and not na(fSZH)) ? fmt2(fSZL) + '-' + fmt2(fSZH) : "NONE"
        // FIX: Using global inLongZone/inShortZone passed as parameters (no local shadowing)
        color bgLEntry = inLongZone ? color.new(COL_SIGNAL_BULL, lA) : (eZTL == "NONE" ? COL_SIGNAL_INACTIVE : color.new(color.blue, 50+lA))
        color bgSEntry = inShortZone ? color.new(COL_SIGNAL_BEAR, rA) : (eZTS == "NONE" ? COL_SIGNAL_INACTIVE : color.new(color.red, 50+rA))
        renderDashRow(dash, 2, eZTL, 'üìç ENTRY ZONE', eZTS, txtLA, bgLEntry, color.white, color.gray, txtRA, bgSEntry, 'ANCHOR: ' + lDAnc + '\n--- ZONES ---\nRaw: ' + fmt2(lZL) + '-' + fmt2(lZH) + '\nFinal: ' + fmt2(fLZL) + '-' + fmt2(fLZH) + '\nEntry: ' + fmt2(sEL) + '\n' + eRL, 'Clustered S/R entry bounds', 'ANCHOR: ' + sDAnc + '\n--- ZONES ---\nRaw: ' + fmt2(sZL) + '-' + fmt2(sZH) + '\nFinal: ' + fmt2(fSZL) + '-' + fmt2(fSZH) + '\nEntry: ' + fmt2(sES) + '\n' + eRS)


        lTargT = fmt2(sTPL) + (lTargNear ? ' ‚ö†Ô∏è' : '')
        sTargT = fmt2(sTPS) + (sTargNear ? ' ‚ö†Ô∏è' : '')
        color bgLStop = iRKL ? color.new(COL_SIGNAL_CAUTION, lA) : color.new(COL_SIGNAL_BULL, lA)
        color bgSStop = iRKS ? color.new(COL_SIGNAL_CAUTION, rA) : color.new(COL_SIGNAL_BEAR, rA)
        renderDashRow(dash, 3, str.tostring(sSL, '#.##'), 'üõë STOP', str.tostring(sSS, '#.##'), txtLA, bgLStop, color.white, color.gray, txtRA, bgSStop, 'Initial stop loss level', 'Risk Management', 'Initial stop loss level')


        color bgLTarg = lTargNear ? color.new(COL_SIGNAL_CAUTION, lA) : color.new(COL_SIGNAL_BULL, lA)
        color bgSTarg = sTargNear ? color.new(COL_SIGNAL_CAUTION, rA) : color.new(COL_SIGNAL_BEAR, rA)
        renderDashRow(dash, 4, lTargT, 'üéØ TARGET', sTargT, txtLA, bgLTarg, color.white, color.gray, txtRA, bgSTarg, 'Mathematical target (R:R ' + fmt1(rrTF) + ':1)' + (rWL != '' ? '\n' + rWL : ''), 'Profit Target', 'Mathematical target (R:R ' + fmt1(rrTF) + ':1)' + (rWS != '' ? '\n' + rWS : ''))
        renderDashRow(dash, 5, 'üéØ ' + lDAnc, 'ANCHOR', 'üéØ ' + sDAnc, txtLA, color.new(COL_SIGNAL_INST, lA), color.white, color.gray, txtRA, color.new(COL_SIGNAL_INST, rA), lAnc, 'Institutional Confluence', sAnc)


        lZT2 = (not na(lZL2) and not na(lZH2)) ? fmt2(lZL2) + '-' + fmt2(lZH2) : "NONE"
        sZT2 = (not na(sZL2) and not na(sZH2)) ? fmt2(sZL2) + '-' + fmt2(sZH2) : "NONE"
        bool inLongZone2 = close >= lZL2 and close <= lZH2
        bool inShortZone2 = close >= sZL2 and close <= sZH2
        color bgLZ2 = inLongZone2 ? color.new(COL_SIGNAL_BULL, lA) : (lZT2 == "NONE" ? COL_SIGNAL_INACTIVE : color.new(color.blue, 60+lA))
        color bgSZ2 = inShortZone2 ? color.new(COL_SIGNAL_BEAR, rA) : (sZT2 == "NONE" ? COL_SIGNAL_INACTIVE : color.new(color.red, 60+rA))
        renderDashRow(dash, 6, lZT2, 'üìç ZONE', sZT2, inLongZone2 ? txtLA : color.new(color.gray, lA), bgLZ2, color.white, color.gray, inShortZone2 ? txtRA : color.new(color.gray, rA), bgSZ2, (lAN2 != "" ? lAN2 : 'Secondary Zone'), 'Secondary Support/Resistance', (sAN2 != "" ? sAN2 : 'Secondary Zone'))

        // ENERGY ROW: Volatility Expansion vs Contraction (Breakout Timing)
        // Left cell: HV Percentile Rank (High = Volatile, Low = Calm)
        // Right cell: Energy State (SQUEEZE = building, EXPANSION = releasing)
        // WARNING: This is NOT Implied Volatility. Do NOT use for options pricing.
        color bgLVol = iVR > 80 ? color.new(color.purple, 40) : iVR > 50 ? color.new(color.orange, 60) : color.new(color.aqua, 50)
        color bgSVol = ivS > 20 ? color.new(color.purple, 40) : ivS > 0 ? color.new(color.orange, 60) : ivS > -20 ? color.new(color.aqua, 50) : color.new(color.gray, 80)
        string energyLabel = ivS > 20 ? 'üü£ EXPANSION' : ivS > 0 ? 'üü† WARMING' : ivS > -20 ? 'üîµ SQUEEZE' : '‚ö™ DORMANT'
        string energyTooltip = 'Volatility Energy: ' + fmtSafeP(ivS, '--') + '%\n\n' + (ivS > 20 ? 'üü£ EXPANSION: Price moving fast. Trend in motion. Trail stops.' : ivS > 0 ? 'üü† WARMING: Volatility rising. Breakout imminent.' : ivS > -20 ? 'üîµ SQUEEZE: Volatility compressing. Energy building for breakout.' : '‚ö™ DORMANT: Very low volatility. Wait for catalyst.') + '\n\n‚ö†Ô∏è NOT Implied Volatility. For options pricing, use external data.'
        renderDashRow(dash, 9, fmtSafeP(iV3, 'N/A') + ' (' + fmtSafeP(iVR, '--') + '%)', '‚ö° ENERGY', energyLabel, color.white, bgLVol, color.white, color.gray, color.white, bgSVol, 'Volatility Rank: ' + fmtSafeP(iVR, '--') + '%\nHigh (>80) = Extended move\nLow (<20) = Calm before storm', 'Volatility Energy (Breakout Timer)', energyTooltip)
        
        // Base Decision
        string bT = netScore > 20 ? (upT and close > globalSma200 ? (iRKL ? "üü° EXTENDED LONG" : (bScore > 75 ? "üü¢ STRONG LONG" : "üü¢ Lean Long")) : "üü° Lean Long") : 
                   netScore > 5 ? "üü¢ Lean Long" : 
                   netScore >= -5 ? "‚öñÔ∏è NEUTRAL" : 
                   netScore >= -20 ? "üî¥ Lean Short" : 
                   (downT and close < globalSma200 ? (iRKS ? "üü° EXTENDED SHORT" : (sScore > 75 ? "üî¥ STRONG SHORT" : "üî¥ Lean Short")) : "üü° Lean Short")

        // Warning & Stage Overrides (The Truth Filter)
        if top and netScore > 0
            bT := "‚ö†Ô∏è TOP WARNING / WAIT"
        else if bot and netScore < 0
            bT := "‚ö†Ô∏è BOTTOM WARNING / WAIT"
        else if isStg4 and netScore > 20
            bT := "‚ö†Ô∏è STAGE 4 RALLY (EXIT?)"
        else if isStg2 and netScore < -20
            bT := "‚ö†Ô∏è STAGE 2 PULLBACK (BUY?)"
        else if isStg1 and math.abs(netScore) > 20
            bT := netScore > 0 ? "‚è≥ STAGE 1 ACCUMULATION" : "‚è≥ STAGE 1 DISTRIBUTION"

        biasTextFull = bT + " (" + str.tostring(math.abs(netScore), "#") + ")"
        biasTooltip = str.format("Net Score: {0} (Buy: {1} - Sell: {2})\nWeinstein: {3})\nWarnings: {4}", netScore, bScore, sScore, wStgL, top ? "TOP" : bot ? "BOTTOM" : "None")

        // BIAS ENGINE ROW
        color bgLBias = bScore > sScore ? COL_SIGNAL_BULL : COL_SIGNAL_INACTIVE
        color bgSBias = sScore > bScore ? COL_SIGNAL_BEAR : COL_SIGNAL_INACTIVE
        color bgMBias = isDanger ? color.new(color.red, 20) : netScore > 40 ? COL_SIGNAL_BULL : netScore < -40 ? COL_SIGNAL_BEAR : netScore > 20 ? color.new(color.green, 50) : netScore < -20 ? color.new(color.red, 50) : COL_SIGNAL_CAUTION
        
        renderDashRow(dash, 10, str.tostring(bScore, "#") + " Buy", globalDec, str.tostring(sScore, "#") + " Sell", color.white, bgLBias, color.white, bgMBias, color.white, bgSBias, bSigL, biasTooltip, sSigL)


        // STAGE/DMI/DARVAS ROW (Row 7) - AI Readable Context
        string stgShort = wStgL
        string dvsShort = dStas
        string dmiLabel = "DMI:" + (hullDMIBull ? "+DI‚ñ≤" : hullDMIBear ? "-DI‚ñº" : "‚Äî")
        // (Defined above)
        bool isAboveBox = str.contains(dStas, "ABOVE") or str.contains(dStas, "BREAKOUT")
        bool isBelowBox = str.contains(dStas, "BELOW")
        color bgStage = isStg2 ? COL_SIGNAL_BULL : isStg4 ? COL_SIGNAL_BEAR : COL_SIGNAL_CAUTION
        color bgDarvas = isAboveBox ? COL_SIGNAL_BULL : isBelowBox ? COL_SIGNAL_BEAR : COL_SIGNAL_CAUTION
        color bgDMI = hullDMIBull ? COL_SIGNAL_BULL : hullDMIBear ? COL_SIGNAL_BEAR : COL_SIGNAL_CAUTION
        renderDashRow(dash, 7, stgShort, dmiLabel, dvsShort, color.white, bgStage, color.white, bgDMI, color.white, bgDarvas, 'Weinstein Stage Analysis', 'Hull DMI Momentum\n+DI‚ñ≤ = Bullish momentum rising\n-DI‚ñº = Bearish momentum', 'Darvas Box Position')


        // NEXT ACTION ROW (Row 8) - AI Explicit Directive
        bool isSafe = str.contains(globalDec, "SAFE") or str.contains(globalDec, "POWER")
        bool isDangerNext = str.contains(globalDec, "TOXIC") or str.contains(globalDec, "DANGEROUS")
        bool isWait = str.contains(globalDec, "CAUTION") or str.contains(globalDec, "EXTENDED") or str.contains(globalDec, "COUNTER")
        // HULL DMI INTEGRATION: If Hull DMI shows bullish momentum, override CHOPPY even if standard ADX is low
        bool isChoppy = adxV < 15 and not hullDMIBull and not isAboveBox  // Only choppy if ADX low AND Hull DMI not bullish AND not breakout
        bool isWeakTrend = adxV >= 15 and adxV < 20

        
        // Determine Dominant Bias
        bool isBullDominant = bScore > sScore
        bool isBearDominant = sScore > bScore
        bool isNeutral = math.abs(bScore - sScore) < 10
        bool isCounter = str.contains(globalDec, "COUNTER")
        
        // Long Action: Uses parameters available in function scope
        // actL = activeLong signal (from bSig array), bScore/sScore, zone proximity
        bool scoreHighL = bScore >= scoreThreshold
        bool scoreHighS = sScore >= scoreThreshold        
        
        // Reason Logic for Tooltip (Technical Depth)
        string distL_Str = str.tostring((close - fLZH)/fLZH*100, "#.1") + "%"
        string distS_Str = str.tostring((fSZL - close)/close*100, "#.1") + "%"
        
        // Explicitly capture the default "Wait for Zone" case
        bool isZoneWaitL = not inLongZone and not scoreHighL and not isDangerNext and not isChoppy and not isWait
        bool isZoneWaitS = not inShortZone and not scoreHighS and not isDangerNext and not isChoppy and not isWait
        
        string waitReasonL = isDangerNext ? "Risk: Market Danger" : isChoppy ? "ADX: " + str.tostring(adxV, "#") + " (Choppy)" : isWait ? "Risk: Setup Invalid" : isZoneWaitL ? "Price " + distL_Str + " > Zone" : "Score: " + str.tostring(bScore, "#") + " < " + str.tostring(scoreThreshold, "#")
        string waitReasonS = isDangerNext ? "Risk: Market Danger" : isChoppy ? "ADX: " + str.tostring(adxV, "#") + " (Choppy)" : isWait ? "Risk: Setup Invalid" : isZoneWaitS ? "Price " + distS_Str + " < Zone" : "Score: " + str.tostring(sScore, "#") + " < " + str.tostring(scoreThreshold, "#")

        // Priority: Danger > Power (Override) > Topping (Safety) > Signal
        string lAct = actStateLong
        string sAct = actStateShort
        
        // Contextual Tooltip Extensions (Now with Quantitative Data)
        string weakSupCtx = isSupW ? "\n‚ö†Ô∏è WEAK SUPPORT @ " + str.tostring(keySup, "#.##") + ": Tested >3 times in 25 bars." : ""
        string weakResCtx = isResW ? "\n‚ö†Ô∏è WEAK RESISTANCE @ " + str.tostring(keyRes, "#.##") + ": Tested >3 times in 25 bars." : ""
        
        // NEW: Exhaustion Context (The "WHY" Data)
        string velCtx = math.abs(zVel) > 2.0 ? "\nüìà VELOCITY Z: " + str.tostring(zVel, "#.##") + " (|z|>2 = Blow-off)" : ""
        string elastCtx = math.abs(zElast) > 1.5 ? "\nüìè ELASTICITY Z: " + str.tostring(zElast, "#.##") + " (|z|>1.5 = Stretched)" : ""
        string trendCtx = trendBars > 20 ? "\n‚è±Ô∏è TREND DURATION: " + str.tostring(trendBars) + " bars (>20 = Stale)" : ""
        
        string fullTooltipL = 'Action: ' + lAct + weakSupCtx + velCtx + elastCtx + trendCtx + (str.contains(lAct, "WAIT") ? "\nREASON: " + waitReasonL : "")
        string fullTooltipS = 'Action: ' + sAct + weakResCtx + velCtx + elastCtx + trendCtx + (str.contains(sAct, "WAIT") ? "\nREASON: " + waitReasonS : "")

        color bgLAc = isDanger ? COL_SIGNAL_BEAR : (str.contains(lAct, "BUY") or str.contains(lAct, "POWER")) ? COL_SIGNAL_BULL : (str.contains(lAct, "WARNING") or str.contains(lAct, "BLOW") or str.contains(lAct, "EXTENDED") or str.contains(lAct, "CAPITULATION")) ? color.new(color.red, 30) : top ? color.new(color.red, 40) : isStg4 ? color.new(color.red, 50) : COL_SIGNAL_CAUTION
        color bgSAc = isDanger ? COL_SIGNAL_BEAR : (str.contains(sAct, "SELL") or str.contains(sAct, "POWER")) ? COL_SIGNAL_BEAR : (str.contains(sAct, "WARNING") or str.contains(sAct, "BLOW") or str.contains(sAct, "EXTENDED") or str.contains(sAct, "CAPITULATION")) ? color.new(color.red, 30) : bot ? color.new(color.lime, 40) : isStg2 ? color.new(color.green, 50) : COL_SIGNAL_CAUTION
        
        color bgMAc = isDanger ? COL_SIGNAL_BEAR : isCounter ? COL_SIGNAL_CAUTION : isBullDominant ? COL_SIGNAL_BULL : isBearDominant ? COL_SIGNAL_BEAR : COL_SIGNAL_CAUTION
        renderDashRow(dash, 8, lAct, '‚ö° ACTION', sAct, txtLA, bgLAc, color.white, bgMAc, color.white, bgSAc, fullTooltipL, 'Actionable Signals', fullTooltipS)

        // REVERSAL ZONE ROW (Row 9) - Zone-Based Mean Reversion Display
        // Zone Mapping: Zone 0 = Extreme (10+), Zone 1 = Strong (7-9), Zone 2 = Forming (4-6)
        float alphaRevL = revScL >= 4 ? math.max(0, 90 - (revScL * 6)) : 90
        float alphaRevS = revScS >= 4 ? math.max(0, 90 - (revScS * 6)) : 90
        
        // Zone text: Higher score = Lower zone number (more urgent)
        string revTextL = revScL >= 10 ? 'üéØ ZONE 0' : revScL >= 7 ? 'üéØ ZONE 1' : revScL >= 4 ? 'üéØ ZONE 2' : '‚Äî'
        string revTextS = revScS >= 10 ? 'üéØ ZONE 0' : revScS >= 7 ? 'üéØ ZONE 1' : revScS >= 4 ? 'üéØ ZONE 2' : '‚Äî'
        
        // Color tiers: Zone 0 = Solid, Zone 1 = Strong, Zone 2 = Ghosted
        color bgRevL = revScL >= 10 ? color.new(color.lime, 0) : revScL >= 7 ? color.new(color.green, 30) : revScL >= 4 ? color.new(color.teal, 60) : color.new(color.gray, 80)
        color bgRevS = revScS >= 10 ? color.new(color.red, 0) : revScS >= 7 ? color.new(color.maroon, 30) : revScS >= 4 ? color.new(color.purple, 60) : color.new(color.gray, 80)
        
        // Tooltip shows score breakdown (informational, not prescriptive)
        string revTooltipL = 'Long Reversal Zone (Score: ' + str.tostring(revScL, '#.#') + ')\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüéØ ZONE 0 (10+): Extreme Oversold\nüéØ ZONE 1 (7-9): Strong Oversold\nüéØ ZONE 2 (4-6): Forming\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ RSI(2)<10: +3 | Divergence: +3\n‚Ä¢ 52W Low: +2 | Vol Climax: +2\n‚Ä¢ MACD/Stoch Cross: +1.5 each'
        string revTooltipS = 'Short Reversal Zone (Score: ' + str.tostring(revScS, '#.#') + ')\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüéØ ZONE 0 (10+): Extreme Overbought\nüéØ ZONE 1 (7-9): Strong Overbought\nüéØ ZONE 2 (4-6): Forming\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ RSI(2)>90: +3 | Divergence: +3\n‚Ä¢ 52W High: +2 | Vol Climax: +2\n‚Ä¢ MACD/Stoch Cross: +1.5 each'
        
        renderDashRow(dash, 11, revTextL, 'üîÑ REV ZONE', revTextS, color.white, bgRevL, color.white, color.new(color.gray, 60), color.white, bgRevS, revTooltipL, 'Mean Reversion Zones', revTooltipS)

        // MTF ROW
        renderDashRow(dash, 12, mTL, str.tostring(sigQual, '#') + '% MTF', mTS, color.new(color.lime, 0), color.gray, sigQual >= 75 ? color.lime : COL_ORANGE, color.gray, color.new(color.red, 0), color.gray, mTt, mTt, mTt)



        table.cell_set_tooltip(dash, 0, 0, "Current Trend: " + trndT)
        table.cell_set_tooltip(dash, 1, 0, "System State:\n" + ctxT)
        table.cell_set_tooltip(dash, 2, 0, "Strategic Decision:\n" + globalDec)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 2. STRUCTURAL CONFLUENCE ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Logic for identifying high-probability institutional levels and clustering themes.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// INSTITUTIONAL PIVOTS (PRE-FETCH FOR CONFLUENCE ENGINE)
// Defined early so they are accessible to global functions like calcEvidenceScore.
[preWPH, preWPL] = request.security(syminfo.tickerid, 'W', [ta.pivothigh(high, 5, 5), ta.pivotlow(low, 5, 5)], barmerge.gaps_off, barmerge.lookahead_off)
[preMPH, preMPL] = request.security(syminfo.tickerid, 'M', [ta.pivothigh(high, 3, 3), ta.pivotlow(low, 3, 3)], barmerge.gaps_off, barmerge.lookahead_off)

// HTF Density Level (Weekly Close Clusters)
// Returns the average of Weekly closes if they cluster within 0.5%
getHTFDensityLevel(string tf) =>
    // Fetch last 3 closes from specified timeframe (use [1] to avoid repainting)
    [htfClose1, htfClose2, htfClose3] = request.security(syminfo.tickerid, tf, 
        [close[1], close[2], close[3]], barmerge.gaps_off, barmerge.lookahead_off)
    
    float densityLevel = na
    float clusterTol = 0.005  // 0.5% clustering tolerance
    
    if not na(htfClose1) and not na(htfClose2) and htfClose1 > 0
        if math.abs(htfClose1 - htfClose2) / math.max(1, htfClose1) < clusterTol
            // Found a cluster of 2+ closes
            densityLevel := (htfClose1 + htfClose2) / 2
            // Check if 3rd close also clusters (stronger signal)
            if not na(htfClose3) and densityLevel > 0 and math.abs(htfClose3 - densityLevel) / densityLevel < clusterTol
                densityLevel := (htfClose1 + htfClose2 + htfClose3) / 3
    densityLevel

// --- STRUCTURAL VALIDATION INTERFACE ---
// Integrates HTF Density Analysis with the Evidence Scoring Architecture.
// 1. Expiration Day Sensitivity: Adjusts weighting for Quad Witching/OpEx volume noise.
// 2. Multi-Factor Evidence Score: Validates levels via Touches, Volume, and MA Confluence.
// 3. Spatial Hysteresis: Prevents zone flickering via "Defender's Advantage" election logic.
// Checks for Quad Witching / OpEx Fridays (3rd Friday of March, June, Sept, Dec).

// 3. FORMATTING UTILITIES (Precision Management)

// Count how many MAs cluster near this level
// More MA confluence = stronger institutional level
maConfluence(float level, float[] mas, float tolerancePct) =>
    int count = 0
    tol = level * tolerancePct
    if array.size(mas) > 0
        for ma in mas
            if not na(ma) and level > 0 and math.abs(level - ma) < tol
                count += 1
    count

// Calculates an "Evidence Score" for a price level based on historical touches, 
// volume quality, and MA confluence. Used for weighting in the clustering engine.
calcEvidenceScore(level, mas, htfMultiplier, volAvg20, low100, high100, atrVal, wH, wL, mH, mL) =>
    int touches = 0
    bool volConfirm = false
    float volThreshold = 1.3
    isExp = isExpirationDay()
    float touchScore = 0.0
    // ATR-BASED TOLERANCE: Adaptive to volatility (0.3 * ATR instead of fixed 0.5%)
    float safeAtr = nz(atrVal, level * 0.005) // Fallback to 0.5% if ATR unavailable
    tol = math.max(safeAtr * 0.3, level * 0.002) // Min 0.2% to prevent too-tight zones

    // OPTIMIZATION: Bounding Box Early Exit
    // If the level is completely outside the range of the last 100 bars, skip the loop.
    bool inRange = (level <= high100 + tol) and (level >= low100 - tol)
    
    if inRange
        for i = 1 to 100
            if level > 0 and (math.abs(low[i] - level) < tol or math.abs(high[i] - level) < tol)
                touches += 1
                // 1. Gaussian Structural Weighting
                float gWeight = 3.5 * math.exp(-math.pow(i - 25.0, 2) / 1800.0) // 2 * 30^2 = 1800
                touchScore := touchScore + gWeight
                
                // 2. Volume check (First 50 bars)
                if i <= 50 and not volConfirm
                    float quality = checkVolumeQuality(volume[i], volAvg20, (high[i] - low[i]) / math.max(1, low[i]) * 100, isExp)
                    if volume[i] > volAvg20 * (volThreshold / quality)
                        volConfirm := true
    
    touchScore := math.min(touchScore, 10.0) // Capped at 10 (research-backed)
    float volScore = volConfirm ? 2.5 : 0.0   // Increased: volume = institutional interest
    
    // 2. MA Confluence (Current TF)
    int maCount = maConfluence(level, mas, 0.012)
    float maScore = maCount * 1.0 // Research-backed: 1.0 per aligned MA
    
    // 3. HTF Multiplier
    float htfScore = htfMultiplier * 2.0
    
    // 4. INSTITUTIONAL PIVOT CONFLUENCE (Multi-TF)
    float htfConfluenceBonus = 0.0
    float pivotTol = 0.007 // 0.7%
    
    if not na(wH) and math.abs(level - wH) / wH < pivotTol
        htfConfluenceBonus += 2.5  // Weekly pivot (research-backed)
    if not na(wL) and math.abs(level - wL) / wL < pivotTol
        htfConfluenceBonus += 2.5
    if not na(mH) and math.abs(level - mH) / mH < pivotTol
        htfConfluenceBonus += 3.0  // Monthly pivot (research-backed)
    if not na(mL) and math.abs(level - mL) / mL < pivotTol
        htfConfluenceBonus += 3.0

    // Total evidence score
    float total = touchScore + volScore + maScore + htfScore + htfConfluenceBonus
    
    // FINAL QUALITY GATE
    bool isIsolated = maCount == 0 and not volConfirm and touches < 2 and htfMultiplier == 0
    // Recency Relaxation: If level was touched in last 10 bars, it's NOT isolated (The 2-week rule)
    if touches >= 1 and touchScore >= 2.0 
        isIsolated := false
    isIsolated ? 0.0 : total

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GENERIC LEVEL PROCESSING HELPER
// Standardizes the addition of levels to arrays and tracking of anchors
// barsAgo: How many bars ago this level was formed (0 = current)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
processLevel(float[] lvls, float[] wgts, string[] nms, bool[] titArray, float lvl, float scr, string nm, bool isTit, float refPr, AnchorData anchor, int barsAgo) =>
    float MIN_ZONE_SCORE = 5.0  // Research-backed: 2 touches + volume = 5.0
    // Titanium levels (KEY SUP/RES, 52W, Golden Cross) bypass gate - structurally validated
    if scr > MIN_ZONE_SCORE or isTit
        // RECENCY DECAY: Non-titanium levels decay over time
        // Decay factor: exp(-0.003 * barsAgo) ‚Üí ~50% weight at ~230 bars ago (Tuned for Swing)
        // Titanium levels (52W High, Golden Cross, POC) are EXEMPT
        float recencyFactor = isTit ? 1.0 : math.exp(-0.003 * math.max(0, nz(barsAgo, 0)))
        float adjustedScore = scr * recencyFactor
        
        array.push(lvls, lvl)
        array.push(wgts, adjustedScore)  // Use decayed score
        array.push(nms, nm)
        array.push(titArray, isTit)

        
        // Calculate distance (always positive)
        float dist = math.abs(refPr - lvl)
        
        // Update anchor if this is the closest level so far
        if dist < anchor.dist
            anchor.dist := dist
            anchor.name := nm

// Helper to find closest Key Level (Resistance/Support) from arrays
findClosestKeyLevel(float[] lvlArray, float targetPrice, bool isSup, float minDst) =>
    float closest = na
    if array.size(lvlArray) > 0
        for i = 0 to array.size(lvlArray) - 1
            float val = array.get(lvlArray, i)
            bool valid = isSup ? (val < targetPrice - minDst) : (val > targetPrice + minDst)
            
            if valid
                if na(closest)
                    closest := val
                else
                    // For support: maximize (closest to price from below)
                    // For resistance: minimize (closest to price from above)
                    if isSup
                        if val > closest
                            closest := val
                    else
                        if val < closest
                            closest := val
    closest

// --- 4. GLOBAL UI PERSISTENCE OBJECTS ---
// These var objects are reused every bar to prevent "Static UI" lag and stacking.
var line lEntryLine_P = line.new(na, na, na, na, xloc=xloc.bar_index, width=2)
var label lEntryLbl_P = label.new(na, na, xloc=xloc.bar_index, style=label.style_label_left, size=size.normal)
var line lStopLine_P = line.new(na, na, na, na, xloc=xloc.bar_index, width=1, style=line.style_dashed)
var label lStopLbl_P = label.new(na, na, xloc=xloc.bar_index, style=label.style_label_left, size=size.normal)
var line lTargetLine_P = line.new(na, na, na, na, xloc=xloc.bar_index, width=1, style=line.style_dashed)
var label lTargetLbl_P = label.new(na, na, xloc=xloc.bar_index, style=label.style_label_left, size=size.normal)

var line sEntryLine_P = line.new(na, na, na, na, xloc=xloc.bar_index, width=2)
var label sEntryLbl_P = label.new(na, na, xloc=xloc.bar_index, style=label.style_label_left, size=size.normal)
var line sStopLine_P = line.new(na, na, na, na, xloc=xloc.bar_index, width=1, style=line.style_dashed)
var label sStopLbl_P = label.new(na, na, xloc=xloc.bar_index, style=label.style_label_left, size=size.normal)
var line sTargetLine_P = line.new(na, na, na, na, xloc=xloc.bar_index, width=1, style=line.style_dashed)
var label sTargetLbl_P = label.new(na, na, xloc=xloc.bar_index, style=label.style_label_left, size=size.normal)

// Primary Zone Boxes & Labels
var box longZoneBox = na
var box shortZoneBox = na
var label longZoneLabel = na
var label shortZoneLabel = na

// Secondary Zone Boxes & Labels
var box longZoneBox2 = na
var box shortZoneBox2 = na
var label longZoneLabel2 = na
var label shortZoneLabel2 = na

// Validation & Discovery Labels (Persistent to prevent stacking)
var label failedValidationLbl = na
var label discoverySignalLbl = na // For Strong Buy/Sell historical labels

// Darvas Box Persistence
var line darvasBoxTopLine = na
var line darvasBoxBottomLine = na
var label darvasTopLabel = na
var label darvasBottomLabel = na

// --- 5. GLOBAL STATE & PERSISTENCE ---
// Tracks prior formations for hysteresis, Z-Score, and opacity calculations.
calcZoneAlpha(float confidence) =>
    // Maps 0-100 confidence scale to 95-10 transparency.
    // Handles NaN values by defaulting to maximum transparency (Ghost Mist).
    float safeConf = nz(confidence, 0.0)
    float alpha = 95.0 - (85.0 * (math.min(100.0, safeConf) / 100.0))
    math.max(10.0, math.min(95.0, alpha))

// Secondary cluster storage [High, Low, Score] for secondary Long/Short zones.
var float[] secondaryZoneInfo = array.new_float(20, na)
var string[] secondaryZoneNames = array.new_string(2, "")

// HYSTERESIS & ACCUMULATION TRACKING
// Tracks prior cluster formations to enable Z-Score and Persistence-based opacity
var float lastLongClusterLevel = na
var float lastShortClusterLevel = na
var int longClusterPersistenceCount = 0
var int shortClusterPersistenceCount = 0

// Historical Stats for Score Z-Score (Relative Strength)
// Initialized to 0.0, updated via ta.ema/stdev in global scope
var float longScoreEma = 0.0
var float longScoreStdev = 0.0
var float shortScoreEma = 0.0
var float shortScoreStdev = 0.0

var float longZoneHigh2 = na
var float longZoneLow2 = na
var float longZoneScore2 = 0.0
var float shortZoneHigh2 = na
var float shortZoneLow2 = na
var float shortZoneScore2 = 0.0

var int longZoneStartIdx = na
var int shortZoneStartIdx = na

// GHOST OBJECT MANAGEMENT (Arrays to prevent stacking)
var line[] ghostLines = array.new_line()
var label[] ghostLabels = array.new_label()

// Persistent storage for active entry, stop, and target levels across bars.
var float suggestedEntryLong = na
var float suggestedStopLossLong = na
var float suggestedTakeProfitLong = na
var float rawTakeProfitLong = na
var float longZoneHigh = na
var float longZoneLow = na
var string longAnchorName = ""
var float longZoneScore = 0.0

var float suggestedEntryShort = na
var float suggestedStopLossShort = na
var float suggestedTakeProfitShort = na
var float rawTakeProfitShort = na
var bool longSetupActive = true
var bool shortSetupActive = true
var float shortZoneHigh = na
var float shortZoneLow = na
var string shortAnchorName = ""
var float shortZoneScore = 0.0

// Pre-allocated dashboard signal strings relocated to top for scope resolution.

// --- 5. CLUSTERING ENGINE: ELECTION LOGIC ---
// Implements "Defender Advantage" and spatial hysteresis to prevent zone flickering.
// Uses Gaussian weighting and ATR-based proximity decay for level selection.
findWinningCluster(int clusterCount, float[] clusterCenters, float[] clusterScores, float[] clusterLeaderWeights, bool[] clusterIsTitanium, float prevEntry, float atrVal, int excludeIdx, float closePrice, bool isSecondary, float trendBias) =>
    // Step 1: Find Defender (cluster closest to prevEntry)
    int defenderIdx = -1
    float minDistToDefender = 999999.0
    if not na(prevEntry) and clusterCount > 0
        for i = 0 to clusterCount - 1
            if i != excludeIdx
                float center = array.get(clusterCenters, i)
                float _dist = math.abs(center - prevEntry)
                if _dist < minDistToDefender
                    minDistToDefender := _dist
                    defenderIdx := i
    
    // Step 2: Calculate œÉ (Standard Deviation) of cluster scores
    float sumScores = 0.0
    float sumSqScores = 0.0
    int validCount = 0
    if clusterCount > 0
        for i = 0 to clusterCount - 1
            if i != excludeIdx
                float s = array.get(clusterScores, i)
                if s >= 0
                    sumScores += s
                    sumSqScores += s * s
                    validCount += 1
                
    float meanScore = validCount > 0 ? sumScores / validCount : 0.0
    float variance = validCount > 1 ? (sumSqScores / validCount) - (meanScore * meanScore) : 0.0
    float sigmaScores = math.sqrt(math.max(0.0, variance))
    
    // Step 3: Taper Factor (Exponential Stickiness)
    float distFromPrev = na(prevEntry) ? 0.0 : math.abs(closePrice - prevEntry)
    float safeAtr = nz(atrVal, 1.0)
    float atrDistPrev = distFromPrev / safeAtr
    float taperFactor = math.exp(-0.5 * atrDistPrev) 
    
    // Step 4: Defender's Advantage 
    float tfMinutes = timeframe.in_seconds() / 60
    float stabilityFactor = tfMinutes >= 1440 ? 0.5 : tfMinutes >= 240 ? 0.8 : tfMinutes >= 60 ? 1.0 : 1.5
    float defenderBonus = stabilityFactor * sigmaScores * taperFactor
    
    // Find Best (Dual-Mode Election)
    int candidateBestIdx = -1
    float candidateBestScore = -1.0
    
    if clusterCount > 0
        for i = 0 to clusterCount - 1
            if i != excludeIdx
                float rawScore = array.get(clusterScores, i)
                if rawScore >= 0 
                    bool isTitCluster = array.get(clusterIsTitanium, i)
                    float bonus = isTitCluster ? defenderBonus * 2.0 : defenderBonus
                    float effectiveScore = (i == defenderIdx) ? rawScore + bonus : rawScore
                    
                    // PROXIMITY-FIRST ENGINE (ATR Exponential Decay)
                    float center = array.get(clusterCenters, i)
                    float distAtr = math.abs(center - closePrice) / safeAtr
                    
                    // Primary: -0.5 decay, Secondary: -0.4 (smoother for Elephant Memory)
                    // TITANIUM LEVELS: Gentler decay (-0.2) because structural levels are TARGETS, not just pullbacks
                    float decayConst = isTitCluster ? -0.2 : (isSecondary ? -0.4 : -0.5)
                    float proxDecay = math.exp(decayConst * distAtr)
                    
                    // DUAL-MODE LOGIC
                    if isSecondary
                        // Secondary election: Structural + Shadow Recency (1.25x)
                        effectiveScore := effectiveScore * proxDecay * 1.25
                    else
                        // Primary election: Recency-First Snap (1.5x)
                        effectiveScore := effectiveScore * proxDecay * 1.5

                    // TREND-AWARE WEIGHTING (Clustering 2.0)
                    // In strong trends, favor zones that are closer to price (shallow pullbacks)
                    // If trendBias > 0, we add a bonus for proximity ‚â§ 2 ATR
                    // MOMENTUM OVERRIDE (The "Chase" Fix)
                    // If trend is VERY strong (bias > 0.8), we massively favor the nearest cluster
                    // to ensure the zone is actually actionable.
                    if trendBias > 0.8 and distAtr < 1.5
                        effectiveScore := effectiveScore * 2.0 // Double the score for local zones in strong trends
                    else if trendBias > 0 and distAtr < 2.0
                        // Linear bonus: Max 1.0 at 0 dist, 0.0 at 2.0 dist
                        float trendBonus = trendBias * (1.0 - (distAtr / 2.0))
                        effectiveScore := effectiveScore + trendBonus

                    if effectiveScore > candidateBestScore
                        candidateBestScore := effectiveScore
                        candidateBestIdx := i
    
    // Step 5: ATR Price Gap Filter (Spatial Hysteresis)
    float minDisplacement = 0.5 * safeAtr
    if candidateBestIdx != -1 and defenderIdx != -1 and candidateBestIdx != defenderIdx
        float defenderCenter = array.get(clusterCenters, defenderIdx)
        float challengerCenter = array.get(clusterCenters, candidateBestIdx)
        float displacement = math.abs(challengerCenter - defenderCenter)
        // If too close, force Defender to win
        if displacement < minDisplacement
            candidateBestIdx := defenderIdx
            
    candidateBestIdx

// Helper to harvest Distal Titanium levels
harvestDistal(int count, float[] centers, bool[] isTit, int ex1, int ex2, int startIdx) =>
    int dCount = 0
    if count > 0
        for i = 0 to count - 1
            if i != ex1 and i != ex2 and array.get(isTit, i) and dCount < 5
                array.set(secondaryZoneInfo, startIdx + dCount, array.get(centers, i))
                dCount += 1
    if dCount < 5
        for i = dCount to 4
            array.set(secondaryZoneInfo, startIdx + i, na)

resolveSecondaryZone(int finalClusterCount, float[] clusterCenters, float[] clusterScores, float[] clusterLeaderWeights, bool[] clusterIsTitanium, float[] clusterHighs, float[] clusterLows, float prevEntryL2, float atrVal, int bestIdx, float closePrice, bool isLong) =>
    int secondIdx = -1
    float bestValidScore = -1.0
    float safeAtr = nz(atrVal, 1.0)
    float primCenter = (bestIdx != -1) ? array.get(clusterCenters, bestIdx) : na
    
    // Iterate through ALL clusters to find the best VALID secondary (Filter-First)
    if finalClusterCount > 0
        for i = 0 to finalClusterCount - 1
            if i == bestIdx
                continue
                
            float secCenter = array.get(clusterCenters, i)
            float secScore = array.get(clusterScores, i)
            
            // 1. Separation Filter (0.75 ATR)
            bool isSeparated = na(primCenter) or math.abs(secCenter - primCenter) >= 0.75 * safeAtr
            
            // 2. DIRECTIONAL FILTER (Re-enabled)
            // Long secondaries must be BELOW price (support)
            // Short secondaries must be ABOVE price (resistance)
            bool isCorrectSide = isLong ? (secCenter < closePrice) : (secCenter > closePrice)
            
            // 3. PROXIMITY CONSTRAINT: REMOVED
            // Logic Reversion: Secondary zones typically SHOULD be further away (next target).
            // The previous constraint (sec < prim) killed all valid next-level targets.
            
            if isSeparated and isCorrectSide
                // Found a valid candidate, now calculate its electoral score
                // We use findWinningCluster but just for THIS specific candidate to apply Gaussian/Proximity
                // This is slightly inefficient but ensures the election rules are identical
                // For speed, let's just duplicate the crucial proximal/Gaussian logic here
                
                // ATR Exponential Decay (Secondary: -0.4 constant)
                float distAtr = math.abs(secCenter - closePrice) / safeAtr
                float proxDecay = math.exp(-0.4 * distAtr)
                
                // Final Electoral Score for this candidate
                float electoralScore = secScore * proxDecay * 1.35 // 1.35x Shadow Recency
                
                if electoralScore > bestValidScore
                    bestValidScore := electoralScore
                    secondIdx := i
                    
    secondIdx

// --- 6. CORE RENDERING ENGINE (ZONES & LABELS) ---
// Handles the drawing of Primary and Secondary zones, labels, and entry lines.
// --- 6. CORE RENDERING ENGINE (LOGIC DEPRECATED - MOVED TO MAIN BLOCK) ---

// Renders institutional distal levels (Key Support/Resistance) on the terminal bar.
// Renders institutional distal levels (Key Support/Resistance) on the terminal bar.
renderGhostTitaniumLevels(line[] linesArray, label[] labelsArray) =>
    if barstate.islast
        // Note: For Titanium levels, we use a simple "Delete and Recreate" on the terminal bar 
        // to handle the dynamic number of levels without complex array-to-object mapping.
        // Because it only runs in islast, it is efficient enough.
        for l in linesArray
            line.delete(l)
        array.clear(linesArray)
        for lb in labelsArray
            label.delete(lb)
        array.clear(labelsArray)
            
        for i = 10 to 19
            float lvl = array.get(secondaryZoneInfo, i)
            if not na(lvl) and math.abs(lvl - close) < scaleGuardThreshold
                string txt = i < 15 ? "KEY FLOOR" : "KEY RES"
                line l = line.new(bar_index, lvl, bar_index + FUTURE_OFFSET, lvl, color = color.new(color.gray, 60), width = 1, style = line.style_dashed)
                label lb = label.new(bar_index + FUTURE_OFFSET + 5, lvl, txt, style = label.style_label_left, color = color.new(color.gray, 80), textcolor = color.white, size = size.tiny)
                array.push(linesArray, l)
                array.push(labelsArray, lb)

     
drawInstitutionalVisuals(dayCh, enAv, isNH3, isNL3, plAnc, dTrnd, uTrnd, enGap, isGpU, isGpD, bSwp, sSwp, enFVG, bFVG, sFVG) =>
    if isExpirationDay() and dayCh
        label.new(bar_index, high, 'QUAD\nüßô', color=color.new(color.purple, 20), style=label.style_label_down, size=size.tiny, tooltip='QUAD')
        line.new(bar_index, low, bar_index, high, color=color.new(color.purple, 50), style=line.style_dotted, extend=extend.both)
    if enAv and isNH3
        label.new(bar_index, high, 'ANCHOR\nRES', color=dTrnd?color.red:color.new(color.red, 50), style=label.style_label_down, size=size.tiny)
    if enAv and isNL3 and not na(plAnc)
        label.new(bar_index, low, 'ANCHOR\nSUP', color=uTrnd?color.green:color.new(color.green, 50), style=label.style_label_up, size=size.tiny)
    if enGap and isGpU and math.abs(high[1]-close) < scaleGuardThreshold
        box.new(bar_index-1, high[1], bar_index+FUTURE_OFFSET, low, border_color=color.new(color.green, 70), bgcolor=color.new(color.green,95), text='GAP SUP', text_size=size.tiny)
    if enGap and isGpD and math.abs(low[1]-close) < scaleGuardThreshold
        box.new(bar_index-1, low[1], bar_index+FUTURE_OFFSET, high, border_color=color.new(color.red, 70), bgcolor=color.new(color.red,95), text='GAP RES', text_size=size.tiny)
    if bSwp
        label.new(bar_index-1, na, 'SWEEP\nüßπ', color=uTrnd?color.green:color.new(color.green, 50), style=label.style_label_up, size=size.tiny, tooltip='Liquidity Sweep (Long)', yloc=yloc.belowbar)
    if sSwp
        label.new(bar_index-1, na, 'SWEEP\nüßπ', color=dTrnd?color.red:color.new(color.red, 50), style=label.style_label_down, size=size.tiny, tooltip='Liquidity Sweep (Short)', yloc=yloc.abovebar)
    if enFVG and bFVG and math.abs(high[2]-close) < scaleGuardThreshold
        box.new(bar_index-2, high[2], bar_index, low, border_color=color.new(color.aqua, 30), bgcolor=color.new(color.aqua, 80), text='FVG ‚Üë', text_size=size.tiny, text_color=color.white)
    if enFVG and sFVG and math.abs(low[2]-close) < scaleGuardThreshold
        box.new(bar_index-2, low[2], bar_index, high, border_color=color.new(color.fuchsia, 30), bgcolor=color.new(color.fuchsia, 80), text='FVG ‚Üì', text_size=size.tiny, text_color=color.white)




drawTopWarnings(isSeverelyOverextended, isScoreDivergence, isScoreDivergencePrev, highestRecentBuyScore, buyScore, isBearishScoreDivergence, isBearishScoreDivergencePrev, highestRecentSellScore, sellScore, isRsiCascade, isRsiCascadePrev, rsiWeekly, rsi, rsiIntraday, isTopping, isToppingPrev, isPowerBreakout) =>
    isPowerBreakout ? na :
     isSeverelyOverextended ? label.new(bar_index, high, 'EXTREME\nEXTENSION\n‚ö°', color = color.new(color.red, 0), style = label.style_label_down, textcolor = color.white, size = size.small, tooltip = 'Overextended: Price >50% above 200 EMA.') :
     isScoreDivergence and not isScoreDivergencePrev ? label.new(bar_index, high, 'INTERNAL\nWEAKNESS\nüìâ', color = COL_ORANGE, style = label.style_label_down, textcolor = color.white, size = size.small, tooltip = 'Internal Weakness: Score dropped while price holds highs.') :
     isBearishScoreDivergence and not isBearishScoreDivergencePrev ? label.new(bar_index, low, 'BEAR\nWEAKNESS\nüìà', color = color.new(color.lime, 0), style = label.style_label_up, textcolor = color.white, size = size.small, tooltip = 'Bear Weakness: Sell score dropped while price holds lows.') :
     isRsiCascade and not isRsiCascadePrev ? label.new(bar_index, high, 'RSI\nCASCADE\nüåä', color = COL_ORANGE, style = label.style_label_down, textcolor = color.white, size = size.small, tooltip = 'RSI Cascade: MTF Overbought alignment.') :
     isTopping and not isToppingPrev ? label.new(bar_index, high, 'TOP\nWARNING\n‚ö†Ô∏è', color = color.new(color.red, 0), style = label.style_label_down, textcolor = color.white, size = size.small, tooltip = 'Technical Top Detection.') : na

// --- 7. PREDICTIVE SETUP ENGINE ---
// Detects setups forming before price confirmation (Squeeze, Accumulation, etc).

// VOLATILITY SQUEEZE DETECTION (Bollinger Band inside Keltner Channel)
// When volatility contracts, a big move is coming - we just don't know which direction
// Returns: [isSqueeze, squeezeLength,
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GLOBAL HTF AND SECURITY CACHE (Token Optimization)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
tfS = timeframe.in_seconds()
htf1 = tfS <= 60 ? "5" : tfS <= 300 ? "15" : tfS <= 900 ? "60" : tfS <= 3600 ? "240" : tfS <= 14400 ? "D" : tfS <= 86400 ? "W" : "M"
htf2 = tfS <= 60 ? "60" : tfS <= 300 ? "240" : tfS <= 900 ? "D" : tfS <= 3600 ? "D" : tfS <= 14400 ? "W" : tfS <= 86400 ? "M" : "M"
[htf2PH, htf2PL, htf2S2] = request.security(syminfo.tickerid, htf2, [ta.pivothigh(high, 10, 10), ta.pivotlow(low, 10, 10), ta.sma(close, 200)], lookahead=barmerge.lookahead_off)
[htf1PH, htf1PL, htf1S5, htf1H, htf1L, htf1C] = request.security(syminfo.tickerid, htf1, [ta.pivothigh(high, 10, 10), ta.pivotlow(low, 10, 10), ta.sma(close, 50), high[1], low[1], close[1]], lookahead=barmerge.lookahead_off)
wDns = getHTFDensityLevel("W")
sma50 = globalSma50, sma100 = globalSma100, sma200 = globalSma200
ema50 = ta.ema(close, 50)
detectVolatilitySqueeze(float src, int bbLen, float bbMult, int kcLen, float kcMult) =>
    // Bollinger Bands
    bbBasis = ta.sma(src, bbLen)
    bbDev = bbMult * ta.stdev(src, bbLen)
    bbUpper = bbBasis + bbDev
    bbLower = bbBasis - bbDev
    
    // Keltner Channel
    kcBasis = ta.ema(src, kcLen)
    kcRange = ta.atr(kcLen)
    kcUpper = kcBasis + kcMult * kcRange
    kcLower = kcBasis - kcMult * kcRange
    
    // Squeeze: BB inside KC (low volatility)
    sqzOn = bbLower > kcLower and bbUpper < kcUpper
    sqzOff = bbLower < kcLower or bbUpper > kcUpper
    
    // Momentum for direction (linear regression)
    val = ta.linreg(src - ta.sma(src, bbLen), bbLen, 0)
    
    // Release direction: positive momentum = bullish, negative = bearish
    releaseDir = sqzOff and sqzOn[1] ? (val > 0 ? 1 : -1) : 0
    
    [sqzOn, releaseDir, val]



// SMART MONEY ACCUMULATION/DISTRIBUTION DETECTION
// OBV diverging from price = institutions accumulating (bullish) or distributing (bearish)
// Returns: [isAccumulating, isDistributing, divergenceStrength]
detectSmartMoney(float closePrice, float vol, int lookback) =>
    // On-Balance Volume
    obv = ta.cum(closePrice > closePrice[1] ? vol : closePrice < closePrice[1] ? -vol : 0)
    
    // Smoothed OBV for trend
    obvEma = ta.ema(obv, lookback)
    obvRising = obvEma > obvEma[1]
    // Fix: Raw OBV check prevents lag on gap-ups (Don't call "Distribution" if raw OBV is Pumping)
    obvFalling = obvEma < obvEma[1] and not (obv > obv[1])
    
    // Price trend
    priceEma = ta.ema(close, lookback)
    priceRising = closePrice > priceEma and priceEma > priceEma[1]
    priceFalling = closePrice < priceEma and priceEma < priceEma[1]
    priceFlat = closePrice > 0 and math.abs(closePrice - closePrice[lookback]) / closePrice < 0.02
    
    // Accumulation: OBV rising while price flat or falling (smart money buying)
    isAccumulating = obvRising and (priceFlat or priceFalling)
    
    // Distribution: OBV falling while price flat or rising (smart money selling)
    isDistributing = obvFalling and (priceFlat or priceRising)
    
    // Divergence strength (0-100) with division by zero protection
    float obvDenom = math.abs(obv[lookback])
    obvChange = obvDenom > 0 ? (obv - obv[lookback]) / obvDenom * 100 : 0.0
    priceChange = closePrice[lookback] > 0 ? (closePrice - closePrice[lookback]) / closePrice[lookback] * 100 : 0
    
    // Haircut for Expiration Day (Quad Witching / OpEx Noise)
    isExp = isExpirationDay()
    float quality = isExp ? 0.5 : 1.0
    
    divergenceStrength = math.abs(obvChange - priceChange) * quality
    
    [isAccumulating, isDistributing, divergenceStrength]

// RANGE CONTRACTION DETECTION (ATR Percentile)
// Low ATR = coiled spring = breakout imminent
// Returns: [isContracted, contractionPct]
detectRangeContraction(int atrLen, int lookbackPeriod) =>
    atrNow = ta.atr(atrLen)
    atrHighest = ta.highest(ta.atr(atrLen), lookbackPeriod)
    atrLowest = ta.lowest(ta.atr(atrLen), lookbackPeriod)
    
    // Percentile: 0 = lowest volatility, 100 = highest (with division by zero protection)
    float atrRange = atrHighest - atrLowest
    atrPercentile = atrRange > 0 ? (atrNow - atrLowest) / atrRange * 100 : 50.0
    
    // Contracted if ATR in bottom 20%
    isContracted = atrPercentile < 20
    
    [isContracted, atrPercentile]

// COMBINED PREDICTIVE SETUP SCORE
// Returns a score 0-100 indicating how "ready" a setup is for a move
// Higher = more likely a big move is coming
calcPredictiveSetupScore(bool sqzOn, float sqzMomentum, bool isAccum, bool isDistrib, float divStrength, bool isContracted) =>
    float score = 0.0
    
    // Squeeze active = +30 (building energy)
    if sqzOn
        score := score + 30.0
        // Stronger momentum = more energy coiled (use absolute momentum value)
        score := score + math.min(20.0, math.abs(sqzMomentum) * 5.0)
    
    // Smart money divergence = +25
    if isAccum or isDistrib
        score := score + 25.0
        // Stronger divergence = more conviction
        score := score + math.min(15.0, divStrength / 5.0)
    
    // Range contraction = +10
    if isContracted
        score := score + 10.0
    
    math.min(100.0, score)
// VOLATILITY FORENSIC ENGINE
// Computes probability of price rejection based on ATR and historical deviations
calcVolatilityForensics(float closePrice, float lowPrice) =>
    // 1. Realized/Historical Volatility (HV) - Annualized
    logRets = math.log(closePrice / nz(closePrice[1], closePrice))
    h_v20 = ta.stdev(logRets, 20) * math.sqrt(252) * 100
    h_v252 = ta.stdev(logRets, 252) * math.sqrt(252) * 100

    // 2. Implied Volatility (IV30) Proxy - Annualized Synthetic
    // Bypasses "Invalid symbol" runtime crashes caused by request.security(IV:...)
    // FIX: Uses Yang-Zhang-style range volatility, annualized to match HV units
    vFix = (ta.highest(close, 22) - ta.lowest(low, 22)) / math.max(1, ta.sma(close, 22))
    f_inalIV30 = ta.stdev(vFix, 20) * math.sqrt(252) * 100  // Annualized to match h_v20 units

    // 3. Volatility Stats & Ranks
    i_vRank = ta.percentrank(f_inalIV30, 252)
    i_vHvSpread = ((f_inalIV30 - h_v20) / math.max(0.1, h_v20)) * 100
    [h_v20, h_v252, f_inalIV30, i_vRank, i_vHvSpread]

// STRUCTURAL SAFETY ENGINE
// Validates risk/reward feasibility and detects overextension
checkForensicSafety(float pr, float sma200, float rsiVal, float ivRnk, bool topping, bool overext, bool bottoming, bool underext) =>
    // Normalized Price Deviation (Generic Climax)
    // Using a fixed length of 20 for the base normalization to avoid "series int" errors
    atr20 = ta.atr(20)
    devMean = ta.sma(pr, 20)
    atrDev = (pr - devMean) / math.max(0.1, atr20)
    
    // Manual Z-Score Calculation -> UPGRADED TO PERCENTILE RANK (Non-Parametric)
    // We ask: "Is this deviation in the top 1% of the last 2 years?"
    
    // Recovery Surge Suppression: A climax long is only a 'Top' danger if structurally high.
    rankVerticalL = ta.percentrank(atrDev, 500)
    rankVerticalS = ta.percentrank(atrDev * -1, 500) // Invert for downside
    
    isVerticalCliL = rankVerticalL > 99 and pr > sma200
    isVerticalCliS = rankVerticalS > 99 and pr < sma200

    // Structural Stretch (Price vs 200 SMA)
    d200L = (pr - sma200) / math.max(0.1, ta.atr(200))
    rankStructL = ta.percentrank(d200L, 500)
    
    d200S = (sma200 - pr) / math.max(0.1, ta.atr(200))
    rankStructS = ta.percentrank(d200S, 500)

    // Trigger on 99th Percentile (Top 1%)
    isStructCliL = rankStructL > 99 and pr > sma200
    isStructCliS = rankStructS > 99 and pr < sma200

    // Nuclear RSI
    isNucL = rsiVal > 70
    isNucS = rsiVal < 30

    // Volatility Hardening
    isVolExtL = ivRnk > 90
    isVolExtS = ivRnk > 90

    // Forensic Memory (Stickiness) - Using volatility to scale the memory length
    vRatio = ta.atr(14) / math.max(0.1, ta.sma(ta.atr(14), 200))
    aStick = math.round(math.max(5, math.min(30, 10 / math.max(0.1, vRatio))))
    
    isRiskLRaw = (topping == true) or (overext == true) or isNucL or isVerticalCliL or isStructCliL 
    isRiskSRaw = (bottoming == true) or (underext == true) or isNucS or isVerticalCliS or isStructCliS

    rZoneL = ta.barssince(isRiskLRaw) < aStick
    rZoneS = ta.barssince(isRiskSRaw) < aStick
    [rZoneL, rZoneS, aStick]


// --- 8. PRIMARY ENTRY ENGINE (LONG) ---
// Orchestrates the identification of Long entry zones by harvesting structural levels, 
// institution anchors, and HTF confluence. Returns a tuple of tactical entry data.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UNIFIED ENTRY/EXIT CALCULATION ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
calcEntryExit(bool isLong, float[] fl, bool[] bl, int sPrior, float cBox, float atrMaxMult) =>
    float bScore = 0.0
    levels = array.new_float(0), weights = array.new_float(0), names = array.new_string(0), isTit = array.new_bool(0)
    
    // Unpack Logic
    cPr = array.get(fl, 6), atrV = array.get(fl, 8), adxV = array.get(fl, 19), volAvg = array.get(fl, 20)
    maArr = array.from(array.get(fl, 5), globalSma50, globalSma100, globalSma200, vwma200)
    upV = array.get(bl, 0), dnV = array.get(bl, 1), drvV = array.get(bl, 2), swpV = array.get(bl, 3), prbV = array.get(bl, 4), chpV = array.get(bl, 5)
    
    // Age Mapping: fl[42] = curPivotAge, fl[43] = oppPivotAge (for recency decay)
    int curAge = math.round(array.get(fl, 42))
    int oppAge = math.round(array.get(fl, 43))
    
    anObj = AnchorData.new(9e9, isLong ? "Rec Str L" : "Rec Str H", 0.0)
    
    // 1. Structural Pivots
    kSupRes = array.get(fl, 15)
    if not na(kSupRes) and (isLong ? true : kSupRes > cPr)
        // Structural pivots ALWAYS use full weight - they're where you'd enter IF reversal happens
        processLevel(levels, weights, names, isTit, kSupRes, 5.0, isLong ? "KEY SUP" : "KEY RES", true, cPr, anObj, curAge)

    // 2. Trend & Volatility
    strTrnd = prbV or (nz(adxV) > 30 and (isLong ? upV : dnV))
    atrP = nz(atrV / math.max(1, cPr), 0.005)
    TOL = math.max(0.003, 0.4 * atrP) * (strTrnd ? 0.7 : 1.0)
    
    // Trend Bias (Clustering 2.0): Favor momentum in strong trends
    float trendBias = 0.0
    if (isLong and upV) or (not isLong and dnV)
        trendBias := (strTrnd or nz(adxV) > 25) ? 1.0 : 0.5
    
    // 3. Macro & Institutional
    whlV = array.get(fl, 13), insV = array.get(fl, 38), swpV_lvl = array.get(fl, 14)
    if not na(whlV) and (isLong ? whlV < cPr : whlV > cPr) and math.abs(whlV - cPr) < cPr * 0.5
        processLevel(levels, weights, names, isTit, whlV, 0.5, "Whale AVWAP", false, cPr, anObj, 0)
    if not na(insV) and (isLong ? insV < cPr : insV > cPr) and math.abs(insV - cPr) < cPr * 0.5
        processLevel(levels, weights, names, isTit, insV, 6.0, "Inst Anchor", true, cPr, anObj, 0)
    if swpV and not na(swpV_lvl) and (isLong ? swpV_lvl < cPr : swpV_lvl > cPr) and math.abs(swpV_lvl - cPr) < cPr * 0.5
        processLevel(levels, weights, names, isTit, swpV_lvl, calcEvidenceScore(swpV_lvl, maArr, 0.5, volAvg, globalLow100, globalHigh100, atrV, preWPH, preWPL, preMPH, preMPL), "Sweep", false, cPr, anObj, 0)

    if drvV
        bTop = isLong ? array.get(fl, 39) : cBox, bBot = isLong ? cBox : array.get(fl, 40)
        l = isLong ? (cPr > bTop ? bTop : bBot) : (cPr < bBot ? bBot : bTop)
        if not na(l) and math.abs(l - cPr) < cPr * 0.5
            processLevel(levels, weights, names, isTit, l, 2.0, "Darvas", true, cPr, anObj, 0)

    // 4. Macro Loop
    yO = array.get(fl, 27), qO = array.get(fl, 28), wExp = array.get(fl, 29), pwV = array.get(fl, 30), mO = array.get(fl, 31), wO = array.get(fl, 32)
    float crossLvl = isLong ? array.get(fl, 36) : array.get(fl, 37)
    processLevel(levels, weights, names, isTit, crossLvl, 5.0, isLong ? "GOLDEN X" : "DEATH X", true, cPr, anObj, 0)
    mLvls = array.from(yO, qO, mO, wO, wExp, pwV, array.get(fl, 34), array.get(fl, 35), array.get(fl, 33))
    mNms = array.from("Y.O", "Q.O", "M.O", "W.O", isLong ? "W.EXP.L" : "W.EXP.H", isLong ? "PW.L" : "PW.H", "Y.L", "52W.L", "Y.H")
    mWgts = array.from(5.0, 4.0, 4.0, 3.5, 2.5, 3.0, 5.0, 5.0, 4.5)
    mTits = array.from(true, true, true, false, false, false, true, true, true)

    for i = 0 to 8
        l = array.get(mLvls, i)
        // Tighten collection buffer to 0.5% to ensure Entry Zones are truly below price (for longs)
        if not na(l) and (isLong ? l < cPr * 1.005 : l > cPr * 0.995) and math.abs(l - cPr) < cPr * 0.7
            processLevel(levels, weights, names, isTit, l, array.get(mWgts, i), array.get(mNms, i), array.get(mTits, i), cPr, anObj, 0)

    // 5. HTF Loop
    hL = array.from(isLong?htf2PL:htf2PH, isLong?htf2PH:htf2PL, wDns, htf2S2, isLong?htf1PL:htf1PH, isLong?htf1PH:htf1PL, isLong?htf1L:htf1H, htf1C, htf1S5, sma200, sma100, sma50, ema50, array.get(fl, 12))
    hH = array.from(3.0, 2.0, 2.0, 3.0, 2.0, 1.0, 2.0, 2.0, 2.0, 4.0, 2.5, 2.0, 1.5, 1.0)
    hN = array.from("H2.P", "H2.F", "W.DNS", "H2.S2", "H1.P", "H1.F", "H1.L", "H1.C", "H1.S5", "S200", "S100", "S50", "E50", "BB")
    hT = array.from(false, false, false, true, false, false, false, false, false, true, false, false, false, false)
    hA = array.from(oppAge, oppAge, 0, 0, curAge, curAge, 0, 0, 0, 0, 0, 0, 0, 0)

    for i = 0 to 13
        l = array.get(hL, i)
        if not na(l) and (isLong ? l < cPr : l > cPr) and math.abs(l - cPr) < cPr * 0.5
            processLevel(levels, weights, names, isTit, l, calcEvidenceScore(l, maArr, array.get(hH, i), volAvg, globalLow100, globalHigh100, atrV, preWPH, preWPL, preMPH, preMPL), array.get(hN, i), array.get(hT, i), cPr, anObj, array.get(hA, i))

    // 6. PSYCHOLOGICAL ROUND NUMBERS
    // Markets react at round numbers due to collective trader behavior (order clustering)
    // For stocks >$50: multiples of 10 (620, 630, 640)
    // For stocks <$50: multiples of 5 (25, 30, 35)
    float roundStep = cPr > 50 ? 10.0 : 5.0
    float nearestRound = math.floor(cPr / roundStep) * roundStep
    
    // Check 3 round numbers in each direction
    for offset = -3 to 3
        float rndLvl = nearestRound + (offset * roundStep)
        if rndLvl > 0 and (isLong ? rndLvl < cPr * 0.995 : rndLvl > cPr * 1.005) and math.abs(rndLvl - cPr) < cPr * 0.1
            // Weight: 3.0 base (behavioral, not structural) + evidence bonus
            float rndScore = calcEvidenceScore(rndLvl, maArr, 1.5, volAvg, globalLow100, globalHigh100, atrV, preWPH, preWPL, preMPH, preMPL)
            if rndScore > 0
                processLevel(levels, weights, names, isTit, rndLvl, rndScore, "ROUND", false, cPr, anObj, 0)


    // Clustering and Election
    sortByWeight(levels, weights, names, isTit)
    numL = array.size(levels)
    
    float zH = 0.0, float zL = 0.0, float e = 0.0, float bSc = 0.0, string an = ""
    var int zScIdx = na

    if numL > 0
        if numL == 1
            l = array.get(levels, 0)
            zL := l
            zH := l
            e := l
            an := array.get(names, 0)
            bSc := array.get(weights, 0)
        else
            cCs = array.new_float(0)
            cSs = array.new_float(0)
            cHs = array.new_float(0)
            cLs = array.new_float(0)
            cNs = array.new_string(0)
            cLds = array.new_string(0)
            cLW = array.new_float(0)
            cTs = array.new_float(0)
            cTi = array.new_bool(0)
            
            for i = 0 to numL - 1
                l = array.get(levels, i)
                w = array.get(weights, i)
                n = array.get(names, i)
                t = array.get(isTit, i)
                
                if (isLong ? l < cPr * 1.003 : l > cPr * 0.997)
                    mrd = false
                    sz = array.size(cCs)
                    if sz > 0
                        for j = 0 to sz - 1
                            cC = array.get(cCs, j)
                            if math.abs(l - cC) / cC <= TOL
                                oSc = array.get(cSs, j)
                                oT = array.get(cTs, j)
                                nSc = oSc + w
                                nT = array.get(cTi, j) ? cC : (oT + (l * w)) / nSc
                                array.set(cSs, j, nSc + (t ? 1.5 : 0.5))
                                array.set(cTs, j, nT * nSc)
                                array.set(cCs, j, nT)
                                if t
                                    array.set(cTi, j, true)
                                    array.set(cHs, j, math.max(array.get(cHs, j), l))
                                    array.set(cLs, j, math.min(array.get(cLs, j), l))
                                if w > array.get(cLW, j)
                                    array.set(cLds, j, n)
                                    array.set(cLW, j, w)
                                mrd := true
                                break
                    if not mrd
                        array.push(cCs, l)
                        array.push(cSs, w)
                        array.push(cTs, l * w)
                        array.push(cHs, l)
                        array.push(cLs, l)
                        array.push(cNs, n)
                        array.push(cLds, n)
                        array.push(cLW, w)
                        array.push(cTi, t)
            
            bIdx = findWinningCluster(array.size(cCs), cCs, cSs, cLW, cTi, array.get(fl, 17), nz(atrV), -1, cPr, false, trendBias)
            
            // DESPERATION FALLBACK: If no cluster found due to trend-distance crush, 
            // pick the closest valid structural cluster. 
            // This ensures parabolic moves (CVNA) still show a meaningful pullback target.
            if bIdx == -1 and array.size(cCs) > 0
                float minDist = 999999.0
                for i = 0 to array.size(cCs) - 1
                    float dist = math.abs(array.get(cCs, i) - cPr)
                    if dist < minDist
                        minDist := dist
                        bIdx := i

            sIdx = resolveSecondaryZone(array.size(cCs), cCs, cSs, cLW, cTi, cHs, cLs, array.get(secondaryZoneInfo, 6), nz(atrV), bIdx, cPr, isLong)
            
            // ZONE PROMOTION (The Dashboard Fix)
            // In a strong trend, the "Secondary" zone (shallow pullback) is often more relevant 
            // than the "Primary" zone (deep historical support).
            // ENHANCEMENT: Mass-Aware Promotion. We only promote if the secondary has significant structural weight (>60% of primary).
            // This prevents "slivers" from overriding "bases".
            if bIdx != -1 and sIdx != -1 and trendBias > 0
                float pDist = math.abs(array.get(cCs, bIdx) - cPr)
                float sDist = math.abs(array.get(cCs, sIdx) - cPr)
                float pWeight = array.get(cSs, bIdx)
                float sWeight = array.get(cSs, sIdx)
                
                if sDist < pDist and sWeight > (pWeight * 0.6)
                    // Swap indices if closer AND structurally significant
                    int tempIdx = bIdx
                    bIdx := sIdx
                    sIdx := tempIdx

            // Distal Harvesting (Global Array Populate 10-19)
            harvestDistal(array.size(cCs), cCs, cTi, bIdx, sIdx, isLong ? 10 : 15)

            if bIdx >= 0
                float centerVal = array.get(cCs, bIdx)
                zL := array.get(cLs, bIdx)
                zH := array.get(cHs, bIdx)
                
                // SNIPER REFINEMENT: Volatility-Scaled Width
                // Formula: max(ATR * 0.5, min(1% of price, ATR * 0.8))
                // - Floor: ATR * 0.5 prevents flickering on low-vol days
                // - Ceiling: min(1%, 0.8 ATR) keeps zones tight
                float atrFloor = atrV * 0.5
                float atrCeiling = atrV * 0.8
                float pctCeiling = cPr * 0.01
                float maxWidth = math.max(atrFloor, math.min(pctCeiling, atrCeiling))
                zH := math.min(zH, centerVal + (maxWidth / 2))
                zL := math.max(zL, centerVal - (maxWidth / 2))
                
                // Min height: 0.25 ATR (prevent razor-thin zones)
                float minH = atrV * 0.25
                if (zH - zL) < minH
                    zH := centerVal + (minH * 0.5)
                    zL := centerVal - (minH * 0.5)
                
                e := centerVal
                bSc := array.get(cSs, bIdx)
                an := array.get(cLds, bIdx)
                
                // Assign Secondary to Global Arrays
                int offSetI = isLong ? 0 : 3
                int offSetC = isLong ? 6 : 7
                int offSetN = isLong ? 0 : 1
                
                if sIdx >= 0
                    float z2C = array.get(cCs, sIdx)
                    float z2H = array.get(cHs, sIdx)
                    float z2L = array.get(cLs, sIdx)
                    z2H := math.min(z2H, z2C * (1 + maxWidth))
                    z2L := math.max(z2L, z2C * (1 - maxWidth))
                    if (z2H - z2L) < minH
                        z2H := z2C + (minH * 0.5)
                        z2L := z2C - (minH * 0.5)
                    
                    array.set(secondaryZoneInfo, offSetC, z2C)
                    array.set(secondaryZoneInfo, offSetI, z2H)
                    array.set(secondaryZoneInfo, offSetI + 1, z2L)
                    array.set(secondaryZoneInfo, offSetI + 2, array.get(cSs, sIdx))
                    array.set(secondaryZoneNames, offSetN, array.get(cLds, sIdx))
                else
                    // Clear secondary
                    array.set(secondaryZoneInfo, offSetI, na)
                    array.set(secondaryZoneInfo, offSetI + 1, na)
                    array.set(secondaryZoneInfo, offSetI + 2, 0.0)
                    array.set(secondaryZoneNames, offSetN, "")

    float mRP = array.get(fl, 26) // Dynamic Max Risk (3% or 5%)
    
    // --- STOP LOSS LOGIC REDESIGN ---
    // Priority 1: Use the Winning Cluster's Structural Limit (zL for Long, zH for Short)
    // This respects the "Key Support" or "MA Cluster" that actually triggered the signal.
    float structuralStop = isLong ? zL : zH

    // Priority 2: Fallback to Raw Swing Low if Zone is invalid or weirdly placed
    if structuralStop == 0.0 or (isLong ? structuralStop > e : structuralStop < e)
        structuralStop := array.get(fl, 7)

    // Apply Buffer (0.5% Breathing Room below structure)
    // We use a blend of % buffer and ATR to ensure it's not too tight
    float buffer = math.max(e * 0.005, atrV * 0.5)
    float sL_struct = isLong ? (structuralStop - buffer) : (structuralStop + buffer)

    // Priority 3: Supreme Law Cap (Hard Limit)
    // sL must never be wider than mRP (5% Stocks / 3% ETFs)
    float sL_capped = isLong ? math.max(sL_struct, e * (1.0 - mRP)) : math.min(sL_struct, e * (1.0 + mRP))

    // Final Assignment
    sL = e > 0 ? sL_capped : 0.0

    // Toxic Check: If the CAPPED stop overrides the STRUCTURAL stop significantly, it's dangerous.
    // Logic: If we had to clamp the stop (sL_capped != sL_struct) AND the clamped stop is 
    // inside the danger zone (e.g. above Zone Low), it's Toxic.
    bool wasClamped = isLong ? (sL_capped > sL_struct) : (sL_capped < sL_struct)
    bool isToxic = isLong ? (sL >= zL) : (sL <= zH)
    
    if wasClamped and isToxic
        bSc := -100.0
    rTp = e > 0 ? e + (isLong ? 1 : -1) * (math.abs(e - sL) * array.get(fl, 9)) : 0.0
    finalTP = rTp
    // Zone Persistence
    var float prevZC = na
    float curZC = (zH + zL) / 2.0
    if bSc > 0
        if na(prevZC) or math.abs(curZC - prevZC) > (atrV * 0.5)
            zScIdx := bar_index
            prevZC := curZC
        else
            prevZC := (prevZC * 0.7) + (curZC * 0.3)
    else
        prevZC := na

    [e, sL, finalTP, rTp, zH, zL, an, bSc, zScIdx]


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SINGLE ENTRY SYSTEM  
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


// 1. REAL-TIME CONFIRMATION MODEL
// Combines multiple RT indicators for high-confidence signals
calcRealTimeConfirmation(sBullMom, accPos, bullClose, sBuyPress, sBearMom, accNeg, bearClose, sSellPress) =>
    // High confidence signals (ALL conditions met)
    rtBullConf = sBullMom and accPos and bullClose and sBuyPress
    rtBearConf = sBearMom and accNeg and bearClose and sSellPress
    
    // Moderate signals (At least 2 of 4 conditions)
    rtBullSig = (sBullMom ? 1 : 0) + (accPos ? 1 : 0) + (bullClose ? 1 : 0) + (sBuyPress ? 1 : 0) >= 2
    rtBearSig = (sBearMom ? 1 : 0) + (accNeg ? 1 : 0) + (bearClose ? 1 : 0) + (sSellPress ? 1 : 0) >= 2
    
    [rtBullConf, rtBearConf, rtBullSig, rtBearSig]

// 2. ELDER FORCE INDEX MODEL
// Detects subtle shifts in buying/selling pressure before price moves
calcElderForceIndex(cls, vol, uptr, dntr, wkUptr, wkDntr) =>
    forceRaw = (cls - cls[1]) * vol
    forceIdx = ta.ema(forceRaw, 13)
    
    buySig = forceIdx < 0 and forceIdx > forceIdx[1] and uptr
    sellSig = forceIdx > 0 and forceIdx < forceIdx[1] and dntr
    
    screen3Buy = cls > high[1] and buySig and wkUptr
    screen3Sell = cls < low[1] and sellSig and wkDntr
    
    // Triple Screen Validation
    screen1Bull = wkUptr
    screen1Bear = wkDntr
    screen2Buy = forceIdx < 0 or forceIdx < forceIdx[1]
    screen2Sell = forceIdx > 0 or forceIdx > forceIdx[1]
    
    tsBuyValid = screen1Bull and screen2Buy
    tsSellValid = screen1Bear and screen2Sell
    
    stBuy = forceIdx < ta.lowest(forceIdx, 20) * 0.5 and uptr
    stSell = forceIdx > ta.highest(forceIdx, 20) * 0.5 and dntr
    
    [forceIdx, buySig, sellSig, screen3Buy, screen3Sell, tsBuyValid, tsSellValid, stBuy, stSell]

// 3. ELDER IMPULSE SYSTEM MODEL
// Prevents counter-trend disasters by checking momentum alignment
calcElderImpulse(cls, dayWk, mainMacdHist, mainEma13) =>
    impulseEMA = mainEma13
    emaRising = impulseEMA > impulseEMA[1]
    emaFalling = impulseEMA < impulseEMA[1]
    
    // Mid-week Override (Tue-Thu) for faster signals
    isMidWeek = dayWk >= dayofweek.tuesday and dayWk <= dayofweek.thursday
    [_, _, fastHist] = ta.macd(cls, 9, 21, 7)
    impulseHist = isMidWeek ? fastHist : mainMacdHist
    
    histRising = impulseHist > impulseHist[1]
    histFalling = impulseHist < impulseHist[1]
    
    impModeGreen = emaRising and histRising
    impModeRed = emaFalling and histFalling
    impModeBlue = not impModeGreen and not impModeRed
    
    [impModeGreen, impModeRed, impModeBlue]

// 4. WEINSTEIN STAGE ANALYSIS MODEL
// Identifies major trend stages (Basing, Advancing, Topping, Declining)
// 4. WEINSTEIN STAGE ANALYSIS MODEL (2.0 Optimized)
// Identifies major trend stages (Basing, Advancing, Topping, Declining)
// ENHANCEMENT: Adds Relative Strength (RS) and Slope Acceleration for predictive power.
calcWeinsteinStage(cls, vol, isChp, idxCls, idxSMA) =>
    // Hull MA for faster stage detection (reduces lag ~50% vs SMA)
    wMA = ta.hma(cls, 150)
    wSlope = (wMA - wMA[10]) / math.max(1, wMA[10]) * 100
    wSlopePrev = (wMA[10] - wMA[20]) / math.max(1, wMA[20]) * 100
    
    // 1. RELATIVE STRENGTH (RS) - The "Alpha" Factor
    // Stock is outperforming the index (SPY/QQQ)
    float rsRatio = not na(idxCls) ? cls / idxCls : 1.0
    float rsEMA = ta.ema(rsRatio, 50) // Smooth RS trend
    bool hasRelStrength = rsRatio > rsEMA
    
    // 2. SLOPE ACCELERATION - The "Momentum" Factor
    // Trend is speeding up (Second Derivative)
    float slopeAccel = wSlope - wSlopePrev
    bool isAccelerating = wSlope > 0 and slopeAccel > 0
    
    prAbove = cls > wMA
    prBelow = cls < wMA
    
    slopeRise = wSlope > 0.5
    slopeFall = wSlope < -0.5
    slopeFlat = not slopeRise and not slopeFall
    
    // Volume Confirmation
    volMA = ta.sma(vol, 50)
    volInc = vol > volMA and volMA > volMA[10]
    
    // Stage Declarations 
    // Stage 2: Advancing (Primary Buy) - Geometric Definition
    st2Adv = prAbove and slopeRise 
    // Stage 4: Declining (Primary Sell)
    st4Dec = prBelow and slopeFall
    // Stage 3: Topping (Exit)
    st3Top = prAbove and slopeFlat
    // Stage 1: Basing (Wait)
    st1Base = prBelow and slopeFlat
    
    // Sub-stages & Recovery Logic (The V-Bottom Fix)
    // If Price > MA but Slope is still falling, checks acceleration.
    // If accelerating UP, it's RECOVERY. If not, it's a BEAR RALLY.
    st2Pull = prBelow and slopeRise // Buying opp in uptrend
    st4Rec = prAbove and slopeFall and isAccelerating // Recovery Mode (OKLO Fix)
    st4Rally = prAbove and slopeFall and not isAccelerating // Bear Rally (Shorting opp)
    
    // SHORT-TERM MOMENTUM OVERRIDE (Crash Detection)
    // If price drops >5% in 7 bars while above MA, this is distribution (Stage 3), not advancing
    float shortTermDrop = (cls - cls[7]) / cls[7] * 100
    bool isSharpSelloff = shortTermDrop < -5.0 and prAbove
    
    // Determine Stage (with override)
    // 0=Undefined, 1=Base, 2=Adv, 3=Top, 4=Dec, 5=Recovery
    stg = isSharpSelloff ? 3 : st2Adv ? 2 : st2Pull ? 2 : st4Dec ? 4 : st4Rec ? 5 : st4Rally ? 4 : st3Top ? 3 : st1Base ? 1 : 0
    
    [stg, wMA, volInc, volMA, hasRelStrength, isAccelerating]

// Symbol Context
isETF = syminfo.type == "fund" or syminfo.type == "index"

// EXIT STRATEGY - Livermore's "Let Winners Run" vs Fixed Targets
minSharpeStocks = 0.20
minSharpeETF = 0.10
maxDrawdownStocks = -60.0
maxDrawdownETF = -50.0

// PART 1B: MODULAR HELPER FUNCTIONS (Top Detection & Analysis)

// Function to check for Overextended Conditions (Price vs MAs, RSI, BB)
checkOverextended(float price, float maShort, float maLong, float rsiVal, float bbUpperVal, int rsiThresh, int rsiExtremeThresh) =>
    // Price vs MA200 deviation
    distFromMA200 = maLong > 0 ? (price - maLong) / maLong * 100 : 0
    isExtendedFromMA200 = distFromMA200 > 30 // >30% above MA200
    isVeryExtendedFromMA200 = distFromMA200 > 50 // >50% is extreme

    // Price vs MA20 deviation -> UPGRADED TO PERCENTILE RANK
    distFromMA20 = maShort > 0 ? (price - maShort) / maShort * 100 : 0
    rankMA20 = ta.percentrank(distFromMA20, 500)
    isExtendedFromMA20 = rankMA20 > 99 // Top 1% of deviations in last 2 years

    // RSI Extremes
    rsiExtremeOB = rsiVal > rsiThresh
    rsiNuclearOB = rsiVal > rsiExtremeThresh

    // Bollinger Band Extension
    aboveUpperBB = price > bbUpperVal * 1.02

    // Combined Logic
    isOver = (isExtendedFromMA200 or isExtendedFromMA20) and (rsiExtremeOB or aboveUpperBB)
    isSevere = isVeryExtendedFromMA200 or (isExtendedFromMA200 and rsiNuclearOB)
    [isOver, isSevere]

// Downside version
checkOverextendedDown(float price, float maShort, float maLong, float rsiVal, float bbLowerVal) =>
    distFromMA200 = maLong > 0 ? (price - maLong) / maLong * 100 : 0
    isExtendedFromMA200 = distFromMA200 < -30 
    distFromMA20 = maShort > 0 ? (price - maShort) / maShort * 100 : 0
    isExtendedFromMA20 = distFromMA20 < -15
    rsiOS = rsiVal < 30
    belowLowerBB = price < bbLowerVal * 0.98
    isUnder = (isExtendedFromMA200 or isExtendedFromMA20) and (rsiOS or belowLowerBB)
    isUnder

// Function to check for RSI Cascade (Multi-Timeframe Overbought)
checkRsiCascade(float rsiCurrent, float rsiW, float rsiIntra, bool enabled, int threshold) =>
    // Cascade Trigger: Weekly is stressed AND (Daily OR Intraday is stressed)
    enabled and rsiW > threshold and (rsiCurrent > threshold or rsiIntra > threshold)

// Function to check for Score Divergence (Internal Weakness)
// Works for both Buy (Top) and Sell (Bottom) divergence
checkScoreDivergence(float currentPrice, float currentScore, float recentPeakPrice, float recentPeakScore, bool enabled, bool isBearish) =>
    isDiv = false
    if enabled
        if not isBearish // Top Detection (Buy Score drops while Price High)
            // Price > 95% of peak, Score dropped >= 40 points (2.5 Sigma - Massive Shift)
            if currentPrice >= recentPeakPrice * 0.95 and (recentPeakScore - currentScore) >= 40
                isDiv := true
        else // Bottom Detection (Sell Score drops while Price Low)
            // Price < 105% of low, Score dropped >= 40 points (2.5 Sigma - Massive Shift)
            if currentPrice <= recentPeakPrice * 1.05 and (recentPeakScore - currentScore) >= 40
                isDiv := true
    isDiv

// Function to check for RSI Failure Swing (The "M" Pattern)
// Function to check for RSI Failure Swing (The "M" Pattern)
checkRsiFailureSwing(float rsiVal, bool bearishDiv) =>
    // If we have divergence AND RSI is now breaking below the recent swing low
    lowestRsi = ta.lowest(rsiVal, 5)
    bearishDiv and rsiVal < lowestRsi[1]

// Z-Score Helper Function
calcZScore(src, len) =>
    mean = ta.sma(src, len)
    dev = ta.stdev(src, len)
    (dev > 0) ? (src - mean) / dev : 0

// Function to calculate trend scored VWAP (Institutional Standard)
// Anchors to a specific condition (e.g., New 3-Month High)
calcAvwap(bool anchorCondition) =>
    var float sumSrcVol = 0.0
    var float sumVol = 0.0
    var bool anchorFound = false
    if anchorCondition
        sumSrcVol := 0.0
        sumVol := 0.0
        anchorFound := true
    
    if anchorFound
        sumSrcVol := sumSrcVol + close * volume
        sumVol := sumVol + volume
    
    (anchorFound and sumVol != 0) ? sumSrcVol / sumVol : na


// Function to Calculate Efficiency Ratio (Fractal Efficiency)
// Measures Trend Persistency vs Noise (Kaufman's ER)
// Returns 0.0 (Random/Choppy) to 1.0 (Efficient Trend)
calcEfficiencyRatio(int length) =>
    // Shortest path (Net Change)
    netChange = math.abs(close - close[length])
    // Actual path (Sum of absolute individual changes)
    totalPath = math.sum(math.abs(close - close[1]), length)
    // Efficiency Ratio (ER)
    // If ER is High (>0.3), market is Trending
    // If ER is Low (<0.2), market is Chopping (Random Walk)
    er = totalPath != 0 ? netChange / totalPath : 0.0
    er

// Function to Detect Liquidity Sweeps (Stop Hunts)
// Logic: Price breaks swing point but closes back inside range
checkLiquiditySweep(float closePrice, float lowPrice, float highPrice, float pivotLow, float pivotHigh, bool isSupWeak, bool isResWeak) =>
    bullishSweep = false
    bearishSweep = false
    if not na(pivotLow)
        // Bullish Sweep: Low breaks pivot low, but Close is above it (Ignore if support is weakened)
        if lowPrice < pivotLow and closePrice > pivotLow and not isSupWeak
            bullishSweep := true
    if not na(pivotHigh)
        // Bearish Sweep: High breaks pivot high, but Close is below it (Ignore if resistance is weakened)
        if highPrice > pivotHigh and closePrice < pivotHigh and not isResWeak
            bearishSweep := true
    // Return signal AND the level that was swept (using the current low/high as the trigger point)
    [bullishSweep, bearishSweep, lowPrice, highPrice]

// Function to Detect Fair Value Gaps (FVG)
// Logic: 3-candle pattern with gap between 1st and 3rd candle
checkFVG(float high2, float low0, float low2, float high0) =>
    bullishFVG = high2 < low0
    bearishFVG = low2 > high0
    [bullishFVG, bearishFVG]


// PART 2: TREND ANALYSIS

maSprint = ta.ema(close, maSprintLength) // The Sprint Line
maHull = ta.hma(close, maHullLength)     // The Zero-Lag Baseline
ma1 = ta.ema(close, ma1Length) // Restored
ma2 = ta.ema(close, ma2Length)
ma3 = ta.ema(close, ma3Length)

// VISUALS: Hybrid Sprint Cloud
// Plot Lines (Thin)
plotSprint = plot(maSprint, 'Sprint Line (EMA 5)', color.new(color.aqua, 20), 1)
plotHull = plot(maHull, 'Hull Baseline (HMA 20)', color.new(color.yellow, 20), 1)
plot(ma1, 'MA 20', color.new(color.blue, 50), 1) // Restored Plot
plot(ma2, 'MA 50', color.new(COL_ORANGE, 50), 1)
plot(ma3, 'MA 200', color.new(color.red, 30), 2)

// Fill Cloud
cloudColor = maSprint > maHull ? color.new(color.lime, 80) : color.new(color.red, 80)
fill(plotSprint, plotHull, cloudColor, 'Sprint Cloud')

// TREND LOGIC (Hybrid Speed)
// Fast Trend: Defined by the Sprint Cloud
isFastUptrend = maSprint > maHull
isFastDowntrend = maSprint < maHull
isSniperUptrend = isFastUptrend // Alias for compatibility
isSniperDowntrend = isFastDowntrend // Alias for compatibility
hma20 = maHull // Alias for compatibility

// Institutional Override: Price vs VWMA 200
isInstBull = close > vwma200
isInstBear = close < vwma200  // FIX A: Added for symmetric trend detection

// LEVEL VALIDATION SYSTEM (The "Correction" Check)
// Checks if price has actually reacted to this level in the past 50 bars
// OPTIMIZATION: Uses ATR for dynamic precision and Time-Decay for recency bias.
calcReactions(series float srcLow, series float lvl, int len, float atrVal) =>
    float count = 0.0
    float safeAtr = nz(atrVal, srcLow * 0.01) // Default to 1% if ATR unset
    for i = 1 to len 
        // Dynamic Threshold: 0.5 * ATR (tighter precision than fixed %)
        if not na(lvl[i]) and math.abs(srcLow[i] - lvl[i]) < (safeAtr * 0.5)
            // Time Decay: Recent reactions are weighted higher
            // Linear decay from 1.0 (recent) to 0.5 (oldest)
            float weight = 1.0 - (0.5 * (float(i) / float(len)))
            count += weight
    count


// Calculate scores for Sniper Levels
atrVal_Global = ta.atr(14) // Moved here to ensure scope availability for Sniper Logic
scoreVWMA = calcReactions(low, vwma200, 50, atrVal_Global)
scoreHMA = calcReactions(low, maHull, 50, atrVal_Global)
// For Bollinger, use lower band
[_, _, bbLowerSniper] = ta.bb(close, 20, 2)
scoreBB = calcReactions(low, bbLowerSniper, 50, atrVal_Global)



// INDICATOR DECLARATIONS
rsi = ta.rsi(close, rsiLength)
[macdLine, signalLine, histLine] = ta.macd(close, macdFast, macdSlow, macdSignal)

// PART 2A: MULTI-TIMEFRAME ANALYSIS (de Prado's Hierarchical Approach)
// Consolidating all MTF requests into single calls per timeframe

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INSTITUTIONAL MACRO HUB
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DYNAMIC INDEX SELECTION (STOCKS ONLY)
string indexTicker = "SPY" // Default
if syminfo.prefix == "NASDAQ"
    indexTicker := "QQQ"

[indexClose, indexSMA200] = request.security(indexTicker, "D", [close[1], ta.sma(close, 200)[1]], lookahead = barmerge.lookahead_off)
marketBullish = not na(indexClose) and indexClose > indexSMA200
marketBearish = not na(indexClose) and indexClose < indexSMA200
marketClimateScore = marketBullish ? 1.0 : -1.0 


float daysToEarnings = na
bool earningsDanger = false

// Institutional Calendar Levels (Elephant Memory)
// Institutional Calendar Levels (Elephant Memory)
// Consolidated HTF requests to prevent "Too many security calls" while maintaining user-selected lookahead.
[yOpenMacro, yHighMacro, yLowMacro] = request.security(syminfo.tickerid, "12M", [open, high, low], lookahead = barmerge.lookahead_off)
qOpenMacro = request.security(syminfo.tickerid, "3M", open, lookahead = barmerge.lookahead_off)
mOpenMacro = request.security(syminfo.tickerid, "M", open, lookahead = barmerge.lookahead_off)
[wOpenMacro, wCloseM, wAtrM, pwHighM, pwLowM] = request.security(syminfo.tickerid, "W", [open, close[1], ta.atr(14)[1], high[1], low[1]], lookahead = barmerge.lookahead_off)
wExpectedLower = wCloseM - wAtrM
wExpectedUpper = wCloseM + wAtrM

// Master Crossover Capture (Instititutional 50/200 SMA Cross Prices)
[gcPrice, dcPrice] = request.security(syminfo.tickerid, "D", [ta.valuewhen(ta.crossover(ta.sma(close, 50), ta.sma(close, 200)), close, 0), ta.valuewhen(ta.crossunder(ta.sma(close, 50), ta.sma(close, 200)), close, 0)], lookahead = barmerge.lookahead_off)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INSTITUTIONAL ANCHORS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
highest3M = ta.highest(high, 63)
lowest3M = ta.lowest(low, 63)

// Anchor Triggers: ONLY on Significant Institutional Events (Trader Logic)
isNewPriceHigh = high > highest3M[1]
isNewPriceLow  = low < lowest3M[1]
isVolClimax    = volume > volAvg20 * 1.5
// Standardized Pivot Calls (Ensures consistency on every bar)
trendPH5  = ta.pivothigh(high, 5, 2)
trendPL5  = ta.pivotlow(low, 5, 2)
trendPH10 = ta.pivothigh(high, 10, 10)
trendPL10 = ta.pivotlow(low, 10, 10)

isStructuralP  = not na(trendPH5)
isStructuralB  = not na(trendPL5)

// Sweep variable calculation for institutional strategy integration.
bullSweepTrend = (low < trendPL10) and close > trendPL10
bearSweepTrend = (high > trendPH10) and close < trendPH10

// ANCHOR PERSISTENCE (Fix Circular Dependency)
var float lastAnchorHigh = high
var float lastAnchorLow  = low

// ATR Check (Global Scope - Defined above for Sniper Logic)
// atrVal_Global already defined


// History-Dependent Calculations (Must execute on every bar for consistency)
barsSinceLastHigh3M = ta.barssince(ta.change(highest3M) != 0)
barsSinceLastLow3M  = ta.barssince(ta.change(lowest3M) != 0)

// Hybrid Trigger: Inst Event OR Price Expansion (>2 ATR) OR Time Decay (>20 bars of new highs)
isNewHigh3MSig = isNewPriceHigh and (isVolClimax or isStructuralP or bearSweepTrend or (barsSinceLastHigh3M > 20) or (high > (lastAnchorHigh + atrVal_Global * 2)))
isNewLow3MSig  = isNewPriceLow  and (isVolClimax or isStructuralB or bullSweepTrend or (barsSinceLastLow3M  > 20) or (low  < (lastAnchorLow  - atrVal_Global * 2)))

avwapHigh = calcAvwap(isNewHigh3MSig) 
avwapLow = calcAvwap(isNewLow3MSig)

if isNewHigh3MSig
    lastAnchorHigh := avwapHigh
if isNewLow3MSig
    lastAnchorLow := avwapLow

// Whale Tracker (Highest Volume Bar of the Year)
highestVolumeIndex = ta.highestbars(volume, 252)
anchoredVWAP = calcAvwap(highestVolumeIndex == 0)

// 1. Monthly (Trend + Pivots for Major S/R)
[monthlyClose, monthlyMA1, monthlyMA2, monthlyMA3, mPH, mPL] = request.security(syminfo.tickerid, 'M', [close, ta.ema(close, ma1Length), ta.ema(close, ma2Length), ta.ema(close, ma3Length), ta.pivothigh(high, 3, 3), ta.pivotlow(low, 3, 3)], barmerge.gaps_off, barmerge.lookahead_off)


// 2. Weekly (Trend + Momentum + Pivots)
[weeklyClose, weeklyMA1, weeklyMA2, weeklyMA3, rsiWeekly, wMACD, wSig, wHist, wPH, wPL] = request.security(syminfo.tickerid, 'W', [close, ta.ema(close, ma1Length), ta.ema(close, ma2Length), ta.ema(close, ma3Length), ta.rsi(close, 14), macdLine, signalLine, histLine, ta.pivothigh(high, 5, 5), ta.pivotlow(low, 5, 5)], barmerge.gaps_off, barmerge.lookahead_off)

// 3. Daily (Trend + Ranges + Pivots)
[dailyClose, dailyMA1, dailyMA2, dailyMA3, dH52, dL52, dPH, dPL] = request.security(syminfo.tickerid, 'D', [close, ta.ema(close, ma1Length), ta.ema(close, ma2Length), ta.ema(close, ma3Length), ta.highest(high, 252), ta.lowest(low, 252), ta.pivothigh(high, 5, 5), ta.pivotlow(low, 5, 5)], barmerge.gaps_off, barmerge.lookahead_off)

// MAP HTF VARIABLES (Critical for Trend Validation)
htfClose = htfTrend == 'W' ? weeklyClose : dailyClose
htfMA1 = htfTrend == 'W' ? weeklyMA1 : dailyMA1
htfMA2 = htfTrend == 'W' ? weeklyMA2 : dailyMA2
htfMA3 = htfTrend == 'W' ? weeklyMA3 : dailyMA3

// MTF TREND DEFINITIONS (Used for specific validation logic)
// 1 = Bullish, -1 = Bearish
mtfTrendWeekly = weeklyClose > weeklyMA1 ? 1 : -1
mtfTrendMonthly = monthlyClose > monthlyMA1 ? 1 : -1

// Determine trend on each timeframe (Stacking + Price Position)
// NOW REQUIRES PRICE TO BE ON CORRECT SIDE OF MA2 (50 EMA)
monthlyUptrend = monthlyClose > monthlyMA2 and monthlyMA1 > monthlyMA2 and monthlyMA2 > monthlyMA3
monthlyDowntrend = monthlyClose < monthlyMA2 and monthlyMA1 < monthlyMA2 and monthlyMA2 < monthlyMA3

weeklyUptrend = weeklyClose > weeklyMA2 and weeklyMA1 > weeklyMA2 and weeklyMA2 > weeklyMA3
weeklyDowntrend = weeklyClose < weeklyMA2 and weeklyMA1 < weeklyMA2 and weeklyMA2 < weeklyMA3

dailyUptrend = dailyClose > dailyMA2 and dailyMA1 > dailyMA2 and dailyMA2 > dailyMA3
dailyDowntrend = dailyClose < dailyMA2 and dailyMA1 < dailyMA2 and dailyMA2 < dailyMA3

htfUptrend = htfClose > htfMA2 and htfMA1 > htfMA2 and htfMA2 > htfMA3
htfDowntrend = htfClose < htfMA2 and htfMA1 < htfMA2 and htfMA2 < htfMA3

// GLOBAL TREND STATUS
// Institutional Filter: Must be holding above 3M Institutional Support
// Blended Bias: Momentum Cloud can override anchor if strong
isBullInst = enableAvwap and not na(avwapLow) ? (close > avwapLow or isFastUptrend) : true
isBearInst = enableAvwap and not na(avwapHigh) ? (close < avwapHigh or isFastDowntrend) : true

uptrend = (isFastUptrend or isInstBull or (ma2 > ma3 and close > ma2)) and isBullInst
downtrend = (isFastDowntrend or isInstBear or (ma2 < ma3 and close < ma2)) and isBearInst
sideways = not isFastUptrend and not isFastDowntrend // Transitional state

// DE PRADO'S HIERARCHICAL TREND ALIGNMENT
// Perfect alignment: Monthly > Weekly > Daily > Current all in same direction
allTimeframesAlignedBullish = monthlyUptrend and weeklyUptrend and dailyUptrend and uptrend
allTimeframesAlignedBearish = monthlyDowntrend and weeklyDowntrend and dailyDowntrend and downtrend

// Partial alignment: At least higher timeframes agree (Monthly & Weekly)
majorTimeframesAlignedBullish = monthlyUptrend and weeklyUptrend
majorTimeframesAlignedBearish = monthlyDowntrend and weeklyDowntrend

// HTF validation for current signals
htfConfirmsBullish = htfUptrend or not mtfStrict and not htfDowntrend
htfConfirmsBearish = htfDowntrend or not mtfStrict and not htfUptrend

// SIGNAL QUALITY SCORE (de Prado's Meta-Labeling + Hierarchical Timeframe Weighting)
// Quality: 0-100 based on timeframe alignment
// Higher timeframes weighted MORE (Monthly > Weekly > Daily > Current)
// This ensures we only trade when multiple timeframes AGREE
monthlyAligned = (monthlyUptrend and uptrend) or (monthlyDowntrend and downtrend)
weeklyAligned = (weeklyUptrend and uptrend) or (weeklyDowntrend and downtrend)
dailyAligned = (dailyUptrend and uptrend) or (dailyDowntrend and downtrend)
htfAligned = (htfUptrend and uptrend) or (htfDowntrend and downtrend)
signalQuality = calcMTFQuality(monthlyAligned, weeklyAligned, dailyAligned, htfAligned, enableMTF)

// Timeframe Alignment Status
tfAlignment = allTimeframesAlignedBullish ? 'PERFECT BULL üü¢' : allTimeframesAlignedBearish ? 'PERFECT BEAR üî¥' : majorTimeframesAlignedBullish ? 'MAJOR BULL üü°' : majorTimeframesAlignedBearish ? 'MAJOR BEAR üî¥' : 'MIXED ‚ö™'
tfAlignmentColor = allTimeframesAlignedBullish ? color.new(color.lime, 0) : allTimeframesAlignedBearish ? color.new(color.red, 0) : majorTimeframesAlignedBullish ? color.new(color.yellow, 0) : majorTimeframesAlignedBearish ? COL_ORANGE : color.new(color.gray, 0)

// PART 3: MOMENTUM INDICATORS WITH Z-SCORE NORMALIZATION
// Z-Score Approach: Adaptive thresholds based on each asset's historical behavior
// Benefits: Works across different assets (SPY vs TSLA), adapts to changing market regimes

// Z-SCORE NORMALIZATION FOR RSI
rsiMean = ta.sma(rsi, 252)
rsiStdDev = ta.stdev(rsi, 252)
rsiZScore = (not na(rsiStdDev) and rsiStdDev > 0) ? (rsi - rsiMean) / rsiStdDev : 0

// Adaptive thresholds using z-scores
rsiOB = rsiZScore > 2.0 or rsi > rsiTopThreshold
rsiOS = rsiZScore < -2.0

// 2-PERIOD RSI (Connors RSI)
rsi2 = ta.rsi(close, 2)
rsi2Mean = ta.sma(rsi2, 252)
rsi2StdDev = ta.stdev(rsi2, 252)
rsi2ZScore = (not na(rsi2StdDev) and rsi2StdDev > 0) ? (rsi2 - rsi2Mean) / rsi2StdDev : 0

// Adaptive Connors thresholds
rsi2ExtremeOS = rsi2ZScore < -2.5
rsi2OS = rsi2ZScore < -1.5
rsi2ExtremeOB = rsi2ZScore > 2.5
rsi2OB = rsi2ZScore > 1.5

// Connors RSI Strategy
connorsBuySignal = rsi2ExtremeOS and uptrend
connorsSellSignal = rsi2ExtremeOB and downtrend
macdBullish = ta.crossover(macdLine, signalLine)
macdBearish = ta.crossunder(macdLine, signalLine)

// Stochastic with Z-Score
k = ta.sma(ta.stoch(close, high, low, 14), 3)
d = ta.sma(k, 3)
kMean = ta.sma(k, 252)
kStdDev = ta.stdev(k, 252)
kZScore = (not na(kStdDev) and kStdDev > 0) ? (k - kMean) / kStdDev : 0

stochOB = kZScore > 1.5  // Adaptive overbought
stochOS = kZScore < -1.5  // Adaptive oversold

// ADX with Z-Score (Trend Strength)
[diPlus, diMinus, adx] = ta.dmi(14, 14)
adxMean = ta.sma(adx, 252)
adxStdDev = ta.stdev(adx, 252)
adxZScore = (not na(adxStdDev) and adxStdDev > 0) ? (adx - adxMean) / adxStdDev : 0

strongTrend = adxZScore > 1.0  // 1 std dev above mean = strong trend for THIS asset


// CCI (Commodity Channel Index) with Z-Score
cci = ta.cci(close, 20)
cciMean = ta.sma(cci, 252)
cciStdDev = ta.stdev(cci, 252)
cciZScore = (not na(cciStdDev) and cciStdDev > 0) ? (cci - cciMean) / cciStdDev : 0

cciOB = cciZScore > 2.0  // Adaptive overbought
cciOS = cciZScore < -2.0  // Adaptive oversold

// Williams %R with Z-Score
williamsR = ta.wpr(14)
williamsRMean = ta.sma(williamsR, 252)
williamsRStdDev = ta.stdev(williamsR, 252)
williamsRZScore = (not na(williamsRStdDev) and williamsRStdDev > 0) ? (williamsR - williamsRMean) / williamsRStdDev : 0

williamsOB = williamsRZScore > 1.5  // Adaptive overbought
williamsOS = williamsRZScore < -1.5  // Adaptive oversold

// MFI (Money Flow Index - Volume-weighted RSI) with Z-Score
mfi = ta.mfi(close, 14)
mfiMean = ta.sma(mfi, 252)
mfiStdDev = ta.stdev(mfi, 252)
mfiZScore = (not na(mfiStdDev) and mfiStdDev > 0) ? (mfi - mfiMean) / mfiStdDev : 0

mfiOB = mfiZScore > 2.0  // Adaptive overbought
mfiOS = mfiZScore < -2.0  // Adaptive oversold

// REAL-TIME PRICE ACTION INDICATORS (Non-Lagging)
// All previous indicators (RSI, MACD, EMAs) are LAGGING - they use historical data
// These indicators react to current bar price action in REAL-TIME

// 1. PRICE VELOCITY (Rate of Change) - REAL-TIME
// Measures how fast price is moving RIGHT NOW

rtPriceChange = close - close[1]
priceVelocity = close[1] > 0 ? rtPriceChange / close[1] * 100 : 0 // Smooth velocity (HMA for responsiveness)
velocityMA = ta.hma(priceVelocity, 20)
velocityStdDev = ta.stdev(priceVelocity, 20)
velocityZScore = (not na(velocityStdDev) and velocityStdDev > 0) ? (priceVelocity - velocityMA) / velocityStdDev : 0

// Strong momentum when velocity is >1.5 std devs
strongBullishMomentum = velocityZScore > 1.5  // Price accelerating up
strongBearishMomentum = velocityZScore < -1.5  // Price accelerating down

// 2. MOMENTUM ACCELERATION (Second Derivative) - REAL-TIME
// Measures if momentum is INCREASING or DECREASING
momentumAcceleration = priceVelocity - priceVelocity[1]
accelerationPositive = momentumAcceleration > 0  // Momentum building
accelerationNegative = momentumAcceleration < 0  // Momentum fading

// 3. INTRABAR RANGE ANALYSIS - REAL-TIME
// Analyzes current bar's high-low range vs recent bars
currentBarRange = high - low
avgBarRange = ta.sma(currentBarRange, 20)
rangeExpansion = currentBarRange > avgBarRange * 1.5  // Wide range = strong move
rangeContraction = currentBarRange < avgBarRange * 0.5  // Narrow range = consolidation

// 4. PRICE POSITION IN BAR - REAL-TIME
// Where is close relative to high/low of current bar?
barPosition = currentBarRange > 0 ? (close - low) / currentBarRange : 0.5
bullishBarClose = barPosition > 0.7  // Close near high (bullish)
bearishBarClose = barPosition < 0.3  // Close near low (bearish)

// 5. ORDER FLOW PROXY - REAL-TIME
// Approximates buying/selling pressure using price and volume
buyingPressure = volume * barPosition  // Volume weighted by bar position
sellingPressure = volume * (1 - barPosition)
netPressure = buyingPressure - sellingPressure
// Smooth pressure (HMA for responsiveness)
pressureMA = ta.hma(netPressure, 20)
pressureStDev = ta.stdev(netPressure, 20)
pressureZScore = pressureStDev > 0 ? (netPressure - pressureMA) / pressureStDev : 0

strongBuyingPressure = pressureZScore > 1.0  // Buyers in control
strongSellingPressure = pressureZScore < -1.0  // Sellers in control

// 6. REAL-TIME TREND CONFIRMATION
// Combines multiple RT indicators for high-confidence signals
[rtBullishConfirmation, rtBearishConfirmation, rtBullishSignal, rtBearishSignal] = calcRealTimeConfirmation(strongBullishMomentum, accelerationPositive, bullishBarClose, strongBuyingPressure, strongBearishMomentum, accelerationNegative, bearishBarClose, strongSellingPressure)

// PART 3A: ELDER'S FORCE INDEX
[forceIndex, elderBuySignal, elderSellSignal, elderScreen3Buy, elderScreen3Sell, tripleScreenBuyValid, tripleScreenSellValid, elderStrongBuy, elderStrongSell] = calcElderForceIndex(close, volume, uptrend, downtrend, weeklyUptrend, weeklyDowntrend)


// PART 3A2: ELDER'S IMPULSE SYSTEM
[impulseGreen, impulseRed, impulseBlue] = calcElderImpulse(close, dayofweek, histLine, globalEma13)


// Impulse confirmation for signals (prevents counter-trend disasters!)
// Elder: "Never buy when Impulse is red, never short when Impulse is green"
impulseBuyAllowed = impulseGreen // Only buy on green impulse
impulseSellAllowed = impulseRed // Only short on red impulse

// Strong impulse (multiple bars in same direction = strong trend)
impulseGreenStreak = impulseGreen and impulseGreen[1] and impulseGreen[2] // 3+ green bars
impulseRedStreak = impulseRed and impulseRed[1] and impulseRed[2] // 3+ red bars

// Volatility (for Stage 3 detection - choppy price action)
priceRange = (high - low) / close * 100
avgRange = ta.sma(priceRange, 20)
isChoppy = priceRange > avgRange * 1.3 // 30% more volatile than average

// PART 3A3: WEINSTEIN STAGE ANALYSIS
[weinsteinStage, weinsteinMA, volumeIncreasing, volumeMA50, hasRelStrength, isAccelerating] = calcWeinsteinStage(close, volume, isChoppy, indexClose, indexSMA200)

// Sub-stage handling: A "Pullback" requires price below MA but MA slope still rising
// This distinguishes a healthy dip from distribution.
float weinsteinSlope = (weinsteinMA - weinsteinMA[10]) / math.max(1, weinsteinMA[10]) * 100
stage2Pullback = weinsteinStage == 2 and close < weinsteinMA and weinsteinSlope > 0.5
stage4Rally = weinsteinStage == 4 and close > weinsteinMA
// NEW: Check for Recovery Mode (Stage 5)
isRecovery = weinsteinStage == 5
weinsteinStageLabel = weinsteinStage == 2 ? (stage2Pullback ? 'STAGE 2: PULLBACK ‚ö†Ô∏è' : 'STAGE 2: ADVANCING ‚úÖ') : weinsteinStage == 4 ? (stage4Rally ? 'STAGE 4: RALLY ‚ö†Ô∏è' : 'STAGE 4: DECLINING ‚ùå') : isRecovery ? 'STAGE 4: RECOVERY üå§Ô∏è' : weinsteinStage == 3 ? 'STAGE 3: TOPPING ‚ö†Ô∏è' : weinsteinStage == 1 ? 'STAGE 1: BASING ‚è≥' : 'STAGE: IPO/NEW (NO DATA)'

// Trading decision based on stage
// NEW: Allow buying in Recovery Mode (Stage 5)
weinsteinBuyAllowed = weinsteinStage == 2 or weinsteinStage == 5 // Buy Stage 2 or Recovery
weinsteinSellAllowed = weinsteinStage == 4 // Only short Stage 4
weinsteinAvoidTrading = weinsteinStage == 1 or weinsteinStage == 3 // Avoid Stage 1 & 3

// Plot Weinstein MA (150-day)
plot(weinsteinMA, 'Weinstein MA(150) - Stage Analysis 30-week MA', COL_ORANGE, 2, display = display.all)


// PART 3A5: DARVAS BOX THEORY
darvasBoxTop = ta.pivothigh(high, 3, 3) // High that held for 3 bars each side
darvasBoxBottom = ta.pivotlow(low, 3, 3) // Low that held for 3 bars each side

// Track current box (use var to persist across bars)
var float currentBoxTop = na
var float currentBoxBottom = na
var int boxStartBar = na

// Update box top when new pivot high detected
if not na(darvasBoxTop)
    currentBoxTop := darvasBoxTop
    if na(currentBoxBottom) or na(boxStartBar)
        boxStartBar := bar_index

// Update box bottom when new pivot low detected  
if not na(darvasBoxBottom)
    currentBoxBottom := darvasBoxBottom
    if na(currentBoxTop) or na(boxStartBar)
        boxStartBar := bar_index

// Box is valid when we have both top and bottom
darvasBoxValid = not na(currentBoxTop) and not na(currentBoxBottom) and currentBoxTop > currentBoxBottom

// Box dimensions
darvasBoxHeight = darvasBoxValid ? currentBoxTop - currentBoxBottom : 0
darvasBoxHeightPercent = darvasBoxValid ? darvasBoxHeight / currentBoxBottom * 100 : 0
darvasBoxMidpoint = darvasBoxValid ? (currentBoxTop + currentBoxBottom) / 2 : na

// Price position relative to box
inDarvasBox = darvasBoxValid and close >= currentBoxBottom and close <= currentBoxTop
aboveDarvasBox = darvasBoxValid and close > currentBoxTop
belowDarvasBox = darvasBoxValid and close < currentBoxBottom

// Darvas Breakout (price breaks above box top on volume)
darvasBreakout = darvasBoxValid and close > currentBoxTop and close[1] <= currentBoxTop and volume > volumeMA50 * 1.3
darvasFakeout = darvasBoxValid and high > currentBoxTop and close < currentBoxTop // Fake Breakout / Trap
darvasBreakoutStrong = darvasBreakout and weinsteinStage == 2 // Breakout in Stage 2 = best

// Darvas Breakdown (price breaks below box bottom - exit signal!)
darvasBreakdown = darvasBoxValid and close < currentBoxBottom and close[1] >= currentBoxBottom

// Box quality (tighter boxes = better)
darvasBoxQuality = not darvasBoxValid ? 0 : darvasBoxHeightPercent < 5 ? 100 : darvasBoxHeightPercent < 10 ? 80 : darvasBoxHeightPercent < 15 ? 60 : darvasBoxHeightPercent < 20 ? 40 : 20

// Darvas entry and stop levels
darvasEntry = darvasBoxValid ? currentBoxTop : na // Enter above box top
darvasStop = darvasBoxValid ? currentBoxBottom : na // Stop at box bottom
darvasTarget = darvasBoxValid ? currentBoxTop + darvasBoxHeight : na // Target = box height above breakout (1:1 R:R)

// Darvas status
darvasStatus = darvasBreakoutStrong ? 'BREAKOUT üöÄ' : darvasBreakout ? 'BREAKING OUT ‚¨ÜÔ∏è' : inDarvasBox ? 'IN BOX üì¶' : aboveDarvasBox ? 'ABOVE BOX ‚úÖ' : belowDarvasBox ? 'BELOW BOX ‚ùå' : 'NO BOX'

// MOMENTUM INDICATORS

// Bollinger Bands
[bbMiddle, bbUpper, bbLower] = ta.bb(close, 20, 2)

// RE-DEFINITION OF OVEREXTENSION (For Opacity Engine)
// We need raw versions that aren't suppressed by "Rocket" logic
// Placed after BB definitions to avoid undeclared identifier error
isOverboughtRaw = rsi > 70 or (not na(bbUpper) and close > bbUpper * 1.02)
isOversoldRaw = rsi < 30 or (not na(bbLower) and close < bbLower * 0.98)

plot(bbUpper, 'BB Upper - Bollinger Band (Resistance)', color.new(color.blue, 50), 1, display = display.all)
plot(bbMiddle, 'BB Middle - Bollinger Band (20 SMA)', color.new(color.gray, 50), 1, display = display.all)
plot(bbLower, 'BB Lower - Bollinger Band (Support)', color.new(color.blue, 50), 1, display = display.all)

// ATR for Stop Loss
atr = ta.atr(atrLength)

// PART 4A-2: RELATIVE STRENGTH vs MARKET (William O'Neil - CAN SLIM)

// Get benchmark data (252 trading days = 1 year) - Combined into single call
[benchmarkClose, benchmarkClose252] = request.security(benchmarkSymbol, timeframe.period, [close, close[252]], barmerge.gaps_off, barmerge.lookahead_off)

// Calculate 1-year performance
close252 = close[252]
stockPerformance = close252 > 0 ? (close - close252) / close252 * 100 : 0
benchmarkPerformance = benchmarkClose252 > 0 ? (benchmarkClose - benchmarkClose252) / benchmarkClose252 * 100 : 0

// Relative Strength Score (0-100 scale)
relativeStrength = benchmarkPerformance != 0 ? (stockPerformance / benchmarkPerformance) * 100 : 100

// O'Neil's RS Rating (percentile rank)
rsRating = relativeStrength > 150 ? 95 : relativeStrength > 120 ? 85 : relativeStrength > 100 ? 70 : relativeStrength > 80 ? 50 : relativeStrength > 60 ? 30 : 10

// Relative Strength validation
rsValid = not enableRelativeStrength or rsRating >= rsMinimum

// 52-week high breakout (O'Neil CAN SLIM 'N')
weekHigh52 = dH52
weekLow52 = dL52
avgVolume20 = volAvg20
isBreakingOut = close > weekHigh52[1] and volume > avgVolume20 * 1.5 // New high on strong volume
newHighValid = not requireNewHighs or isBreakingOut

// PART 4B: TIMEFRAME DETECTION (needed for pattern confidence)

// SHARPE & SORTINO RATIOS - TradingView Official RiskMetrics Library
// Reference: https://www.tradingview.com/script/oOgZRqiM-RiskMetrics/
// Uses monthly returns as per TradingView standard (Strategy Tester methodology)

// IMPORTANT: The RiskMetrics library expects BAR-BY-BAR percent changes
// It internally compounds these into monthly periods automatically
// Do NOT pre-aggregate to monthly - let the library do it!

// Calculate bar-to-bar return percentage (works on any timeframe)
barReturnPct = nz(ta.roc(close, 1), open > 0 ? 100.0 * (close - open) / open : 0)

// The library will automatically:
// 1. Compound bar-by-bar returns within each calendar month
// 2. Store up to 60 monthly returns (5 years)
// 3. Calculate Sharpe/Sortino from those 60 monthly periods
periodicReturns = rm.getPeriodicReturns(barReturnPct, maxPeriods = 60)

// Calculate Sharpe Ratio using TradingView's official methodology
// annualBenchmark expects percentage (e.g., 4.5 for 4.5%), not decimal
// riskFreeRate is stored as decimal (0.045), so multiply by 100
// NOTE: The library returns MONTHLY Sharpe, so we multiply by ‚àö12 to annualize it
sharpeRatioMonthly = periodicReturns.sharpeRatio(riskFreeRate * 100)
sharpeRatio = sharpeRatioMonthly * math.sqrt(12) // Annualize: Monthly Sharpe √ó ‚àö12
hasSharpeData = not na(sharpeRatio)

// Calculate Sortino Ratio (only penalizes downside volatility)
// Also annualize it for consistency
sortinoRatioMonthly = periodicReturns.sortinoRatio(riskFreeRate * 100)
sortinoRatio = sortinoRatioMonthly * math.sqrt(12) // Annualize: Monthly Sortino √ó ‚àö12
hasSortinoData = not na(sortinoRatio)

// Extract additional metrics from RiskMetrics library
// These are calculated from the 60-month (5-year) dataset, ensuring consistency
avgReturn = periodicReturns.avg() * 12 // Average monthly return * 12 = annualized
returnStdDev = periodicReturns.stdev() * math.sqrt(12) // Annualized volatility

// Calculate Maximum Drawdown manually from monthly data
// Use request.security to get 2 years (24 months) of monthly closes
// RECENCY LOGIC: 5 years (60) is too long; penalizes recovery plays (TLT/PANW).
maxDrawdownPeriod = 24 
[monthlyHigh, monthlyCloseDD] = request.security(syminfo.tickerid, "M", [ta.highest(high, maxDrawdownPeriod), close], lookahead=barmerge.lookahead_off)
monthlyDrawdown = monthlyHigh > 0 ? (monthlyCloseDD - monthlyHigh) / monthlyHigh * 100 : 0
maxDrawdown = ta.lowest(monthlyDrawdown, maxDrawdownPeriod)

// For backward compatibility - keep daily return calculations for other technical indicators
dailyPriceChange = ta.change(close)
dailyReturn = close[1] > 0 ? dailyPriceChange / close[1] : 0 // Decimal form for RSI, momentum calculations, etc.

// VOLATILITY METRICS
volSmaForDenom = ta.sma(close, 20)
volStdev = ta.stdev(close, 20)
volatility = volSmaForDenom > 0 ? volStdev / volSmaForDenom * 100 : 0 // Coefficient of variation
historicVolatility = returnStdDev * 100 // Annualized %

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PHASE 5 & 6: VOLATILITY FORENSIC ENGINE (Functional Integration)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
[hv20, hv252, finalIV30, ivRank, ivHvSpread] = calcVolatilityForensics(close, low)

// Compare current volatility to historical (percentile rank)
volatilityPercentile = ta.percentrank(volatility, 252)

// SMART RISK SCORE (0-100, where 100 = extremely dangerous)
// Key insight: Volatility is GOOD if stock quality is GOOD (opportunity!)
//              Volatility is BAD if stock quality is POOR (danger!)

sharpeScore = hasSharpeData and not na(sharpeRatio) ? (sharpeRatio > 2 ? 0 : sharpeRatio > 1 ? 10 : sharpeRatio > 0.5 ? 25 : sharpeRatio > 0 ? 40 : 50) : 20
sortinoScore = hasSortinoData and not na(sortinoRatio) ? (sortinoRatio > 2 ? 0 : sortinoRatio > 1 ? 10 : sortinoRatio > 0.5 ? 25 : 40) : 20
drawdownScore = (not na(maxDrawdown)) ? (maxDrawdown > -10 ? 0 : maxDrawdown > -20 ? 15 : maxDrawdown > -30 ? 30 : maxDrawdown > -40 ? 45 : 60) : 20

// SMART VOLATILITY SCORE
// High volatility + Good fundamentals = OPPORTUNITY (low penalty)
// High volatility + Poor fundamentals = DANGER (high penalty)
// ETFs/Indices = Always lower volatility concern (inherently diversified)

baseVolatilityScore = volatilityPercentile < 30 ? 0 : volatilityPercentile < 50 ? 10 : volatilityPercentile < 70 ? 20 : volatilityPercentile < 85 ? 35 : 50

// Adjust volatility penalty based on stock quality
// Adjust volatility penalty based on stock quality
// Removed fundamental checks
volatilityMultiplier = 1.0

volatilityScore = math.round(baseVolatilityScore * volatilityMultiplier)

riskScore = math.round((sharpeScore + sortinoScore + drawdownScore + volatilityScore) / 4)

// TRADING WORTHINESS DECISION (Adaptive based on protection mode)
// UPDATED: Now uses user-defined input thresholds for full control
// Users can adjust Sharpe, Drawdown, and Risk Score limits to match their risk tolerance

// Risk thresholds (Simplified)
minSharpe = isETF ? minSharpeETF : minSharpeStocks
maxDD = isETF ? maxDrawdownETF : maxDrawdownStocks

// Max Risk Score Allowed
// Base risk score allowed
maxRiskScoreAllowed = baseMaxRiskScore

sharpeDisplayValue = hasSharpeData ? str.tostring(sharpeRatio, '#.##') : 'N/A'
sharpeDisplayColor = hasSharpeData ? (sharpeRatio >= minSharpe ? color.lime : color.red) : color.new(color.gray, 50)

// SMARTRISK THRESHOLD - Initialized later after MTF data is ready

// High quality stocks can have HIGHER risk scores (volatility = opportunity!)
// Poor quality stocks must have LOW risk scores (volatility = danger!)
// (Simplified: Removed fundamental quality adjustment)

// POSITION DECISIONS MOVED DOWN TO LINE 3800 TO CAPTURE TOXIC RISK IN REAL-TIME

// Parabolic SAR
psar = ta.sar(0.02, 0.02, 0.2)
plot(psar, 'PSAR - Parabolic SAR (Trend reversal)', style = plot.style_cross, color = close > psar ? color.green : color.red, linewidth = 2, display = display.all)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PHASE 4B: FIBONACCI RETRACEMENT ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

swingHigh = ta.highest(high, fibLength)
swingLow = ta.lowest(low, fibLength)
fibRange = swingHigh - swingLow
fib236 = swingLow + fibRange * 0.236
fib382 = swingLow + fibRange * 0.382
fib50 = swingLow + fibRange * 0.5
fib618 = swingLow + fibRange * 0.618
fib786 = swingLow + fibRange * 0.786



// Support & Resistance Zones (CLEAN - Only Key Levels)


// CURRENT TIMEFRAME PIVOTS (stored for analysis, not all displayed)
pivotHigh = ta.pivothigh(high, 10, 10)
pivotLow = ta.pivotlow(low, 10, 10)

// HIGHER TIMEFRAME PIVOTS (Weekly and Daily for stronger levels)
// Pivot Data (Using Consolidated Data)
weeklyHigh = wPH
weeklyLow = wPL
dailyHigh = dPH
dailyLow = dPL

// Store recent pivots to find KEY levels
var array<float> recentResistances = array.new_float(0)
var array<float> recentSupports = array.new_float(0)

// Helper function to check if level already exists (within 0.5% tolerance)
levelExists(array<float> arr, float level) =>
    bool found = false
    if not na(level) and array.size(arr) > 0
        for i = 0 to array.size(arr) - 1
            if math.abs(array.get(arr, i) - level) / level < 0.005
                found := true
                break
    found

// Collect resistance levels (prioritize HTF)
// Supply-Side Novelty Filter: Evaluates incoming resistance pivots for uniqueness to prevent cluster drift.
if not na(pivotHigh) and na(pivotHigh[1])  // NEW pivot detected
    if not levelExists(recentResistances, pivotHigh)
        array.push(recentResistances, pivotHigh)

// Monthly pivots (Major structural levels)    
if not na(mPH) and mPH != mPH[1]
    if not levelExists(recentResistances, mPH)
        array.push(recentResistances, mPH)
        
if not na(weeklyHigh) and weeklyHigh != weeklyHigh[1]
    if not levelExists(recentResistances, weeklyHigh)
        array.push(recentResistances, weeklyHigh)
    
if not na(dailyHigh) and timeframe.isintraday and dailyHigh != dailyHigh[1]
    if not levelExists(recentResistances, dailyHigh)
        array.push(recentResistances, dailyHigh)

// Intermediate Resistance Mapping
// Identifies recent price peaks as tactical resistance levels.
float recentSwingHigh = ta.highest(high, 20)
if recentSwingHigh > close * 1.05 and recentSwingHigh != recentSwingHigh[1]  // At least 5% above current price
    if not levelExists(recentResistances, recentSwingHigh)
        array.push(recentResistances, recentSwingHigh)

// ENHANCEMENT: Push Fibonacci levels into structural resistance array
if fib618 > close + (atr * 0.5) and not levelExists(recentResistances, fib618)
    array.push(recentResistances, fib618)
if fib50 > close + (atr * 0.5) and not levelExists(recentResistances, fib50)
    array.push(recentResistances, fib50)
if fib382 > close + (atr * 0.5) and not levelExists(recentResistances, fib382)
    array.push(recentResistances, fib382)


// Memory Management: Buffer Pruning
// Ensures tactical level arrays maintain a maximum depth of 20 levels.
while array.size(recentResistances) > 20
    array.shift(recentResistances)



// Collect support levels (prioritize HTF)
// Demand-Side Novelty Filter: Validates incoming support pivots for structural confluence and novelty.
if not na(pivotLow) and na(pivotLow[1])  // NEW pivot detected
    if not levelExists(recentSupports, pivotLow)
        array.push(recentSupports, pivotLow)

// Monthly pivots (Major structural levels)
if not na(mPL) and mPL != mPL[1]
    if not levelExists(recentSupports, mPL)
        array.push(recentSupports, mPL)

// Optimization: Only push HTF levels if they changed
if not na(weeklyLow) and weeklyLow != weeklyLow[1]
    if not levelExists(recentSupports, weeklyLow)
        array.push(recentSupports, weeklyLow)
    
if not na(dailyLow) and timeframe.isintraday and dailyLow != dailyLow[1]
    if not levelExists(recentSupports, dailyLow)
        array.push(recentSupports, dailyLow)


// Intermediate Support Mapping
// Identifies recent price troughs as tactical support levels.
float recentSwingLow = ta.lowest(low, 20)
if recentSwingLow < close * 0.95 and recentSwingLow != recentSwingLow[1]  // At least 5% below current price
    if not levelExists(recentSupports, recentSwingLow)
        array.push(recentSupports, recentSwingLow)

// ENHANCEMENT: Push Fibonacci levels into structural support array
if fib618 < close - (atr * 0.5) and not levelExists(recentSupports, fib618)
    array.push(recentSupports, fib618)
if fib50 < close - (atr * 0.5) and not levelExists(recentSupports, fib50)
    array.push(recentSupports, fib50)
if fib382 < close - (atr * 0.5) and not levelExists(recentSupports, fib382)
    array.push(recentSupports, fib382)

// Universal Pruning (Support): Instant Drain - Increased to 20
while array.size(recentSupports) > 20
    array.shift(recentSupports)



// Find KEY levels: Closest resistance above and support below current price
float keyResistance = na
float keySupport = na

if array.size(recentResistances) > 0
    keyResistance := findClosestKeyLevel(recentResistances, close, false, atr)

if array.size(recentSupports) > 0
    keySupport := findClosestKeyLevel(recentSupports, close, true, atr)

// FALLBACK: If no resistance found, use 52W High
bool isAtATH = close >= dH52 * 0.98  // Within 2% of 52W High = ATH
if na(keyResistance)
    // Fallback to Fibonacci Extension (0.236) of yearly range, with safety cap
    float athProj = dH52 + (dH52 - dL52) * 0.236
    float athCap = isETF ? 1.02 : 1.05 // Professional cap: 2% for ETFs, 5% for stocks
    keyResistance := isAtATH ? math.min(athProj, dH52 * athCap) : dH52

// FALLBACK: If no support found, use 52W Low
bool isAtATL = close <= dL52 * 1.02  // Within 2% of 52W Low = ATL  
if na(keySupport)
    // Fallback to 52W Low (or -10% below ATL for floor)
    keySupport := isAtATL ? dL52 * 0.90 : dL52


// Draw ONLY the key levels (1 resistance, 1 support) - CLEAN CHART
var label keyResistanceLabel = na
var label keySupportLabel = na

// Opacity Logic for S/R
resColor = downtrend ? color.new(color.red, 20) : color.new(color.red, 70) // Faded if uptrend
supColor = uptrend ? color.new(color.lime, 20) : color.new(color.lime, 70) // Faded if downtrend

// Draw Key Levels - STEPPED LINES (Historical Accuracy)
// We draw a line segment for EACH bar to ensure history is accurate ("Sticks to Candlesticks")
// Labels are restricted to the CURRENT (last) bar to avoid "270 label at 170 price" confusion.

// Resistance Line
if showSR and not na(keyResistance) and keyResistance > 0 and math.abs(keyResistance - close) < scaleGuardThreshold
    // Draw segment from previous bar to current bar
    line.new(bar_index - 1, keyResistance, bar_index, keyResistance, color = resColor, width = 2, style = line.style_solid)

// Resistance Label (Current Only)
if showSR and not na(keyResistance) and barstate.islast and math.abs(keyResistance - close) < scaleGuardThreshold
    string resTxt = 'üî¥ KEY RES: ' + str.tostring(keyResistance, '#.##')
    string resTooltip = 'Nearest Structural Resistance above ' + str.tostring(close, '#.##')
    if na(keyResistanceLabel)
        keyResistanceLabel := label.new(bar_index, keyResistance, resTxt, color = resColor, textcolor = color.black, style = label.style_label_left, size = size.normal, tooltip = resTooltip)
    else
        label.set_xy(keyResistanceLabel, bar_index, keyResistance)
        label.set_text(keyResistanceLabel, resTxt)
        label.set_color(keyResistanceLabel, resColor)
        label.set_tooltip(keyResistanceLabel, resTooltip)
else
    label.delete(keyResistanceLabel), keyResistanceLabel := na

// Support Line
if showSR and not na(keySupport) and keySupport > 0 and math.abs(keySupport - close) < scaleGuardThreshold
    // Draw segment from previous bar to current bar
    line.new(bar_index - 1, keySupport, bar_index, keySupport, color = supColor, width = 2, style = line.style_solid)

// Support Label (Current Only)
if showSR and not na(keySupport) and barstate.islast and math.abs(keySupport - close) < scaleGuardThreshold
    // STACKING FIX: If resistance is very close to support, push the support label down
    float labelDisp = keySupport
    float srGap = not na(keyResistance) ? (keyResistance - keySupport) / keySupport : 1.0
    lStyle = label.style_label_up
    if srGap < 0.005 // Labels are within 0.5% (roughly overlapping)
        labelDisp := keySupport * 0.998 // Slight nudge down
    
    string supTxt = 'üü¢ KEY SUP: ' + str.tostring(keySupport, '#.##')
    string supTooltip = 'Nearest Structural Support below ' + str.tostring(close, '#.##')
    
    if na(keySupportLabel)
        keySupportLabel := label.new(bar_index, labelDisp, supTxt, color = supColor, textcolor = color.black, style = lStyle, size = size.normal, tooltip = supTooltip)
    else
        label.set_xy(keySupportLabel, bar_index, labelDisp)
        label.set_text(keySupportLabel, supTxt)
        label.set_color(keySupportLabel, supColor)
        label.set_style(keySupportLabel, lStyle)
        label.set_tooltip(keySupportLabel, supTooltip)
else
    label.delete(keySupportLabel), keySupportLabel := na

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// BOUNCE DETECTION (Visual Clarity) - WITH CONFIDENCE-BASED COLORING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// If price touches support/resistance and shows reaction, mark it.
bool supBounce = not na(keySupport) and low <= keySupport * 1.002 and close > keySupport and close > open
bool resReject = not na(keyResistance) and high >= keyResistance * 0.998 and close < keyResistance and close < open

// Confidence Breakdown: trend(30) + RSI(25) + volume(20) + candle(25)
float bTrend = uptrend ? 30 : 0
float bRsi = rsi < 40 ? 25 : rsi < 50 ? 15 : 0
float bVol = volume > avgVolume20 ? 20 : 0
float bCandle = close > open ? 25 : 0
float bConf = supBounce ? bTrend + bRsi + bVol + bCandle : 0

float rTrend = downtrend ? 30 : 0
float rRsi = rsi > 60 ? 25 : rsi > 50 ? 15 : 0
float rVol = volume > avgVolume20 ? 20 : 0
float rCandle = close < open ? 25 : 0
float rConf = resReject ? rTrend + rRsi + rVol + rCandle : 0

// Colors: Gray‚ÜíYellow‚ÜíGreen/Red
color bCol = bConf >= 70 ? color.green : bConf >= 40 ? color.yellow : color.new(color.gray, 50)
color rCol = rConf >= 70 ? color.red : rConf >= 40 ? COL_ORANGE : color.new(color.gray, 50)

// Tooltips: WHY did it bounce/reject?
string bTooltip = 'SUPPORT BOUNCE (' + str.tostring(bConf, '#') + '%)\n\n' +
                  '‚úì Trend: ' + str.tostring(bTrend, '#') + '/30 ' + (bTrend >= 30 ? '(Uptrend)' : '(No trend boost)') + '\n' +
                  '‚úì RSI: ' + str.tostring(bRsi, '#') + '/25 ' + (bRsi >= 25 ? '(Oversold)' : bRsi >= 15 ? '(Low)' : '(Neutral)') + '\n' +
                  '‚úì Volume: ' + str.tostring(bVol, '#') + '/20 ' + (bVol >= 20 ? '(High Vol)' : '(Low Vol)') + '\n' +
                  '‚úì Candle: ' + str.tostring(bCandle, '#') + '/25 ' + (bCandle >= 25 ? '(Bullish)' : '(Bearish)')

string rTooltip = 'RESISTANCE REJECTION (' + str.tostring(rConf, '#') + '%)\n\n' +
                  '‚úì Trend: ' + str.tostring(rTrend, '#') + '/30 ' + (rTrend >= 30 ? '(Downtrend)' : '(No trend boost)') + '\n' +
                  '‚úì RSI: ' + str.tostring(rRsi, '#') + '/25 ' + (rRsi >= 25 ? '(Overbought)' : rRsi >= 15 ? '(High)' : '(Neutral)') + '\n' +
                  '‚úì Volume: ' + str.tostring(rVol, '#') + '/20 ' + (rVol >= 20 ? '(High Vol)' : '(Low Vol)') + '\n' +
                  '‚úì Candle: ' + str.tostring(rCandle, '#') + '/25 ' + (rCandle >= 25 ? '(Bearish)' : '(Bullish)')

// FORMING vs CONFIRMED: Gray for unconfirmed bars, solid for confirmed
bool isFormingBounceReject = not barstate.isconfirmed

if supBounce
    // Gray if forming, original color if confirmed
    bounceColor = isFormingBounceReject ? color.gray : bCol
    bounceTextColor = isFormingBounceReject ? color.black : (bConf >= 70 ? color.white : color.black)
    bouncePrefix = isFormingBounceReject ? '‚è≥ ' : ''
    label.new(bar_index, low, bouncePrefix + 'BOUNCE ' + str.tostring(bConf, '#') + '%', color = bounceColor, style = label.style_label_up, textcolor = bounceTextColor, size = size.tiny, tooltip = bTooltip + (isFormingBounceReject ? '\n\n‚è≥ FORMING - Wait for bar close.' : ''))
if resReject
    // Gray if forming, original color if confirmed
    rejectColor = isFormingBounceReject ? color.gray : rCol
    rejectTextColor = isFormingBounceReject ? color.black : (rConf >= 70 ? color.white : color.black)
    rejectPrefix = isFormingBounceReject ? '‚è≥ ' : ''
    label.new(bar_index, high, rejectPrefix + 'REJECT ' + str.tostring(rConf, '#') + '%', color = rejectColor, style = label.style_label_down, textcolor = rejectTextColor, size = size.tiny, tooltip = rTooltip + (isFormingBounceReject ? '\n\n‚è≥ FORMING - Wait for bar close.' : ''))


// Golden Cross & Death Cross
goldenCross = ta.crossover(ma2, ma3)
deathCross = ta.crossunder(ma2, ma3)
plotshape(goldenCross, 'Golden Cross', shape.xcross, location.belowbar, color.new(color.yellow, 0), text = 'GOLDEN\nCROSS', size = size.normal)
plotshape(deathCross, 'Death Cross', shape.xcross, location.abovebar, color.new(color.black, 0), text = 'DEATH\nCROSS', size = size.normal)

// PART 4B: TIMEFRAME DETECTION (needed for pattern confidence)

// Detect current timeframe
currentTF = timeframe.period
isIntraday = timeframe.isintraday
isDaily = timeframe.isdaily
isWeekly = timeframe.isweekly
isMonthly = timeframe.ismonthly

// PART 5: CANDLESTICK PATTERN DETECTION WITH CONFIDENCE SCORING

// Candle body and wick calculations
bodySize = math.abs(close - open)
upperWick = high - math.max(close, open)
lowerWick = math.min(close, open) - low
totalRange = high - low
avgBody = ta.sma(bodySize, 14)

// Pattern Detection (Boolean)
// Volatility-Adjusted Candlestick Logic: Captures pinbars/tails regardless of body color
isDoji = bodySize < avgBody * 0.1 and totalRange > avgBody

// Hammer/Pinbar: Huge lower wick (>2x body), small upper wick. Color doesn't specificially matter if wick is huge.
isHammer = lowerWick > bodySize * 2 and upperWick < bodySize * 0.5 
isShootingStar = upperWick > bodySize * 2 and lowerWick < bodySize * 0.5

// Harami/Engulfing (classic definitions)
bullishEngulfing = close > open and close[1] < open[1] and close > open[1] and open < close[1]
bearishEngulfing = close < open and close[1] > open[1] and close < open[1] and open > close[1]

// PATTERN CONFIDENCE SCORING (used by pattern system below)
// Base confidence factors (0-100 scale)
// Extract ta.* functions to variables for consistency (v6 requirement)
volumeSma20 = volAvg20
volumeFactor = volume > volumeSma20 * 2 ? 30 : volume > volumeSma20 * 1.5 ? 20 : volume > volumeSma20 ? 10 : 0
trendStrengthFactor = adx > 40 ? 25 : adx > 30 ? 20 : adx >= adxTrendThresh + 5 ? 15 : adx >= adxTrendThresh ? 10 : 5
lowest50 = ta.lowest(low, 50)
highest50 = ta.highest(high, 50)
nearKeyLevel = math.abs(close - lowest50) / close < 0.02 or math.abs(close - highest50) / close < 0.02
proximityFactor = nearKeyLevel ? 20 : 10
momentumAligned = rsi > 50 and macdLine > signalLine and close > ma1 or rsi < 50 and macdLine < signalLine and close < ma1
momentumFactor = momentumAligned ? 15 : 5
timeframeFactor = isMonthly ? 10 : isWeekly ? 8 : isDaily ? 5 : 3
baseConfidence = volumeFactor + trendStrengthFactor + proximityFactor + momentumFactor + timeframeFactor

// CONFIDENCE-BASED PATTERN SYSTEM
// Track best bullish and bearish candlestick patterns
var string bestBullPattern = ''
var int bestBullConfidence = 0
var string bestBearPattern = ''
var int bestBearConfidence = 0

if showCandlePatterns
    bestBullPattern := ''
    bestBullConfidence := 0
    bestBearPattern := ''
    bestBearConfidence := 0

    // BULLISH PATTERNS - Priority: Engulfing > Hammer > Doji
    if bullishEngulfing
        conf = baseConfidence + 15 + (uptrend ? 10 : -5)
        if conf > bestBullConfidence
            bestBullPattern := 'BULL ENG'
            bestBullConfidence := conf

    if isHammer
        conf = baseConfidence + 10 + (downtrend ? 10 : 0)
        if conf > bestBullConfidence
            bestBullPattern := 'HAMMER'
            bestBullConfidence := conf

    if isDoji and not(bullishEngulfing or isHammer)
        conf = baseConfidence
        if conf > bestBullConfidence and close > open
            bestBullPattern := 'DOJI'
            bestBullConfidence := conf

    // BEARISH PATTERNS - Priority: Engulfing > Shooting Star > Doji
    if bearishEngulfing
        conf = baseConfidence + 15 + (downtrend ? 10 : -5)
        if conf > bestBearConfidence
            bestBearPattern := 'BEAR ENG'
            bestBearConfidence := conf

    if isShootingStar
        conf = baseConfidence + 10 + (uptrend ? 10 : 0)
        if conf > bestBearConfidence
            bestBearPattern := 'SHOOT'
            bestBearConfidence := conf

    if isDoji and not(bearishEngulfing or isShootingStar)
        conf = baseConfidence
        if conf > bestBearConfidence and close < open
            bestBearPattern := 'DOJI'
            bestBearConfidence := conf

// Display only highest confidence patterns
showBullPattern = bestBullPattern != '' and (not useSmartFiltering or bestBullConfidence >= minConfidenceScore)
showBearPattern = bestBearPattern != '' and (not useSmartFiltering or bestBearConfidence >= minConfidenceScore)

// --- 16. CHART PATTERN RECOGNITION ---

// BULL FLAG (continuation pattern)
highest5 = ta.highest(high, 5)
lowest5 = ta.lowest(low, 5)
highest10 = ta.highest(high, 10)
lowest10 = ta.lowest(low, 10)
flagPole = high[5] > high[10] * 1.03
flagConsolidation = highest5 - lowest5 < atr * 1.5
bullFlag = flagPole and flagConsolidation and uptrend
if showChartPatterns and bullFlag and close > highest5[1]
    bfColor = uptrend ? color.new(color.lime, 20) : color.new(color.lime, 70)
    bfConf = uptrend ? 'High (Trend Aligned)' : 'Moderate (Counter-Trend)'
    label.new(bar_index, high, 'FLAGüö©', color = bfColor, style = label.style_label_down, textcolor = color.black, size = size.small, tooltip = 'Bull Flag\nConfidence: ' + bfConf)

// BEAR FLAG (continuation pattern)
bearFlagPole = low[5] < low[10] * 0.97
bearFlag = bearFlagPole and flagConsolidation and downtrend
if showChartPatterns and bearFlag and close < lowest5[1]
    bearFColor = downtrend ? color.new(color.red, 20) : color.new(color.red, 70)
    bearFConf = downtrend ? 'High (Trend Aligned)' : 'Moderate (Counter-Trend)'
    label.new(bar_index, low, 'FLAGüö©', color = bearFColor, style = label.style_label_up, textcolor = color.white, size = size.small, tooltip = 'Bear Flag\nConfidence: ' + bearFConf)


// PART 6A: VOLUME ANALYSIS (Murphy Chapter 7)


volMA = volAvg20
highVolume = volume > volMA * 1.5
climaxVolume = volume > volMA * 2.5

// On Balance Volume (OBV) - Key volume indicator
// Extract ta.* functions for consistency (v6 requirement)
obv = ta.cum(math.sign(ta.change(close)) * volume)
obvMA = ta.hma(obv, 20)
obvRising = ta.rising(obv, 3)
obvFalling = ta.falling(obv, 3)
obvBullish = obv > obvMA and obvRising
obvBearish = obv < obvMA and obvFalling

// CHAIKIN ACCUMULATION/DISTRIBUTION LINE (Murphy Chapter 7)
// More sophisticated than OBV - considers where price closes within the day's range
// Close near high = accumulation, close near low = distribution
moneyFlowMultiplier = high - low > 0 ? (close - low - (high - close)) / (high - low) : 0
moneyFlowVolume = moneyFlowMultiplier * volume
adLine = ta.cum(moneyFlowVolume)
adLineMA = ta.hma(adLine, 20)
adLineRising = ta.rising(adLine, 3)
adLineFalling = ta.falling(adLine, 3)
adLineBullish = adLine > adLineMA and adLineRising // Institutional accumulation
adLineBearish = adLine < adLineMA and adLineFalling // Institutional distribution

// Volume Confirmation
volumeConfirmsBull = close > close[1] and volume > volMA
volumeConfirmsBear = close < close[1] and volume > volMA

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PREDICTIVE SETUP DETECTION (Leading Indicators)
// These detect setups BEFORE price confirms - making signals more anticipatory
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Volatility Squeeze (Bollinger inside Keltner = energy building)
[sqzOn, sqzReleaseDir, sqzMomentum] = detectVolatilitySqueeze(close, 20, 2.0, 20, 1.5)

// Smart Money Accumulation/Distribution (OBV diverging from price)
[isSmartAccum, isSmartDistrib, smartDivStrength] = detectSmartMoney(close, volume, 20)

// Range Contraction (Low ATR = breakout imminent)
[isRangeContracted, atrPercentile] = detectRangeContraction(14, 50)

// Combined Predictive Setup Score (0-100)
predictiveSetupScore = calcPredictiveSetupScore(sqzOn, sqzMomentum, isSmartAccum, isSmartDistrib, smartDivStrength, isRangeContracted)

// Predictive Setup Status for tooltips (SPLIT BY ZONE TYPE)
string predictiveStatusBull = ""  // For Buy Zones only
string predictiveStatusBear = ""  // For Sell Zones only
// and can be misleading in directional zone tooltips (e.g., "Breakout Soon" after breakout)

if isSmartAccum
    predictiveStatusBull := predictiveStatusBull + "üêã SMART MONEY ACCUMULATING\n"
if isSmartDistrib
    predictiveStatusBear := predictiveStatusBear + "üêã SMART MONEY DISTRIBUTING\n"

// Neutral signals tracked internally for scoring but NOT shown in zone tooltips
// to avoid "Breakout Soon" appearing after a breakout already happened
string predictiveStatusNeutral = ""
if sqzOn
    predictiveStatusNeutral := "üîã SQUEEZE ACTIVE\n"
if isRangeContracted
    predictiveStatusNeutral := predictiveStatusNeutral + "‚ö° RANGE CONTRACTED\n"
if predictiveSetupScore >= 50
    predictiveStatusNeutral := predictiveStatusNeutral + "üéØ SETUP SCORE: " + str.tostring(predictiveSetupScore, '#') + "/100\n"

// Combined for backwards compatibility (NOT used in zone tooltips anymore)
string predictiveStatus = predictiveStatusNeutral

// Pattern confidence already calculated above in Part 5


// PART 6B: DIVERGENCE DETECTION (Murphy Chapter 11)
divLength = 5
rsiHighPivot = ta.pivothigh(rsi, divLength, divLength)
rsiLowPivot = ta.pivotlow(rsi, divLength, divLength)
priceHighPivot = ta.pivothigh(high, divLength, divLength)
priceLowPivot = ta.pivotlow(low, divLength, divLength)

// Pivots (Daily)
macdHighP = ta.pivothigh(macdLine, 5, 5)
macdLowP = ta.pivotlow(macdLine, 5, 5)

// Persistence Logic (Using Consolidated Top Data)
// Extraction for Daily RSI
prevPriceLow_RSI = ta.valuewhen(not na(priceLowPivot), low, 1)
prevRSI_Low      = ta.valuewhen(not na(rsiLowPivot), rsi, 1)
prevPriceHigh_RSI = ta.valuewhen(not na(priceHighPivot), high, 1)
prevRSI_High     = ta.valuewhen(not na(rsiHighPivot), rsi, 1)

bool dBullRSI = not na(priceLowPivot) and not na(rsiLowPivot) and low < prevPriceLow_RSI and rsi > prevRSI_Low
bool dBearRSI = not na(priceHighPivot) and not na(rsiHighPivot) and high > prevPriceHigh_RSI and rsi < prevRSI_High

// Weekly Persistence
wRLP = ta.pivotlow(rsiWeekly, 5, 5)
wRHP = ta.pivothigh(rsiWeekly, 5, 5)
prevPriceLow_wRSI = ta.valuewhen(not na(priceLowPivot), low, 1)
prevRSIWeekly_Low = ta.valuewhen(not na(wRLP), rsiWeekly, 1)
prevPriceHigh_wRSI = ta.valuewhen(not na(priceHighPivot), high, 1)
prevRSIWeekly_High = ta.valuewhen(not na(wRHP), rsiWeekly, 1)

bool wBullRSI = not na(wRLP) and low < prevPriceLow_wRSI and rsiWeekly > prevRSIWeekly_Low
bool wBearRSI = not na(wRHP) and high > prevPriceHigh_wRSI and rsiWeekly < prevRSIWeekly_High

// MACD Persistence
// macdHighP and macdLowP defined above
prevPriceLow_MACD = ta.valuewhen(not na(priceLowPivot), low, 1)
prevMACD_Low      = ta.valuewhen(not na(macdLowP), macdLine, 1)
prevPriceHigh_MACD = ta.valuewhen(not na(priceHighPivot), high, 1)
prevMACD_High     = ta.valuewhen(not na(macdHighP), macdLine, 1)

bool dBullMACD = not na(priceLowPivot) and not na(macdLowP) and low < prevPriceLow_MACD and macdLine > prevMACD_Low
bool dBearMACD = not na(priceHighPivot) and not na(macdHighP) and high > prevPriceHigh_MACD and macdLine < prevMACD_High

wMLP = ta.pivotlow(wMACD, 5, 5)
wMHP = ta.pivothigh(wMACD, 5, 5)
prevPriceLow_wMACD = ta.valuewhen(not na(priceLowPivot), low, 1)
prevWMACD_Low      = ta.valuewhen(not na(wMLP), wMACD, 1)
prevPriceHigh_wMACD = ta.valuewhen(not na(priceHighPivot), high, 1)
prevWMACD_High     = ta.valuewhen(not na(wMHP), wMACD, 1)

bool wBullMACD = not na(wMLP) and low < prevPriceLow_wMACD and wMACD > prevWMACD_Low
bool wBearMACD = not na(wMHP) and high > prevPriceHigh_wMACD and wMACD < prevWMACD_High

// Unified Flags
sinceWBR = ta.barssince(wBullRSI)
sinceWBM = ta.barssince(wBullMACD)
sinceWBeR = ta.barssince(wBearRSI)
sinceWBeM = ta.barssince(wBearMACD)

bool bullWDiv = sinceWBR <= 15 or sinceWBM <= 15
bool bearWDiv = sinceWBeR <= 15 or sinceWBeM <= 15

sinceDBR = ta.barssince(dBullRSI)
sinceDBM = ta.barssince(dBullMACD)
sinceDBeR = ta.barssince(dBearRSI)
sinceDBeM = ta.barssince(dBearMACD)

bullishRSIDivergence = sinceDBR <= 10 or sinceWBR <= 15
bearishRSIDivergence = sinceDBeR <= 10 or sinceWBeR <= 15
bullishMACDDivergence = sinceDBM <= 10 or sinceWBM <= 15
bearishMACDDivergence = sinceDBeM <= 10 or sinceWBeM <= 15


// PART 6C: PRICE GAPS (Murphy Chapter 5)


gapThreshold = 0.003

// Gap Up (Bullish)
gapUp = low > high[1] * (1 + gapThreshold)
if showGaps and gapUp
    label.new(bar_index, low, 'GAP‚¨ÜÔ∏è', color = color.new(color.blue, 50), style = label.style_label_up, textcolor = color.blue, size = size.tiny, tooltip = 'Bullish Fair Value Gap (FVG):\nPrice jumped leaving an imbalance.\nOften acts as support.')
    box.new(bar_index - 1, high[1], bar_index, low, border_color = color.new(color.blue, 70), bgcolor = color.new(color.blue, 90))

// Gap Down (Bearish)
gapDown = high < low[1] * (1 - gapThreshold)
if showGaps and gapDown
    label.new(bar_index, high, 'GAP‚¨áÔ∏è', color = color.new(COL_ORANGE, 50), style = label.style_label_down, textcolor = color.red, size = size.tiny, tooltip = 'Bearish Fair Value Gap (FVG):\nPrice dropped leaving an imbalance.\nOften acts as resistance.')
    box.new(bar_index - 1, low[1], bar_index, high, border_color = color.new(color.red, 70), bgcolor = color.new(color.red, 90))

// Breakaway Gap (at start of new trend with high volume)
breakawayGap = (gapUp or gapDown) and highVolume and (uptrend or downtrend)

// Exhaustion Gap (at end of trend - potential reversal)
exhaustionGap = gapUp and uptrend and rsiOB or gapDown and downtrend and rsiOS

// PART 6D: CONSOLIDATION & ACCUMULATION

// Consolidation Detection (low volatility, tight range)
priceRangeAbs = high - low
avgRangeAbs = ta.sma(priceRangeAbs, 20)
avgAtr50 = ta.sma(atr, 50)
isConsolidating = priceRangeAbs < avgRangeAbs * 0.5 and atr < avgAtr50

// Accumulation (price stable, volume increasing, bullish)
isAccumulation = isConsolidating and volume > volMA and obvBullish

// Distribution (price stable, volume increasing, bearish)
isDistribution = isConsolidating and volume > volMA and obvBearish

// PART 7: TIMEFRAME-SPECIFIC SETTINGS (Murphy's Multi-Timeframe Analysis)

// Timeframe detection already done in Part 4B

// Timeframe-specific ATR multipliers (Murphy recommends wider stops for higher timeframes)
// Reduced multipliers for more realistic stop loss levels
atrMultiplierTF = isMonthly ? 2.0 : isWeekly ? 1.5 : isDaily ? 1.2 : 1.0
// riskRewardTF logic removed (Using Input instead)

// Timeframe display
tfDisplay = isMonthly ? 'MONTHLY' : isWeekly ? 'WEEKLY' : isDaily ? 'DAILY' : currentTF

// TRIPLE GAP (SAN-KU) PATTERN - Japanese Candlestick Pattern
// One of the most powerful reversal patterns in Japanese candlestick analysis
// Three consecutive gaps in the same direction = momentum exhaustion
// Bullish Triple Gap: 3 gaps down ‚Üí reversal up (buy signal)
// Bearish Triple Gap: 3 gaps up ‚Üí reversal down (sell signal)

// Count consecutive gaps
consecutiveGapsUp = gapUp ? (gapUp[1] ? (gapUp[2] ? 3 : 2) : 1) : 0
consecutiveGapsDown = gapDown ? (gapDown[1] ? (gapDown[2] ? 3 : 2) : 1) : 0

// Triple Gap pattern detected
tripleGapBullish = consecutiveGapsDown >= 3  // 3 gaps down = buy signal (reversal)
tripleGapBearish = consecutiveGapsUp >= 3  // 3 gaps up = sell signal (reversal)

tripleGapBearishStrength = tripleGapBearish ? 80 : 0

// PART 7B: MARKET REGIME (PREDICTIVE ENGINE)
// 1. Efficiency Ratio (Kaufman's ER)
// Length 30 is standard for Fractal Efficiency
// Length is now dynamic based on input
efficiencyRatio = calcEfficiencyRatio(erLength)
// ADX Override: If ADX > Threshold, we are trending regardless of ER (prevents lag on V-shapes)
isChoppyMarket = efficiencyRatio < 0.20 and adx < adxTrendThresh // Lowered from 0.25 to 0.20 to reduce false positives
isTrendingMarket = efficiencyRatio > 0.30 or adx > adxTrendThresh // High Efficiency OR High Strength = Trend

// --- 11. TRAP FATIGUE & FATIGUE PROTECTION (NEW) ---
// Institutional Logic: If a level is tested too many times, it weakens.
// Real institutional absorption happens on the 1st or 2nd test. 4th test is usually a breakdown.
// Support Weakening Detection (with Volume Filter)
// Only count "Damage" if the test happens on ABOVE AVERAGE volume.
// Low volume tests = Absorption (Strength), High volume tests = Distribution (Weakness)
supportTestCount = math.sum(low < (keySupport * 1.01) and volume > volAvg20 ? 1 : 0, 25)
isSupportWeakened = not na(keySupport) and supportTestCount > 3

// Resistance Weakening Detection (with Volume Filter)
resistanceTestCount = math.sum(high > (keyResistance * 0.99) and volume > volAvg20 ? 1 : 0, 25)
isResistanceWeakened = not na(keyResistance) and resistanceTestCount > 3

// 2. Liquidity Sweeps (High Confidence Reversal)
// Calculate PIVOTS (Lagging Confirmation)
pl = ta.pivotlow(low, liqPivotLength, liqPivotLength)
ph = ta.pivothigh(high, liqPivotLength, liqPivotLength)

// ACTIVE PIVOT TRACKING (Zero-Lag State)
// We must remember the LAST confirmed pivot to check for sweeps in REAL-TIME.
var float activeLiqPivotLow = na
var float activeLiqPivotHigh = na

if not na(pl)
    activeLiqPivotLow := pl
if not na(ph)
    activeLiqPivotHigh := ph

// Calculate sweeps using ACTIVE pivots (Compares CURRENT price to OLD level)
// FATIGUE SYNCED: Sweeps are ignored if support/resistance is weakened (high risk of breakdown)
[bullishSweep, bearishSweep, sweepLevelBull, sweepLevelBear] = checkLiquiditySweep(close, low, high, activeLiqPivotLow, activeLiqPivotHigh, isSupportWeakened, isResistanceWeakened)

// --- 11.2 FAILED SWEEP DETECTION (DUMP/MOON HUNTER) ---
// Logic: If price breaks below a bullish sweep low, it's a massive bearish signal (Trapped Bulls).
// If price breaks above a bearish sweep high, it's a massive bullish signal (Trapped Bears).
var float lastBullSweepLow = na
var int lastBullSweepBar = 0
var float lastBearSweepHigh = na
var int lastBearSweepBar = 0

if bullishSweep
    lastBullSweepLow := sweepLevelBull
    lastBullSweepBar := bar_index
if bearishSweep
    lastBearSweepHigh := sweepLevelBear
    lastBearSweepBar := bar_index

crossUnderBullSweep = ta.crossunder(close, lastBullSweepLow)
crossOverBearSweep  = ta.crossover(close, lastBearSweepHigh)
failedBullishSweep = not na(lastBullSweepLow) and bar_index - lastBullSweepBar <= 10 and crossUnderBullSweep
failedBearishSweep = not na(lastBearSweepHigh) and bar_index - lastBearSweepBar <= 10 and crossOverBearSweep

// Reset if too old
if bar_index - lastBullSweepBar > 10
    lastBullSweepLow := na
if bar_index - lastBearSweepBar > 10
    lastBearSweepHigh := na
// These override "Chop" status because they are Mean Reversion signals specific to chop

// --- 10. INSTITUTIONAL SIGNAL LAYER (Gaps & FVG) ---
gapThresholdInst = 0.02 // 2%
volThresholdInst = 2.0  // 2x volume
isGapUpInst = low > high[1] * (1 + gapThresholdInst) and volume > avgVolume20 * volThresholdInst
isGapDownInst = high < low[1] * (1 - gapThresholdInst) and volume > avgVolume20 * volThresholdInst

// 4. Fair Value Gaps (FVG)
[bullishFVG, bearishFVG] = checkFVG(high[2], low, low[2], high)

// Fair Value Gaps used as directional filters to block counter-trend entries.
bool bearishFVGActive = bearishFVG or bearishFVG[1] or bearishFVG[2]
bool bullishFVGActive = bullishFVG or bullishFVG[1] or bullishFVG[2]

// FVG blocks opposite direction trades
bool fvgAllowsBuy = not (downtrend and bearishFVGActive)  // Block buys during bearish FVG in downtrend
bool fvgAllowsSell = not (uptrend and bullishFVGActive)   // Block sells during bullish FVG in uptrend


barMidpoint = hl2
isLowVolumeTrap = volume < volAvg20 * 0.7 // Optimized: Use global volAvg20

// High-Fidelity Trap Logic (Moved Upstream for Scoring)
bearTrap = not na(keySupport) and low < keySupport * 1.02 and close > barMidpoint and isLowVolumeTrap and not isSupportWeakened
bullTrap = not na(keyResistance) and high > keyResistance * 0.98 and close < barMidpoint and isLowVolumeTrap and not isResistanceWeakened

// CANONICAL HIKKAKE PATTERN (Based on hikkake.pine reference)
// Bar[2] = Mother Bar, Bar[1] = Inside Bar, Bar[0] = Fake-out + Confirmation

// Step 1: Inside Bar - Bar[1] is completely inside Bar[2]
bool insideBar = high[1] < high[2] and low[1] > low[2]

// Step 2: Fake-out Bar - Current bar (Bar[0]) must be ENTIRELY outside Inside Bar range
// This is stricter than just a wick - the WHOLE bar must break out in one direction
bool fakeoutBullSetup = high < high[1] and low < low[1]   // Entire bar BELOW Inside Bar (traps bears)
bool fakeoutBearSetup = high > high[1] and low > low[1]   // Entire bar ABOVE Inside Bar (traps bulls)

// Step 3: Confirmation - Close reverses beyond the Inside Bar's opposite side
// For Bullish: Fakeout was DOWN, so confirmation is Close > Inside Bar High
// For Bearish: Fakeout was UP, so confirmation is Close < Inside Bar Low
bool bullishHikkake = insideBar[1] and fakeoutBullSetup[1] and close > high[2]
bool bearishHikkake = insideBar[1] and fakeoutBearSetup[1] and close < low[2]

// PIN BAR PATTERN (Professional Standard)
// A pin bar has a long tail indicating rejection, with a small body at the opposite end
// Minimum tail:body ratio of 2:1 is required for a valid pin bar
// Note: bodySize is already defined globally at line 2699
float pinUpperWick = high - math.max(close, open)
float pinLowerWick = math.min(close, open) - low
float pinTotalRange = high - low

// Bullish Pin Bar: Long lower wick (rejection of lows), small body at top
bool bullishPinBar = pinTotalRange > 0 and 
     pinLowerWick > (bodySize * 2.0) and      // Lower wick at least 2x body
     pinLowerWick > (pinTotalRange * 0.6) and // Lower wick is 60%+ of total range
     pinUpperWick < (pinTotalRange * 0.25)    // Upper wick is small (max 25%)

// Bearish Pin Bar: Long upper wick (rejection of highs), small body at bottom
bool bearishPinBar = pinTotalRange > 0 and 
     pinUpperWick > (bodySize * 2.0) and      // Upper wick at least 2x body
     pinUpperWick > (pinTotalRange * 0.6) and // Upper wick is 60%+ of total range
     pinLowerWick < (pinTotalRange * 0.25)    // Lower wick is small (max 25%)

// ENGULFING PATTERN (Institutional Momentum Shift)
// Current candle completely engulfs the previous candle's body
float engPrevBody = math.abs(close[1] - open[1])
float engCurrBody = math.abs(close - open)
bool engPrevBullish = close[1] > open[1]
bool engPrevBearish = close[1] < open[1]
bool engCurrBullish = close > open
bool engCurrBearish = close < open

// Bullish Engulfing: Red candle followed by larger green candle that engulfs it
bool bullishEngulfingStrict = engPrevBearish and engCurrBullish and 
     open <= close[1] and close >= open[1] and  // Current body engulfs previous body
     engCurrBody > engPrevBody * 1.1                   // Current body is at least 10% larger

// Bearish Engulfing: Green candle followed by larger red candle that engulfs it
bool bearishEngulfingStrict = engPrevBullish and engCurrBearish and 
     open >= close[1] and close <= open[1] and  // Current body engulfs previous body
     engCurrBody > engPrevBody * 1.1                   // Current body is at least 10% larger

// PART 8: COMPREHENSIVE SIGNAL GENERATION (All Murphy Concepts)

// BUY SIGNALS - Organized by CATEGORY (Murphy's Confluence Method)
// MURPHY'S RULE: "Buy strength, sell weakness" - Focus on CONTINUATION, not reversal
// Category 1: TREND (Restored for Dashboard)
ma1CrossMa2 = ta.crossover(ma1, ma2)
buyTrend1 = ma1CrossMa2 and uptrend
buyTrend2 = goldenCross
buyTrend3 = uptrend and close > ma1 and ma1 > ma2 and ma2 < ma3
buyTrend4 = allTimeframesAlignedBullish
buyTrend5 = majorTimeframesAlignedBullish and uptrend
buyTrend6 = weinsteinStage == 2

buyTrendScore = (buyTrend1 ? 1 : 0) + (buyTrend2 ? 1 : 0) + (buyTrend3 ? 1 : 0) + (buyTrend4 ? 2 : 0) + (buyTrend5 ? 1 : 0) + (buyTrend6 ? 2 : 0) 

adjustedMaxRisk = baseMaxRisk // Corrected: baseMaxRisk is already decimal

// 11.2. MOMENTUM SIGNALS (Crosses & Divergence Pulses)
kCrossD = ta.crossover(k, d)

// SWING LOW/HIGH DETECTION (Adaptive resolution based on timeframe)
swingLookback = isDaily ? 50 : isWeekly ? 20 : isMonthly ? 12 : 20  // 50 days = 2.5 months of daily data
swingLowForSL = ta.lowest(low, swingLookback)
swingHighForSL = ta.highest(high, swingLookback)

// 11.3. ANCHORED VWAP (Institutional Anchors)
isNewHigh3M = isNewHigh3MSig
isNewLow3M = isNewLow3MSig

if volatilityPercentile > 70 // High volatility = tighter stops
    adjustedMaxRisk := adjustedMaxRisk * 0.7 // 30% tighter
if isMonthly // Higher timeframes get slightly more room
    adjustedMaxRisk := adjustedMaxRisk * 1.2
else if isWeekly
    adjustedMaxRisk := adjustedMaxRisk * 1.1

// Absolute cap: NEVER more than 3% (baseMaxRisk) regardless of calculation
maxRiskPct = math.min(baseMaxRisk, adjustedMaxRisk)

// --- 11.4. POSITION TRACKING & STRUCTURAL MAPPING ---
pivotLowPrice = ta.pivotlow(low, 10, 10) // 10 bars left, 10 bars right (Significant Structure)
lowestLow20 = ta.lowest(low, 50) // 50-bar Lookback (Structural Floor)
entrySwingLow = na(pivotLowPrice) ? lowestLow20 : pivotLowPrice  // Renamed to avoid conflict
pivotHighPrice = ta.pivothigh(high, 10, 10) // 10 bars left, 10 bars right
highestHigh20 = ta.highest(high, 50) // 50-bar Lookback (Structural Ceiling)
entrySwingHigh = na(pivotHighPrice) ? highestHigh20 : pivotHighPrice  // Renamed to avoid conflict

// AGE TRACKING (for Recency Decay)
// Offset by 10 because a 10/10 pivot is only confirmed 10 bars after the event
pivotLowAge  = ta.barssince(not na(pivotLowPrice))  + 10
pivotHighAge = ta.barssince(not na(pivotHighPrice)) + 10


// Calculate Bollinger Bands for Entry Logic (if not already defined)
[bbMiddleEntry, bbUpperEntry, bbLowerEntry] = ta.bb(close, 20, 2)

// ROCKET LOGIC ENGINE (Parabolic Move Detection)
// Detects massive momentum where standard supports lag too much
// Triggers: RSI > 70 OR Close > Bollinger Upper OR ADX > 30
rocketMA = ta.ema(close, 8) // The "Rocket Line" (EMA 8) standard
rsiVal = ta.rsi(close, 14)
isParabolicLong = (rsiVal > 70) or (close > bbUpperEntry)  // True blow-off only (no ADX)
isParabolicShort = (rsiVal < 30) or (close < bbLowerEntry) // True capitulation only (no ADX)

// ZONE STABILIZATION: Locks zones to historical close to prevent intraday shifting.
float stableClose = barstate.isrealtime ? close[1] : close

// FIX 2: OVERNIGHT GAP PROTECTION
// If price gaps > 1% from previous close, force use of current close for zone calculation.
// This prevents stale zones when a gap invalidates yesterday's levels.
float gapPct = math.abs(open - close[1]) / close[1]
bool isSignificantGap = gapPct > 0.01  // > 1% gap

// FIX 3: INTRADAY DEVIATION PROTECTION (NEW)
// If current price has moved > 1.5% from previous close, use current close.
// This prevents zones from being calculated using stale reference points.
float intradayDeviation = math.abs(close - close[1]) / close[1]
bool isSignificantIntradayMove = intradayDeviation > 0.015  // > 1.5% move

if isSignificantGap or isSignificantIntradayMove
    stableClose := close  // Use current close, not yesterday's

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ZONE RESET: Force fresh calculation every bar (Prevents stale data persistence)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
longZoneLow := na
longZoneHigh := na
shortZoneLow := na
shortZoneHigh := na


// --- GHOST ZONE SUPPRESSION (Hard Kill) ---
// If price breaks below long support or above short resistance, kill the memory anchor
defenderLong = nz(suggestedEntryLong[1])
if defenderLong > 0 and (failedBullishSweep or close < defenderLong * 0.995) // Kill anchor on breach OR specific failed sweep
    defenderLong := 0.0

defenderShort = nz(suggestedEntryShort[1])
if defenderShort > 0 and (failedBearishSweep or close > defenderShort * 1.005) // Kill anchor on breach OR specific failed sweep
    defenderShort := 0.0

// --- 11.5. ENTRY ENGINE EXECUTION (Long & Short) ---
float atrShortTerm = ta.atr(5)
// Unified parameters for new Entry Engine
techFloatsL = array.from(pivotLowPrice, entrySwingLow, pivotHighPrice, fib618, fib50, ma1, stableClose, swingLowForSL, atr, riskRewardTF, vwma200, hma20, bbLowerEntry, anchoredVWAP, sweepLevelBull, keySupport, rocketMA, defenderLong, atrShortTerm, adx, volatilityPercentile, weekHigh52, weekLow52, scoreVWMA, scoreHMA, scoreBB, maxRiskPct, yOpenMacro, qOpenMacro, wExpectedLower, pwLowM, mOpenMacro, wOpenMacro, yHighMacro, yLowMacro, dL52, gcPrice, dcPrice, avwapLow, currentBoxTop, currentBoxBottom, keyResistance, pivotLowAge, pivotHighAge)
techBoolsL  = array.from(uptrend, downtrend, darvasBoxValid, bullishSweep, isParabolicLong, isChoppyMarket)

[resEL, resSL, resTP, resRTP, resZH, resZL, resAN, resZS, resZSL_idx] = calcEntryExit(true, techFloatsL, techBoolsL, structurePriorityMode ? 1 : 0, currentBoxBottom, atrMultiplierTF)
suggestedEntryLong      := resEL
suggestedStopLossLong   := resSL
suggestedTakeProfitLong := resTP
rawTakeProfitLong       := resRTP
longZoneHigh            := resZH
longZoneLow             := resZL
longAnchorName          := resAN
longZoneScore           := resZS
longZoneStartIdx        := resZSL_idx

techFloatsS = array.from(pivotHighPrice, entrySwingHigh, pivotLowPrice, fib382, fib50, ma1, stableClose, swingHighForSL, atr, riskRewardTF, vwma200, hma20, bbUpperEntry, anchoredVWAP, sweepLevelBear, keyResistance, rocketMA, defenderShort, atrShortTerm, adx, volatilityPercentile, weekLow52, weekHigh52, scoreVWMA, scoreHMA, scoreBB, maxRiskPct, yOpenMacro, qOpenMacro, wExpectedUpper, pwHighM, mOpenMacro, wOpenMacro, yHighMacro, yLowMacro, dH52, gcPrice, dcPrice, avwapHigh, currentBoxTop, currentBoxBottom, keySupport, pivotHighAge, pivotLowAge)
techBoolsS  = array.from(downtrend, uptrend, darvasBoxValid, bearishSweep, isParabolicShort, isChoppyMarket)

[resES, resSS, resTPS, resRTPS, resZHS, resZLS, resANS, resZSS, resZSS_idx] = calcEntryExit(false, techFloatsS, techBoolsS, structurePriorityMode ? 1 : 0, currentBoxTop, atrMultiplierTF)
suggestedEntryShort      := resES
suggestedStopLossShort   := resSS
suggestedTakeProfitShort := resTPS
rawTakeProfitShort       := resRTPS
shortZoneHigh            := resZHS
shortZoneLow             := resZLS
shortAnchorName          := resANS
shortZoneScore           := resZSS
shortZoneStartIdx        := resZSS_idx


// --- GHOST SETUP FILTER (XLF FIX) ---
// Logic: If target is met, the setup is "dead" until we return to the entry zone.
if not na(suggestedTakeProfitLong) and close >= suggestedTakeProfitLong
    longSetupActive := false
if not na(longZoneHigh) and close <= longZoneHigh // Revive if price returns to zone or below
    longSetupActive := true

if not na(suggestedTakeProfitShort) and close <= suggestedTakeProfitShort
    shortSetupActive := false
if not na(shortZoneLow) and close >= shortZoneLow // Revive if price returns to zone or above
    shortSetupActive := true


// --- ZONE PROCESSING & REFINEMENT (Global) ---
// Unpack Secondary Zones (Moved from Line 4517)
longZoneHigh2 := array.get(secondaryZoneInfo, 0)
longZoneLow2 := array.get(secondaryZoneInfo, 1)
longZoneScore2 := array.get(secondaryZoneInfo, 2)
shortZoneHigh2 := array.get(secondaryZoneInfo, 3)
shortZoneLow2 := array.get(secondaryZoneInfo, 4)
shortZoneScore2 := array.get(secondaryZoneInfo, 5)
string longAnchorName2 = array.get(secondaryZoneNames, 0)
string shortAnchorName2 = array.get(secondaryZoneNames, 1)

// Calculate Validity Flags (Moved from Line 4572)
// FIXED LOGIC: Use Near Edge for Stale Check, Far Edge for Broken Check
// Long (Support): Top must be >= 97% Close (Stale), Bottom must be <= 100.5% Close (Broken)
bool primaryLongNearby = not na(longZoneHigh) and longZoneLow <= close * 1.005 and longZoneHigh >= close * 0.97
bool secondaryLongNearby = not na(longZoneHigh2) and longZoneLow2 <= close * 1.005 and longZoneHigh2 >= close * 0.97

// Short (Resistance): Bottom must be <= 103% Close (Stale), Top must be >= 99.5% Close (Broken)
bool primaryShortNearby = not na(shortZoneHigh) and shortZoneHigh >= close * 0.995 and shortZoneLow <= close * 1.03
bool secondaryShortNearby = not na(shortZoneHigh2) and shortZoneHigh2 >= close * 0.995 and shortZoneLow2 <= close * 1.03

// Zone Promotion (Swap if Primary Stale & Secondary Fresh)
// Moved from Line 4580 to ensure Scoring sees the Best Zone
if not primaryLongNearby and secondaryLongNearby
    float tempH = longZoneHigh, float tempL = longZoneLow, float tempS = longZoneScore
    longZoneHigh := longZoneHigh2, longZoneLow := longZoneLow2, longZoneScore := longZoneScore2
    longZoneHigh2 := tempH, longZoneLow2 := tempL, longZoneScore2 := tempS
    primaryLongNearby := true // Now primary is valid
    string tempN = longAnchorName
    longAnchorName := longAnchorName2
    longAnchorName2 := tempN

if not primaryShortNearby and secondaryShortNearby
    float tempH = shortZoneHigh, float tempL = shortZoneLow, float tempS = shortZoneScore
    shortZoneHigh := shortZoneHigh2, shortZoneLow := shortZoneLow2, shortZoneScore := shortZoneScore2
    shortZoneHigh2 := tempH, shortZoneLow2 := tempL, shortZoneScore2 := tempS
    primaryShortNearby := true // Now primary is valid
    string tempN = shortAnchorName
    shortAnchorName := shortAnchorName2
    shortAnchorName2 := tempN

// GLOBAL ZONE STATE DEFINITIONS (For Scoring & Confluence)
// Uses the corrected/promoted zones
float zoneToleranceGlobal = atr * 0.1
bool inLongZone = primaryLongNearby and close >= (longZoneLow - zoneToleranceGlobal) and close <= (longZoneHigh + zoneToleranceGlobal)
bool inShortZone = primaryShortNearby and close >= (shortZoneLow - zoneToleranceGlobal) and close <= (shortZoneHigh + zoneToleranceGlobal)



// --- 11.6. RISK MANAGEMENT & STOP REFINEMENT ---
bool toxicRiskLong = false
bool toxicRiskShort = false

// MAX RISK CAP: Don't let stop be more than 3% from entry
// NOTE: This logic is now handled internally by calcEntryExitLong/Short (Critical Fix)
// We just need to read the score to check for Toxic Risk.
// If score is -100, it means the setup is Toxic (Stop forced into technical zone).

if longZoneScore == -100
    toxicRiskLong := true

if shortZoneScore == -100
    toxicRiskShort := true

// MTF TARGET OVERRIDE (Structural Magnets)
// The user wants "Multi Time Frame" logic because ATR targets are too tight in crashes.
// Logic: Target the First Major Resistance/Support (50 EMA, 200 EMA, Pivot, or 52W H/L).

// A. LONG TARGETS (Ceilings)
float r1 = (weeklyMA2 > suggestedEntryLong * 1.02) ? weeklyMA2 : 999999.0 // Weekly 50
float r2 = (weeklyMA3 > suggestedEntryLong * 1.02) ? weeklyMA3 : 999999.0 // Weekly 200
float r3 = (not na(pivotHighPrice) and pivotHighPrice > suggestedEntryLong * 1.02) ? pivotHighPrice : 999999.0 // Pivot High
float r4 = weekHigh52 // Ceiling (52W High)

// Pick the Lowest valid resistance (The first ceiling we hit)
float structuralCeiling = math.min(r1, r2, r3)
if structuralCeiling == 999999.0
    structuralCeiling := r4

// Sanity Check: If target is >20% above entry, use a more reasonable 10% ATR-based target
// TARGET MIGRATION (Blue Sky Fix): If Price is at ATH (no resistance), use Fib Extensions
bool isBlueSky = close > r3 // Above all pivots
if structuralCeiling == 999999.0 or isBlueSky
    structuralCeiling := suggestedEntryLong + (fibRange * 1.618) // Target the 1.618 Extension

if structuralCeiling > suggestedEntryLong * 1.20 and close < weekHigh52
    structuralCeiling := suggestedEntryLong + (atr * 4)

suggestedTakeProfitLong := structuralCeiling

// B. SHORT TARGETS (Floors)
float t1 = (weeklyMA2 < suggestedEntryShort * 0.98) ? weeklyMA2 : 0.0 // Weekly 50
float t2 = (weeklyMA3 < suggestedEntryShort * 0.98) ? weeklyMA3 : 0.0 // Weekly 200
float t3 = (not na(pivotLowPrice) and pivotLowPrice < suggestedEntryShort * 0.98) ? pivotLowPrice : 0.0 // Pivot Low
float t4 = weekLow52 // Backbone (52W Low)

// Pick the Highest valid support (The first floor we hit)
float structuralFloor = math.max(t1, t2, t3)
if structuralFloor == 0.0
    structuralFloor := t4

// SANITY CHECK: If target is >15% below entry, use a more reasonable 10% ATR-based target
float maxDropPct = 0.15
if structuralFloor < suggestedEntryShort * (1 - maxDropPct)
    structuralFloor := suggestedEntryShort - (atr * 3) // Reasonable ATR-based fallback

suggestedTakeProfitShort := structuralFloor


// ENHANCEMENT 9: Score-Based Opacity (Heatmap Logic)
// Maps a confluence score to a transparency value (0-100)
// High Score (10+) -> Low Alpha (Solid)
// Low Score (4) -> High Alpha (Faded)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SMART RISK ASSESSMENT (Synced with Live Calculations)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
sharpePass = not na(sharpeRatio) ? sharpeRatio >= minSharpe : true
sharpeFail = not na(sharpeRatio) ? sharpeRatio < minSharpe : false

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INITIAL RISK ASSESSMENT (Core Filters)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
adxPasses = adx >= adxTrendThresh
// Fixed: maxDrawdown is negative (e.g., -35%), so check if it's > -maxDD (less severe than threshold)
// Default to TRUE if drawdown is na (young stocks) to avoid perpetual "Caution"
ddPass = na(maxDrawdown) or (maxDrawdown > -maxDD)
isSafeToTrade = riskScore <= maxRiskScoreAllowed and sharpePass and ddPass and adxPasses
isCautionZone = riskScore > maxRiskScoreAllowed and riskScore <= maxRiskScoreAllowed + 20 and sharpePass
isDangerous = riskScore > maxRiskScoreAllowed + 20 or sharpeFail or (not na(maxDrawdown) and maxDrawdown < -(maxDD + 20))

// Dashboard Variables (Initial)
string tradingDecision = ""
color tradingDecisionColor = color.gray
int recommendedPositionSize = 0

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SUPREME LAW OF RISK MANAGEMENT: FINAL GLOBAL CLAMP (3% CAP)
// Consolidates all safety checks, caps, and target syncs before decisions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// 4. Position Sizing Logic (Moved banners below final clamp)
maxPosSize = isSafeToTrade ? 100 : isCautionZone ? 50 : isDangerous ? 0 : 25
recommendedPositionSize := math.round(maxPosSize * (100 - riskScore) / 100)

// RESISTANCE PROXIMITY CHECK - Warning if target is near resistance
// Check if LONG target is within 2% of major resistance (pivot highs)
longTargetNearResistance = false
resistanceWarningLong = ''
if not na(pivotHighPrice) and math.abs(suggestedTakeProfitLong - pivotHighPrice) / suggestedTakeProfitLong < 0.02
    longTargetNearResistance := true
    resistanceWarningLong := '‚ö†Ô∏è Target near pivot high'

// Check if LONG target has big gap to resistance (>50% beyond resistance)
longTargetFarBeyondResistance = false
if not na(pivotHighPrice) and suggestedTakeProfitLong > pivotHighPrice * 1.50
    longTargetFarBeyondResistance := true
    resistanceWarningLong := '‚ö° Target extends far beyond resistance'

// Check if SHORT target is within 2% of major support (pivot lows)
shortTargetNearSupport = false
resistanceWarningShort = ''
if not na(pivotLowPrice) and math.abs(suggestedTakeProfitShort - pivotLowPrice) / suggestedTakeProfitShort < 0.02
    shortTargetNearSupport := true
    resistanceWarningShort := '‚ö†Ô∏è Target near pivot low'

// Check if SHORT target has big gap to support (>50% beyond support)
shortTargetFarBeyondSupport = false
if not na(pivotLowPrice) and suggestedTakeProfitShort < pivotLowPrice * 0.50
    shortTargetFarBeyondSupport := true
    resistanceWarningShort := '‚ö° Target extends far beyond support'

// ENTRY STATUS: Are we at entry level or need to wait?
atEntryLong = close <= suggestedEntryLong * 1.002 // Within 0.2% of entry
atEntryShort = close >= suggestedEntryShort * 0.998

distanceToEntryLong = close > 0 ? (close - suggestedEntryLong) / close * 100 : 0 // % above entry
distanceToEntryShort = close > 0 ? (suggestedEntryShort - close) / close * 100 : 0 // % below entry

// Parsing Dual-Naming for UI Clarity
longAnchorSplit = str.split(longAnchorName, "|")
longDisplayAnchor = array.size(longAnchorSplit) > 0 ? array.get(longAnchorSplit, 0) : longAnchorName
longTooltipAnchor = array.size(longAnchorSplit) > 1 ? array.get(longAnchorSplit, 1) : longAnchorName

shortAnchorSplit = str.split(shortAnchorName, "|")
shortDisplayAnchor = array.size(shortAnchorSplit) > 0 ? array.get(shortAnchorSplit, 0) : shortAnchorName
shortTooltipAnchor = array.size(shortAnchorSplit) > 1 ? array.get(shortAnchorSplit, 1) : shortAnchorName

// Identify WHICH level was chosen (for dashboard display)
entryLevelNameLong = longDisplayAnchor
entryLevelNameShort = shortDisplayAnchor

// Reason Building (Updated for Tooltips)
entryReasonLong = longDisplayAnchor + '\n‚Üí ' + str.format('{0,number,#.#}', distanceToEntryLong) + '% from current price'
entryReasonShort = shortDisplayAnchor + '\n‚Üí ' + str.format('{0,number,#.#}', distanceToEntryShort) + '% from current price'

momentumBullish = rsi > 50 and macdLine > 0
newHighs = high > high[1]

buyMomentum1 = rsi < 30 and rsi > rsi[1] and not downtrend  // Momentum Check: Oversold bounce filtering.
buyMomentum2 = ta.crossover(macdLine, signalLine)
buyMomentum3 = kCrossD
buyMomentum4 = momentumBullish
buyMomentum5 = macdLine > signalLine and macdLine > 0
buyMomentum6 = rsi > 50 and rsi > rsi[1] + 5
buyMomentum7 = elderBuySignal or elderStrongBuy or elderScreen3Buy
buyMomentum8 = newHighs
buyMomentum9 = impulseGreen

buyMomentumScore = (buyMomentum1 ? 1 : 0) + (buyMomentum2 ? 1 : 0) + (buyMomentum3 ? 1 : 0) + (buyMomentum4 ? 1 : 0) + (buyMomentum5 ? 1 : 0) + (buyMomentum6 ? 1 : 0) + (buyMomentum7 ? 2 : 0) + (buyMomentum8 ? 1 : 0) + (buyMomentum9 ? 1 : 0)

// Category 1: SELL TREND (Restored for Dashboard)
ma1CrossMa2Down = ta.crossunder(ma1, ma2)
sellTrend1 = ma1CrossMa2Down and downtrend
sellTrend2 = deathCross
sellTrend3 = downtrend and close < ma1 and ma1 < ma2 and ma2 < ma3
sellTrend4 = allTimeframesAlignedBearish
sellTrend5 = majorTimeframesAlignedBearish and downtrend
sellTrend6 = weinsteinStage == 4
sellTrendScore = (sellTrend1 ? 1 : 0) + (sellTrend2 ? 1 : 0) + (sellTrend3 ? 1 : 0) + (sellTrend4 ? 2 : 0) + (sellTrend5 ? 1 : 0) + (sellTrend6 ? 2 : 0)

// Category 2: SELL MOMENTUM (Restored)
kCrossDDown = ta.crossunder(k, d)

sellMomentum1 = rsiOB and rsi < rsi[1]
sellMomentum2 = macdBearish and macdLine > 0
sellMomentum3 = stochOB and kCrossDDown
sellMomentum4 = cciOB or williamsOB or mfiOB
sellMomentum5 = macdLine < signalLine and macdLine < 0 and downtrend
sellMomentum6 = connorsSellSignal
sellMomentum7 = elderSellSignal or elderStrongSell or elderScreen3Sell
sellMomentum8 = impulseRed or impulseRedStreak
sellMomentum9 = tripleGapBearish // Triple Gap (San-Ku)
sellMomentumScore = (sellMomentum1 ? 1 : 0) + (sellMomentum2 ? 1 : 0) + (sellMomentum3 ? 1 : 0) + (sellMomentum4 ? 1 : 0) + (sellMomentum5 ? 1 : 0) + (sellMomentum6 ? 2 : 0) + (sellMomentum7 ? 2 : 0) + (sellMomentum8 ? impulseRedStreak ? 2 : 1 : 0) + (sellMomentum9 ? 2 : 0)

// Category 3: SUPPORT/BREAKOUT (Murphy: Buy at support OR breakouts, not breakdowns)
buyVolatility1 = close > ma1 and close[1] <= ma1[1] and uptrend // Pullback to MA support (Murphy's method!)
buyVolatility2 = close > psar and close[1] <= psar[1] and strongTrend // PSAR support
buyVolatility3 = close > fib618 and close[1] <= fib618 and uptrend // Fib support bounce
buyVolatility4 = close > psar and uptrend and strongTrend // PSAR confirms uptrend (continuation)
buyVolatility5 = strongTrend and uptrend and adx > 30 // ADX confirms strong uptrend (Murphy: high ADX = strong trend!)
buyVolatility6 = sqzOn // Volatility Squeeze (Jan 4 Standard)
buyVolatility7 = darvasBreakoutStrong or inDarvasBox and darvasBoxQuality >= 60 // Darvas: Breakout or in tight box
buyVolatilityScore = (buyVolatility1 ? 2 : 0) + (buyVolatility2 ? 1 : 0) + (buyVolatility3 ? 1 : 0) + (buyVolatility4 ? 1 : 0) + (buyVolatility5 ? 1 : 0) + (buyVolatility6 ? 1 : 0) + (buyVolatility7 ? darvasBreakoutStrong ? 2 : 1 : 0)

// Category 4: VOLUME (includes both surges AND healthy continuation)
buyVolume1 = volumeConfirmsBull and obvBullish // OBV bullish
volumeStdev = ta.stdev(volume, 20)
buyVolume2 = volume > (volMA + volumeStdev * 2.0) and close > open // Significant Volume Surge (Z-Score > 2)
buyVolume3 = obvBullish and uptrend // OBV confirming uptrend (continuation)
buyVolume4 = adLineBullish and uptrend // Chaikin A/D Line - institutional accumulation
buyVolumeScore = (buyVolume1 ? 1 : 0) + (buyVolume2 ? 1 : 0) + (buyVolume3 ? 1 : 0) + (buyVolume4 ? 1 : 0)

// Category 5: DIVERGENCE (High Value) - MOVED UP TO FIX UNDECLARED IDENTIFIER
// 3A. BULLISH SCORE DIVERGENCE (Top Detection) - Moved Up
highestRecentBuyMom = ta.highest(buyMomentumScore, 20)
highestRecentPriceForDiv = ta.highest(close, 20)
isBullishScoreDivergence = checkScoreDivergence(close, buyMomentumScore, highestRecentPriceForDiv, highestRecentBuyMom, enableScoreDivergence, false)

// 3B. BEARISH SCORE DIVERGENCE (Selling pressure exhausting) - Moved Up
highestRecentSellMom = ta.highest(sellMomentumScore, 20)
lowestRecentPriceForDiv = ta.lowest(close, 20)
isBearishScoreDivergence = checkScoreDivergence(close, sellMomentumScore, lowestRecentPriceForDiv, highestRecentSellMom, enableScoreDivergence, true)

buyDivergence = bullishRSIDivergence or bullishMACDDivergence or isBullishScoreDivergence
buyDivergenceScore = buyDivergence ? 1 : 0

sellDivergence = bearishRSIDivergence or bearishMACDDivergence or isBearishScoreDivergence
sellDivergenceScore = sellDivergence ? 1 : 0

// Total Buy Score
// Category Count (Initialize early for confluence tracking)
buyCategories = (buyTrendScore > 0 ? 1 : 0) + (buyMomentumScore > 0 ? 1 : 0) + (buyVolatilityScore > 0 ? 1 : 0) + (buyVolumeScore > 0 ? 1 : 0) + (buyDivergenceScore > 0 ? 1 : 0)

// --- 12. STATISTICAL SCORING ENGINE (Sigma-Based) ---
// Replaces heuristic points with Standard Deviations (Sigma) to normalize scores.
zVolume = calcZScore(volume, 20) // Demand Urgency
// CONSOLIDATION FIX: Don't penalize low volume if we are in a healthy uptrend.
// Quiet pullbacks are bullish.
isConsolidation = volume < volAvg20 and uptrend
isBreakoutVolumeExec = (not na(keyResistance) and close > keyResistance) or isNewHigh3M

if (zVolume < 0 and isConsolidation) or (zVolume < 0 and isBreakoutVolumeExec)
    zVolume := 0 // Neutralize penalty

zRSI = calcZScore(rsi, 14) * -1 // Oversold Depth (Lower RSI = Higher Score)
zTrend = calcZScore(close - ma2, 50) // Deviation from Trend

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// NEW: EXHAUSTION FILTERS (Statistically Validated)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// A. VELOCITY Z-SCORE (Blow-Off Detection)
// ROC-10 normalized to 250-day distribution. |z| > 2.0 = statistical outlier.
float roc10 = ta.roc(close, 10)
float zVelocity = calcZScore(roc10, 250)
float velocityPenalty = math.abs(zVelocity) > 2.0 ? -1.0 : 0.0

// B. ELASTICITY Z-SCORE (Mean Reversion Curve)
// Distance from MA20 normalized. Gaussian decay: peak at z=0.5, penalty at z>2.0
float distFromMA20 = ma1 > 0 ? (close - ma1) / ma1 * 100 : 0
float zElasticity = calcZScore(distFromMA20, 250)
// Gaussian Decay: exp(-0.5 * (|z| - 0.5)^2) - 0.5 => Peak at z=0.5, decay at extremes
float elasticityScore = math.exp(-0.5 * math.pow(math.abs(zElasticity) - 0.5, 2)) - 0.5
elasticityScore := math.max(-1.0, math.min(1.0, elasticityScore))

// C. TREND DURATION PENALTY (Time Decay)
// Penalize stale trends (>20 bars above/below MA without pullback)
int trendBarsUp = nz(ta.barssince(close < ma1), 0)
int trendBarsDown = nz(ta.barssince(close > ma1), 0)
float trendDurationPenalty = (uptrend and trendBarsUp > 20) or (downtrend and trendBarsDown > 20) ? -0.5 : 0.0

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// MOMENTUM BALANCE (The "Middle Ground Exception")
// Normally, High RSI = Penalty (zRSI < 0). 
// But if we are in a Breakout or Strong Trend, High RSI is GOOD.
// logic: If zRSI is negative BUT we have strong momentum -> Remove penalty.
isMomentumMove = strongTrend or impulseGreen or darvasBreakoutStrong or goldenCross

// GLOBAL RSI CASCADE CALCULATION (Using Consolidated Data)
rsiIntraday = request.security(syminfo.tickerid, cascadeTimeframe, ta.rsi(close, 14), barmerge.gaps_off, barmerge.lookahead_off)

// Bearish Cascade (Top)
isRsiCascade = checkRsiCascade(rsi, rsiWeekly, rsiIntraday, enableRsiCascade, 70)

// Bullish Cascade (Bottom) - NEW
// Logic: Weekly < 40 + Intraday < 30 (Oversold alignment)
isRsiBullCascade = rsiWeekly < 40 and rsiIntraday < 30 and rsi < 30

if zRSI < 0 and isMomentumMove
    // Flip negative score to small positive (Momentum Bonus)
    // Means: "It's Overbought, BUT it's a Rocket üöÄ"
    zRSI := 0.5 

// Calculate Total Sigma
// Base Sigma from Market Data + Exhaustion Filters
totalSigma = zVolume + zRSI + zTrend + velocityPenalty + elasticityScore + trendDurationPenalty

// 12.1. MARKET CLIMATE BIAS (Institutional Tide Alignment)
// Penalize Longs in Bear Market (-1.0) / Boost in Bull Market (+1.0)
// This aligns the strategy with the Institutional Tide
totalSigma := totalSigma + marketClimateScore


// Add Structural Bonuses (Fixed Sigma Weights)
// Zone Confidence: +2.0 Sigma (95% Probability Event)
if buyCategories > 0
    totalSigma := totalSigma + 2.0

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 52-WEEK PROXIMITY PENALTY (Anti-FOMO) - REFINED
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
distTo52WHigh = (nz(weekHigh52) - close) / math.max(1, close) * 100
isNear52WHigh = not na(distTo52WHigh) and distTo52WHigh < 2.5 and distTo52WHigh >= -0.5 // Within 2.5% or 0.5% breakout

// Confluence Parameters
// Enhanced Power Breakout: High volume, institutional participation
// REDEFINED: Broadened to include Multi-Month pivot breakouts and Rocket Momentum
isRocketMomentum = strongTrend and isMomentumMove and hasRelStrength and close > maSprint

// FIX: Calculate crossover OUTSIDE conditional to ensure consistency
bool xoPivotHigh = ta.crossover(close, pivotHighPrice)
isPivotBreakoutL = not na(pivotHighPrice) and xoPivotHigh

// SIMPLIFIED: Use volAvg20 (global) instead of undefined volSMA20ForFOMO
// FVG/Momentum helpers removed (undefined) - replaced with volume check alone
isPowerBreakout = ((close > weekHigh52[1]) or isPivotBreakoutL or isRocketMomentum) and (volume > volAvg20 * 1.3)

// Power Breakdown: High volume OR FVG resistance OR momentum confirmation (Short side)
// FIX: Calculate crossunder OUTSIDE conditional
bool xuPivotLow = ta.crossunder(close, pivotLowPrice)
isPivotBreakoutS = not na(pivotLowPrice) and xuPivotLow
isPowerBreakdown = ((close < weekLow52[1]) or isPivotBreakoutS) and (volume > volAvg20 * 1.3)

if isNear52WHigh or isRocketMomentum
    if isPowerBreakout
        totalSigma := totalSigma + 1.2 // Increased reward for Institutional Power Move
    else if not isRocketMomentum // ONLY penalize if NOT a rocket
        totalSigma := totalSigma - 1.5 // Retail FOMO Risk (Penalize)
        // isExhaustedTop: Top warning combined with weakening momentum
        // USING RAW INDICATORS to avoid circular dependency (isTopping depends on final score)
        bool isExhaustedTop = (rsi > 70 or close > bbUpper) and (rsi > 70 or histLine < histLine[1])
        if isExhaustedTop
            totalSigma := totalSigma - 1.0 // Blowoff Top Risk (Extra Penalty)

// Convert Sigma to "Score" (0-100) for backward compatibility with Dashboard
// 3.0 Sigma = 100 Score. 0 Sigma = 50 Score.
// CALCULATION MOVED TO LINE 2675 TO CAPTURE BONUSES



// Category Count (for confluence check)
// (buyCategories definition moved upstream)

// PREDICTIVE BONUS: Liquidity Sweep
// If we have a sweep, it's a massive confidence booster (+3 pts)
// PREDICTIVE BONUS & CONFLUENCE
// Combined block for token efficiency
totalSigma += (bullishSweep ? 1.0 : 0) + 
              (not na(longZoneLow) and close >= longZoneLow and close <= longZoneHigh ? 1.5 : 0) +
              (not na(maSprint) and not na(maHull) and maSprint > maHull and low <= maSprint and close >= maHull and close > open ? 0.5 : 0) +
              (bullFlag ? 1.0 : 0) +
              (isRsiBullCascade ? 1.5 : 0) +
              (stochOS and kCrossD ? 0.5 : 0) +
              (cciOS or williamsOS or mfiOS ? 0.5 : 0) +
              (macdBullish ? 0.5 : 0) +
              (obvBullish ? 0.2 : 0) +
              (isBullishScoreDivergence or bullishRSIDivergence or bullishMACDDivergence ? 1.5 : 0) +
              (bullishFVG ? 0.5 : 0)

buyCategories += (bullishSweep ? 1 : 0) + 
                 (not na(longZoneLow) and close >= longZoneLow and close <= longZoneHigh ? 1 : 0) +
                 (not na(maSprint) and not na(maHull) and maSprint > maHull and low <= maSprint and close >= maHull and close > open ? 1 : 0) +
                 (bullFlag ? 1 : 0) +
                 (isRsiBullCascade ? 1 : 0) +
                 (stochOS and kCrossD ? 1 : 0) +
                 (cciOS or williamsOS or mfiOS ? 1 : 0) +
                 (macdBullish ? 1 : 0) +
                 (obvBullish ? 1 : 0) +
                 (isBullishScoreDivergence or bullishRSIDivergence or bullishMACDDivergence ? 1 : 0) +
                 (bullishFVG ? 1 : 0) +
                 (failedBearishSweep ? 2 : 0) // Trapped Bears



// ==========================================
// PENALTIES: CRUSH COUNTER-TREND SIGNALS
// ==========================================
// "Don't catch a falling knife" (Bearish Penalties)

// SHARP SELLOFF PENALTY (7-Day Momentum Collapse)
// If price dropped >5% in 7 days, this is distribution, not a dip to buy
float recentDrop = (close - close[7]) / close[7] * 100
if recentDrop < -5.0
    totalSigma := totalSigma - 2.5 // Massive penalty for falling knife

// STAGE 3 TOPPING PENALTY
if weinsteinStage == 3 // Topping/Distribution Phase
    totalSigma := totalSigma - 2.0

if deathCross // 50 EMA < 200 EMA
    totalSigma := totalSigma - 2.0
if weinsteinStage == 4 // Stage 4 Decline
    totalSigma := totalSigma - 2.0
if failedBullishSweep
    totalSigma := totalSigma - 3.0 // Massive penalty for trapped buyers
if impulseRedStreak // 3+ Red Bars (Strong Momentum)
    totalSigma := totalSigma - 1.5
else if impulseRed // Single Red Bar
    totalSigma := totalSigma - 0.5
if downtrend // General Downtrend
    totalSigma := totalSigma - 0.5


if isBearishScoreDivergence // Bulls are Exhausted (Score Divergence - Symmetry)
    totalSigma := totalSigma - 1.5

// RESISTANCE REJECTION PENALTY (Supply/Demand Conflict)
// If sellers are actively rejecting at resistance, penalize LONG score
if resReject
    totalSigma := totalSigma - 1.5

// 3. SMART LOGIC: TRAP DETECTION (Sigma Boost)
// Logic: Price pierced Key Support but closed back inside on low volume.
if bearTrap
    totalSigma += 1.25 // +1.25 Sigma (~20 Score Points)
if bullishHikkake
    totalSigma += 1.5 // Hikkake: Failed Inside Bar Breakout (High Probability Reversal)
if bullishPinBar and (close < keySupport * 1.05 or inLongZone)
    totalSigma += 1.0 // Pin Bar at support = confirmed rejection
if bullishEngulfingStrict and (close < keySupport * 1.05 or inLongZone)
    totalSigma += 1.25 // Engulfing at support = momentum shift
if isSupportWeakened
    totalSigma -= 1.5 // FATIGUE PENALTY: Support is failing to hold after multiple tests.

// FINAL SIGMA TO SCORE CONVERSION
// 3.0 Sigma = 80 Score (Prime). 5.0 Sigma = 100 Score.
// User Request: "Score = 50 + (totalSigma * 10)" - Conservative Statistical Grading.
buyScore = math.min(100, math.max(0, 50 + (totalSigma * 10)))

// BLUE SKY BOOST: MOVED TO FINALIZATION BLOCK (Line 3971)

// (Duplicate definitions removed)

// Category 3: VOLATILITY/RESISTANCE
sellVolatility1 = close < bbUpper and close[1] >= bbUpper[1] // BB rejection
sellVolatility2 = close < psar and close[1] >= psar[1] and strongTrend // PSAR cross down
sellVolatility3 = close < fib382 and close[1] >= fib382 // Fib rejection
sellVolatility4 = close < psar and downtrend and strongTrend // PSAR confirms downtrend (continuation)
sellVolatility5 = strongTrend and downtrend and adx > 30 // ADX confirms strong downtrend
sellVolatility6 = darvasBreakdown or belowDarvasBox and darvasBoxValid // Darvas: Breakdown or below box
sellVolatilityScore = (sellVolatility1 ? 1 : 0) + (sellVolatility2 ? 1 : 0) + (sellVolatility3 ? 1 : 0) + (sellVolatility4 ? 1 : 0) + (sellVolatility5 ? 1 : 0) + (sellVolatility6 ? darvasBreakdown ? 2 : 1 : 0)

// Category 4: VOLUME
sellVolume1 = volumeConfirmsBear and obvBearish // OBV bearish
sellVolume2 = volume > volMA * 1.5 and close < open // High volume red bar
sellVolume3 = obvBearish and downtrend // OBV confirming downtrend (continuation)
sellVolume4 = adLineBearish and downtrend // Chaikin A/D Line - institutional distribution
sellVolumeScore = (sellVolume1 ? 1 : 0) + (sellVolume2 ? 1 : 0) + (sellVolume3 ? 1 : 0) + (sellVolume4 ? 1 : 0)

// Category 5: DIVERGENCE (High Value)
// Total Sell Score
sellCategories = (sellTrendScore > 0 ? 1 : 0) + (sellMomentumScore > 0 ? 1 : 0) + (sellVolatilityScore > 0 ? 1 : 0) + (sellVolumeScore > 0 ? 1 : 0) + (sellDivergenceScore > 0 ? 1 : 0)

// --- 13. SHORT SIDE STATISTICAL SCORING ---

// 3B. BEARISH SCORE DIVERGENCE - MOVED TO LINE 3584
// (Was here, moved earlier to resolve undeclared identifier error)

// Final Sell Sigma
sellTotalSigma = 0.0

// MARKET CLIMATE FILTER (Institutional Symmetry)
// Bonus to Shorts in Bear Market (+1.0), Penalty in Bull Market (-1.0)
sellTotalSigma := sellTotalSigma - marketClimateScore


// Parabolic Filter (Phase 9 - Relaxed)
// Goal: Don't sell early on a "Rocket" just because it's technically overbought.
// Definition: High Momentum + Breakout conditions
// Note: We use raw ADX > 18 (Trend Start) and Price > 50 EMA (Trend Filter)
isParabolicRun = adx > 18 and close > ma2 and rsi > 60

// What to Ignore?
// Ignore "Reversion" signals (RSI, Stoch, Extensions) IF Parabolic OR Breakout Active.
// We still respect Reversal Patterns (Shooting Star, Engulfing) because they signal the END of the run.
hasReversalPattern = isShootingStar or bearishEngulfing or bearishSweep

// FIX ISS-1: Logic Scope - Use 'close > shortZoneHigh' instead of dashboard status
// Use keyResistance or shortZoneHigh to detect breakout context
isBreakoutActive = (not na(shortZoneHigh) and close > shortZoneHigh) or (not na(keyResistance) and close > keyResistance) or darvasBreakoutStrong

shouldIgnoreReversion = (isParabolicRun or allTimeframesAlignedBullish or isBreakoutActive) and not hasReversalPattern

// 1. REVERSION SIGNALS (High Weight - Catching Tops)
// Filter applied: Only count if NOT ignoring reversion
if isRsiCascade and not shouldIgnoreReversion // Added: Cascade = Massive Top Signal (+2.0)
    sellTotalSigma := sellTotalSigma + 2.0
if connorsSellSignal and not shouldIgnoreReversion     // RSI(2) > 90
    sellTotalSigma := sellTotalSigma + 2.0
if rsiOB and rsi < rsi[1] and not shouldIgnoreReversion // RSI > 65 Hook
    sellTotalSigma := sellTotalSigma + 1.5
if stochOB and kCrossDDown and not shouldIgnoreReversion // Stoch OB
    sellTotalSigma := sellTotalSigma + 1.0
if cciOB and not shouldIgnoreReversion
    sellTotalSigma := sellTotalSigma + 0.5
if williamsOB and not shouldIgnoreReversion
    sellTotalSigma := sellTotalSigma + 0.5
if mfiOB and not shouldIgnoreReversion
    sellTotalSigma := sellTotalSigma + 0.5

// 2. TREND SIGNALS
if downtrend
    sellTotalSigma := sellTotalSigma + 0.5 // Reduced from 1.0
if macdBearish
    sellTotalSigma := sellTotalSigma + 0.5 // Reduced from 1.0
if impulseRedStreak // Elder: 3+ Red Bars
    sellTotalSigma := sellTotalSigma + 1.5
else if impulseRed // Single Red Bar
    sellTotalSigma := sellTotalSigma + 0.5

// 3. SMART LOGIC: TRAP DETECTION (Sigma Boost)
if bullTrap
    sellTotalSigma += 1.25 // +1.25 Sigma (~20 Score Points)
if bearishHikkake
    sellTotalSigma += 1.5 // Hikkake: Failed Inside Bar Breakout (High Probability Reversal)
if isResistanceWeakened
    sellTotalSigma -= 1.5 // FATIGUE PENALTY: Resistance is failing to hold after multiple tests.
if weinsteinStage == 4 // Declining Phase (MAJOR)
    sellTotalSigma := sellTotalSigma + 1.5 // Reduced from 2.0
if elderSellSignal or elderStrongSell
    sellTotalSigma := sellTotalSigma + 1.0 // Reduced from 1.5
if allTimeframesAlignedBearish
    sellTotalSigma := sellTotalSigma + 1.5 // Reduced from 2.0
else if majorTimeframesAlignedBearish
    sellTotalSigma := sellTotalSigma + 0.5 // Reduced from 1.0

// 3. PATTERN/INSTITUTIONAL
if bearishSweep
    sellTotalSigma := sellTotalSigma + 1.0
if bearishFVG
    sellTotalSigma := sellTotalSigma + 0.5
if isShootingStar // Candlestick Pattern
    sellTotalSigma := sellTotalSigma + 1.0
if darvasBreakdown
    sellTotalSigma := sellTotalSigma + 1.0 // Reduced from 1.5
if bearFlag

    sellTotalSigma := sellTotalSigma + 1.0 // Reduced from 1.5

// 4. DIVERGENCE (High Probability Tops)
if bearishRSIDivergence or bearishMACDDivergence
    sellTotalSigma := sellTotalSigma + 2.0

// 5. ZONE CONFLUENCE (Short Entry Zone)
if not na(shortZoneLow) and close >= shortZoneLow and close <= shortZoneHigh
    sellTotalSigma := sellTotalSigma + 1.5 // Reduced from 2.0

// 6. EXTREME EXTENSION (Price at Extremes - High Probability Reversal)
// Filter applied: Only count if NOT ignoring reversion
if close > bbUpper and not shouldIgnoreReversion  // Above Bollinger Upper Band
    sellTotalSigma := sellTotalSigma + 1.5
// Keltner Channel Extreme: Price > 3 ATR above EMA
keltnerUpper = ta.ema(close, 20) + 3 * ta.atr(10)
if close > keltnerUpper and not shouldIgnoreReversion
    sellTotalSigma := sellTotalSigma + 2.0

// Bearish Score Divergence (Bulls Exhausted)
if isBearishScoreDivergence
    sellTotalSigma := sellTotalSigma + 1.5

// FAILED BULLISH SWEEP: Trapped Bulls (High Confidence Sell)
if failedBullishSweep
    sellTotalSigma := sellTotalSigma + 2.5 // Heavy reward for a dump signal

// PIN BAR & ENGULFING AT RESISTANCE (Confirmed Rejection)
if bearishPinBar and (close > keyResistance * 0.95 or inShortZone)
    sellTotalSigma := sellTotalSigma + 1.0 // Pin Bar at resistance = confirmed rejection
if bearishEngulfingStrict and (close > keyResistance * 0.95 or inShortZone)
    sellTotalSigma := sellTotalSigma + 1.25 // Engulfing at resistance = momentum shift
if bearishHikkake
    sellTotalSigma := sellTotalSigma + 1.5 // Hikkake: Failed Inside Bar Breakout

// 7. RED CLOUD REJECTION (Price rejected by Red Cloud)
if not na(maSprint) and not na(maHull) and maSprint < maHull and high >= maSprint and close <= maHull and close < open
    sellTotalSigma := sellTotalSigma + 0.5 // Reduced from 1.0

// ==========================================
// PENALTIES: CRUSH COUNTER-TREND SIGNALS
// ==========================================
// "Don't short a rocket" (Bullish Penalties)
// FIX ISS-5: SYMMETRIC PENALTIES (Increased to -2.0)
if goldenCross // 50 EMA > 200 EMA
    sellTotalSigma := sellTotalSigma - 2.0
if weinsteinStage == 2 // Stage 2 Markup
    sellTotalSigma := sellTotalSigma - 2.0
if impulseGreenStreak // 3+ Green Bars (Strong Momentum)
    sellTotalSigma := sellTotalSigma - 1.5
else if impulseGreen // Single Green Bar
    sellTotalSigma := sellTotalSigma - 0.5
if uptrend // General Uptrend - FIX: Was -0.5, increased to -2.0
    sellTotalSigma := sellTotalSigma - 2.0


if isBullishScoreDivergence // Bears are Exhausted (Score Divergence)
    sellTotalSigma := sellTotalSigma - 1.5

// SUPPORT BOUNCE PENALTY (Supply/Demand Conflict - Symmetry)
// If buyers are actively bouncing at support, penalize SHORT score
if supBounce
    sellTotalSigma := sellTotalSigma - 1.5

// FINAL SIGMA TO SCORE CONVERSION (Same formula as buyScore)
// 3.0 Sigma = 80 Score (Prime). 5.0 Sigma = 100 Score.
// User Request: "Score = 50 + (totalSigma * 10)"
sellTotalSigma := sellTotalSigma + velocityPenalty + elasticityScore + trendDurationPenalty
sellScore = math.min(100, math.max(0, 50 + (sellTotalSigma * 10)))

// GREEN SHIELD: MOVED TO FINALIZATION BLOCK (Line 3976)
// This prevents "shorting the rocket" while catching pullbacks when momentum fades.
// (Original logic removed to avoid double application)

// --- 14. TOP DETECTION & OVEREXTENSION WARNINGS ---

// 1. OVEREXTENDED CONDITIONS (Price too far from mean)
// Uses modular function: checkOverextended
[isOverextended, isSeverelyOverextended] = checkOverextended(close, ma1, ma3, rsi, bbUpper, rsiTopThreshold, rsiExtremeThreshold)

// Visual Fix moved below RSI Cascade calculation to catch ALL signals

// 2. RSI CASCADE (Moved Up to 2890)
// Warning: Definition removed from here to allow Scoring Usage

// RAW SAFETY SIGNALS (For Opacity Engine - Unlinked from Rocket Suppression)
isOverextendedRaw = isOverextended
isSeverelyOverextendedRaw = isSeverelyOverextended
isRsiCascadeRaw = isRsiCascade

// Visual Fix (Final): Suppress ALL Reversion signals (Extensions + Cascade) on Rockets
if shouldIgnoreReversion
    isOverextended := false
    isSeverelyOverextended := false
    isRsiCascade := false

// 3. SCORE DIVERGENCE (Internal Weakness)
// Code moved up to Line 2922 to avoid circular dependency.
// Uses 'buyMomentumScore' instead of 'buyScore'.
highestRecentBuyScore = ta.highest(buyScore, 20) // Kept for visual display
highestRecentPrice = ta.highest(close, 20) // Kept for reference
// isScoreDivergence is now calculated at Line 2922 using Momentum Score

// 3B. BEARISH SCORE DIVERGENCE (Bottom Detection)
// Logic: Price is near lows, but Sell Score has dropped (Selling pressure exhausting)
// 3B. BEARISH SCORE DIVERGENCE (Code moved up to Line 3044 to avoid circular dependency)
// This space intentionally left blank to maintain line history or can be removed.

// 4. RSI FAILURE SWING (The "M" Pattern)
// Uses modular function: checkRsiFailureSwing
isRsiFailureSwing = checkRsiFailureSwing(rsi, bearishRSIDivergence)

// COMBINED TOPPING SIGNAL
// Topping if: Weinstein Stage 3 OR Cascade OR Score Divergence OR Failure Swing
// Note: weinsteinTopping is defined here locally if not already defined
weinsteinTopping = weinsteinStage == 3
// Bearish Divergence (already calculated)
hasBearishDivergence = bearishRSIDivergence or bearishMACDDivergence


// Chart Patterns (already calculated) - MASTER DEFINITION for Topping & Signals

// UPDATE: Added CONFIRMATION checks (breakouts) to match visual labels.
// This prevents "Ghost Signals" where logic sees a pattern setup but user sees no confirmed label.

hasBullishPattern = (bullFlag and close > highest5[1]) or bullishSweep
hasBearishPattern = (bearFlag and close < lowest5[1]) or bearishSweep


// Gradient Harmony: Determines dashboard topping states while suppressing chart noise.
isToppingFull = weinsteinTopping or isRsiCascade or isBullishScoreDivergence or isRsiFailureSwing or (isOverextended and (hasBearishDivergence or hasBearishPattern))
isTopping = isToppingFull and not isPowerBreakout

// RAW TOPPING (For Visual Opacity)
isToppingRaw = isToppingFull and not isPowerBreakout

// 5. COMBINED BOTTOMING SIGNAL (Risk for Shorts)
isUnderExtended = checkOverextendedDown(close, ma1, ma3, rsi, bbLower)
isBottomingFull = weinsteinStage == 1 or isRsiBullCascade or isBearishScoreDivergence or (isUnderExtended and (bullishRSIDivergence or hasBullishPattern))
isBottoming = isBottomingFull and not isPowerBreakdown

// RAW BOTTOMING (For Visual Opacity)
isBottomingRaw = isBottomingFull and not isPowerBreakdown

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MEAN REVERSION SCORE (Function-Based Calculation)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Uses calcReversionScore() for token efficiency

// Pre-calculate shared inputs
int consecutiveDownDays = nz(ta.barssince(close > open), 0)
int consecutiveUpDays = nz(ta.barssince(close < open), 0)
bool nearKeySupportRev = not na(keySupport) and close < keySupport * 1.02
bool nearKeyResistanceRev = not na(keyResistance) and close > keyResistance * 0.98
bool bullishEngulfingRev = close > open and open < close[1] and close > open[1]
bool bearishEngulfingRev = close < open and open > close[1] and close < open[1]
bool near52WLow = not na(weekLow52) and close < weekLow52 * 1.05
bool near52WHigh = not na(weekHigh52) and close > weekHigh52 * 0.95
float volRatioRev = volume / math.max(1, volAvg20)
bool obvDivLong = obvBullish and close < close[1]
bool obvDivShort = obvBearish and close > close[1]
bool aboveSMA200 = close > globalSma200

// LONG REVERSAL SCORE
float revScoreLong = calcReversionScore(true, rsi2, rsi, zElasticity, zVolume, volRatioRev, isRsiBullCascade, bullishRSIDivergence, stochOS and kCrossD, macdBullish, obvDivLong, isHammer, bullishEngulfingRev, near52WLow, nearKeySupportRev, close < bbLower, williamsOS, mfiOS, cciOS, consecutiveDownDays, aboveSMA200)

// SHORT REVERSAL SCORE
float revScoreShort = calcReversionScore(false, rsi2, rsi, zElasticity, zVolume, volRatioRev, isRsiCascade, bearishRSIDivergence, stochOB and kCrossDDown, macdBearish, obvDivShort, isShootingStar, bearishEngulfingRev, near52WHigh, nearKeyResistanceRev, close > bbUpper, williamsOB, mfiOB, cciOB, consecutiveUpDays, aboveSMA200)

// HIKKAKE BONUS (Structural Trap Reversal - High Weight)
// Hikkake is a failed inside bar breakout - strong reversal signal
if bullishHikkake
    revScoreLong := revScoreLong + 2.5
if bearishHikkake
    revScoreShort := revScoreShort + 2.5

// Threshold for "SETUP" status
bool isRevSetupLong = revScoreLong >= 4.0
bool isRevSetupShort = revScoreShort >= 4.0

// Zone 0 indicators (Extreme reversal - score 10+)
bool isRevZone0Long = revScoreLong >= 10.0
bool isRevZone0Short = revScoreShort >= 10.0

// Plot üéØ icons for Zone 0 (extreme reversal setups)
plotshape(isRevZone0Long and barstate.isconfirmed, title='Zone 0 Long', style=shape.labelup, location=location.belowbar, color=color.new(color.lime, 20), text='üéØ', textcolor=color.white, size=size.tiny)
plotshape(isRevZone0Short and barstate.isconfirmed, title='Zone 0 Short', style=shape.labeldown, location=location.abovebar, color=color.new(color.red, 20), text='üéØ', textcolor=color.white, size=size.tiny)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Visual Alerts via Helper Function
highestRecentSellScore = ta.highest(sellScore, 20) // Calculated for display
drawTopWarnings(isSeverelyOverextended, isBullishScoreDivergence, isBullishScoreDivergence[1], highestRecentBuyScore, buyScore, isBearishScoreDivergence, isBearishScoreDivergence[1], highestRecentSellScore, sellScore, isRsiCascade, isRsiCascade[1], rsiWeekly, rsi, rsiIntraday, isTopping, isTopping[1], isPowerBreakout)



// PART 9: INSTITUTIONAL TOOLS (AVWAP, Gaps, MSS)
// Advanced features for Stock Trading

// AVWAP Calculation MOVED to Line 2530 to allow usage in Entry Zone logic
// avwapHigh and avwapLow are already defined above

// Plot AVWAP
plot(enableAvwap ? avwapHigh : na, 'AVWAP Resistance', color.new(color.red, 30), 1, display = display.all)
plot(enableAvwap ? avwapLow : na, 'AVWAP Support', color.new(color.green, 30), 1, display = display.all)

// AVWAP Anchor Labels
plAnchor = ta.pivotlow(low, 5, 5) // Calculate globally to ensure consistency



// Draw Visuals via Helper Function (Reduces Main Body Size)
drawInstitutionalVisuals(globalDayChanged, enableAvwap, isNewHigh3M, isNewLow3M, plAnchor, downtrend, uptrend, enableGapZones, isGapUpInst, isGapDownInst, bullishSweep, bearishSweep, enableGapZones, bullishFVG, bearishFVG)

// PART 7B: SCORE FINALIZATION & UNIFICATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Optimization: Pass RS and Acceleration to final scoring
[finalBScore, finalSScore] = finalizeConsolidatedScores(buyScore, sellScore, bullishSweep, bullishFVG, bearishSweep, bearishFVG, isNewHigh3M, weinsteinStage, impulseGreen, hasRelStrength, isAccelerating)
buyScore := finalBScore
sellScore := finalSScore

// Threshold Adjustment (Simplified for Score System)
thresholdAdjusted = scoreThreshold
// Legacy multipliers removed as Z-Score is inherently normalized

// MURPHY'S CONFLUENCE RULE: Signals must come from at least 3 different categories
confluenceMetBuy = buyCategories >= 3

// DE PRADO'S MTF VALIDATION: Higher timeframes MUST confirm
// CRITICAL: Daily signals require WEEKLY confirmation (minimum)
// STRICT MODE: Requires ALL timeframes (Monthly + Weekly + Daily) to align
// This prevents buying on daily when weekly/monthly are bearish
validMtfBuy = useMtfConfirmation ? (isDaily ? mtfTrendWeekly == 1 : isWeekly ? mtfTrendMonthly == 1 : true) : true
validMtfSell = useMtfConfirmation ? (isDaily ? mtfTrendWeekly == -1 : isWeekly ? mtfTrendMonthly == -1 : true) : true

if strictMtfMode
    // In strict mode, ALL higher timeframes must align
    if isDaily
        validMtfBuy := mtfTrendWeekly == 1 and mtfTrendMonthly == 1
        validMtfSell := mtfTrendWeekly == -1 and mtfTrendMonthly == -1

// -------------------------------------------------------------------------
// PART 8: SIGNAL GENERATION (The "Engine")
// -------------------------------------------------------------------------

// --- REVERSION LOGIC (Buying dips in uptrends / Selling tops in downtrends) ---
// Enhanced with Institutional Tools + Chart Patterns
distToLow20   = math.abs(close - ta.lowest(low, 20)) / close
distToVWMA    = math.abs(close - vwma200) / close
distToAVWAP   = enableAvwap and not na(avwapLow) ? math.abs(close - avwapLow) / close : 999
nearSupport   = distToLow20 < 0.02 or distToVWMA < 0.02 or distToAVWAP < 0.02 // Price is near structural support

distToHigh20  = math.abs(close - ta.highest(high, 20)) / close
distToVWMAH   = math.abs(close - vwma200) / close // Same VWMA, just checking distance
distToAVWAPH  = enableAvwap and not na(plAnchor) ? math.abs(close - high[ta.barssince(high == plAnchor)]) / close : 999 
nearResistance = distToHigh20 < 0.02 or distToVWMAH < 0.02 or distToAVWAPH < 0.02


// REVERSION BUY: Identify Source
string buySignalSource = ""
if isHammer and nearSupport and not failedBullishSweep
    buySignalSource := "Hammer at Support"
else if darvasBreakout
    buySignalSource := "Darvas Breakout"

else if bullishSweep and not failedBullishSweep
    buySignalSource := "Liquidity Sweep"
else if bullFlag and close > highest5[1]
    buySignalSource := "Bull Flag"
else if hasBullishPattern
    buySignalSource := "Bull Pattern"

isReversionBuy = buySignalSource != ""

// Logic: Distinguish between Structural Reversion (Dip Buy) and Momentum Patterns
// Structural Reversions should stick to the Support level (Static).
// Momentum Patterns (Flags, Darvas) should use Market Entry (Dynamic).
isStructuralReversion = ((isHammer and nearSupport) or bullishSweep or (nearSupport and not (darvasBreakout or bullFlag or hasBullishPattern))) and not failedBullishSweep

// REVERSION SELL: Identify Source
string sellSignalSource = ""
if isShootingStar and nearResistance
    sellSignalSource := "Shooting Star at Resistance"
else if darvasBreakdown
    sellSignalSource := "Darvas Breakdown"

else if bearishSweep
    sellSignalSource := "Liquidity Sweep"
else if bearFlag and close < lowest5[1]
    sellSignalSource := "Bear Flag"
else if hasBearishPattern
    sellSignalSource := "Bear Pattern"



isReversionSell = sellSignalSource != ""

// Logic: Distinguish between Structural Reversion (Dip Sell) and Momentum Patterns
// Structural Reversions should stick to the Resistance level (Static).
// Momentum Patterns (Flags, Darvas) should use Market Entry (Dynamic).
isStructuralReversionSell = (isShootingStar and nearResistance) or bearishSweep or (nearResistance and not (darvasBreakdown or bearFlag or hasBearishPattern))

// TREND-AWARE ENTRY LOGIC (Technical Entry Synchronization)
// Breakouts (Trend) -> Enter at MARKET (Close) with Tight Stop
// Reversions (Dip) -> Enter at LIMIT (Support) with Structural Stop

// LONG OVERRIDE
// TREND ENTRY: Requires Signal AND (Volume Conviction OR Extreme Score)
// Dynamic Entry: StructuralReversion enables breakout-style momentum entries
// Low-Volatility Guard: Suppress signals in choppy markets due to fakeout risk
// Low-Volatility Guard: Suppress signals in choppy markets UNLESS conviction is extreme (Breakout)
if not isStructuralReversion and (not isChoppyMarket or buyScore >= 90) and buyScore >= thresholdAdjusted and (zVolume > 1.0 or buyScore >= 90)
    // TREND MODE: Breakout triggered! Don't wait for support.
    suggestedEntryLong := close
    
    // Tighter Stop for Momentum (ATR Trailing) vs Deep Structure
    // Logic: Pick the LOWER stop for longs (further from price = safer, but capped to prevent excessive risk)
    float breakoutStopLong = math.max(low - atr, close - (atr * 2))
    // Use the existing structural stop if it's lower (safer), otherwise use breakout stop
    suggestedStopLossLong := na(suggestedStopLossLong) ? breakoutStopLong : math.min(suggestedStopLossLong, breakoutStopLong)
    
    // Recalculate Target based on new risk
    float newRiskLong = math.abs(suggestedEntryLong - suggestedStopLossLong)
    suggestedTakeProfitLong := suggestedEntryLong + (newRiskLong * riskRewardTF)
    
    // Zone remains at structural support while entry is derived dynamically
    // VISUAL SYNC FIX: Center zone on dynamic entry for trend-mode
    // SNIPER REFINEMENT: Use volatility-scaled width formula
    float atrFloorL = atr * 0.5, float atrCeilingL = atr * 0.8, float pctCeilingL = close * 0.01
    float zoneExpansion = math.max(atrFloorL, math.min(pctCeilingL, atrCeilingL)) / 2
    longZoneHigh := suggestedEntryLong + zoneExpansion
    longZoneLow := suggestedEntryLong - zoneExpansion

// SHORT OVERRIDE
// TREND ENTRY: Requires Signal AND (Volume Conviction OR Extreme Score)
// Low-Volatility Guard: Suppress signals in choppy markets
// Low-Volatility Guard: Suppress signals in choppy markets UNLESS conviction is extreme (Breakout)
if not isStructuralReversionSell and (not isChoppyMarket or sellScore >= 90) and sellScore >= thresholdAdjusted and (zVolume > 1.0 or sellScore >= 90)
    // TREND MODE: Breakdown triggered! Don't wait for resistance.
    suggestedEntryShort := close
    
    // Tighter Stop for Momentum
    // Logic: Pick the HIGHER stop for shorts (above entry = correct direction)
    float breakoutStopShort = math.min(high + atr, close + (atr * 2))
    // Use the existing structural stop if it's higher (correct), otherwise use breakout stop
    suggestedStopLossShort := na(suggestedStopLossShort) ? breakoutStopShort : math.max(suggestedStopLossShort, breakoutStopShort)
    
    // Recalculate Target
    float newRiskShort = math.abs(suggestedStopLossShort - suggestedEntryShort)
    suggestedTakeProfitShort := suggestedEntryShort - (newRiskShort * riskRewardTF)
    
    // NOTE: Zone stays at Structural Resistance (stable). Entry is dynamic.
    // VISUAL SYNC FIX: Center zone on dynamic entry for trend-mode
    // SNIPER REFINEMENT: Use volatility-scaled width formula
    float atrFloorS = atr * 0.5, float atrCeilingS = atr * 0.8, float pctCeilingS = close * 0.01
    float zoneExpansionShort = math.max(atrFloorS, math.min(pctCeilingS, atrCeilingS)) / 2
    shortZoneHigh := suggestedEntryShort + zoneExpansionShort
    shortZoneLow := suggestedEntryShort - zoneExpansionShort

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ADX QUALITY SCALAR (Trend Trades Only)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Penalize scores in choppy markets. Reversion trades are EXEMPT.
// This prevents "STRONG LONG/SHORT" labels when ADX shows no trend.
adxMultiplier = adx < 15 ? 0.80 : adx < 20 ? 0.90 : 1.0

// Long-side: Exempt if near support or sweep (isStructuralReversion already includes these)
if not isStructuralReversion and not nearSupport
    buyScore := buyScore * adxMultiplier

// Short-side: Exempt if near resistance or bearish sweep
if not isStructuralReversionSell
    sellScore := sellScore * adxMultiplier

// --- 15. CAPITAL PROTECTION HIERARCHY ---
// Implements a multi-layered validation system based on Link, de Prado, and Murphy.
// Layer 1: Forensic Risk (Blocks dangerous environments)
// Layer 2: Technical Confluence (Ensures signal quality)
// Layer 3: Position Sizing & Safety (Clamps risk to predefined thresholds)

// LAYER 1: CAPITAL PROTECTION (Market Volatility Filtering)
// Technical filters block signals in dangerous environments
// This focuses on Murphy's technical analysis while showing fundamental context
capitalProtectionPassed = not isDangerous

// 15.1. MODULAR VALIDATION LAYER (Pre-Signal Check)

// LAYER 2: TECHNICAL VALIDATION (Only checked if capital protection passed)
// ENHANCED: Add Weinstein Stage and Elder Impulse requirements for higher win rate
weinsteinValidBuy = not requireWeinsteinStage or (weinsteinStage == 2)  // Stage 2 = Advancing
weinsteinValidSell = not requireWeinsteinStage or (weinsteinStage == 4) // Stage 4 = Declining

// 15.2. MARCEL LINK / ELDER IMPULSE FILTER
// Blocks counter-impulse trades (Longs blocked on Red, Shorts blocked on Green).
impulseValidBuy = not impulseRed      // Buy when NOT red (allows green/blue)
impulseValidSell = not impulseGreen   // Short when NOT green (allows red/blue)

// LAYER 3: MARKET CONDITION VALIDATION (No choppy/sideways markets)
// Use ADX to filter out low-trend environments
// FIX #6: Keep at 20 - balance between trend quality and opportunity
adxStrong = adx >= adxTrendThresh  // ADX >= threshold = decent trend

// 15.3. ADAPTIVE SHORT BIAS (Resistance-Based Counter-Trend)
// DUPLICATE BLOCK DELETED (distToLow20, isReversionBuy, etc.)

// MOVED: SELL CATEGORIES CONFLUENCE CHECK CHECK
// Must be defined AFTER hasBearishPattern (Line 3891)
sellCategories := (sellTrendScore > 0 ? 1 : 0) + (sellMomentumScore > 0 ? 1 : 0) + (sellVolatilityScore > 0 or (bearishSweep or bearishFVG or hasBearishPattern or isShootingStar) ? 1 : 0) + (sellVolumeScore > 0 ? 1 : 0) + (sellDivergenceScore > 0 or isBearishScoreDivergence ? 1 : 0)


// Threshold Adjustment (Re-check after move)
confluenceMetSell = sellCategories >= 3

// WICK REJECTION FILTERS (Prevent buying into resistance rejections / selling into support bounces)
// User Feedback: "Long tail on Friday" caused bad buy signal
hasUpperWickRejection = upperWick > bodySize // If upper wick is larger than body, sellers are active (Shooting Star / Doji)
hasLowerWickRejection = lowerWick > bodySize // If lower wick is larger than body, buyers are active (Hammer / Doji)

// GLOBAL VALIDATION - STRICT TECHNICAL ALIGNMENT
// 1. Trend Follow: Score + Confluence + Quality + Validation + GREEN CANDLE + GREEN CLOUD (Buy) / RED CANDLE + RED CLOUD (Sell)
//    - We enforce 'isFastUptrend' for Buys and 'isFastDowntrend' for Sells to ensure the LOCAL trend is aligned.
//    - This prevents buying "Trend" signals when the cloud is actually Red (just because we are above VWMA 200).
// 2. Reversion: Hammer/MSS + Score (Bypass Cloud)
// 3. GLOBAL FILTER: No Rejection Wicks (Must close strong)

// Map legacy variable aliases to current state definitions
mtfValidBuy = validMtfBuy
mtfValidSell = validMtfSell

// CHART PATTERN DIRECT LOGIC (No Points, just VALIDATION)
// Chart Patterns now defined globally at Part 7A for use in Topping & Signals


// FAST TRIGGER CONFIRMATION (Latency Mitigation)
// Pivot points lag by 5 bars. To catch the EXACT bottom/top, we use "Fast Triggers".
// Fast Trigger = 1-Bar Breakout or Engulfing Pattern *inside* the zone.
calcFastTrigger(isLong) =>
    if isLong
        // Bullish Engulfing Logic or 1-Bar High Breakout
        (close > open and close > high[1]) or (close > open and open < close[1] and close > open[1])
    else
        // Bearish Engulfing Logic or 1-Bar Low Breakdown
        (close < open and close < low[1]) or (close < open and open > close[1] and close < open[1])

isFastTriggerBuy = calcFastTrigger(true)
isFastTriggerSell = calcFastTrigger(false)

// --- 16. HARMONIZED FILTERS (Logic/Visual Sync) ---

// 1. ADX Condition (Slope + Divine Tier)
adxSlope = adx - adx[1]
adxLimitLong = buyScore >= 95 ? 15 : 18
isAdxConditionMetGlobal = adx > adxLimitLong or (weinsteinStage == 2 and adx > 15) or (adxSlope > 0 and adx > 12)

adxLimitSellGlobal = sellScore >= 95 ? 15 : 18
isAdxConditionMetSellGlobal = adx > adxLimitSellGlobal or (weinsteinStage == 4 and adx > 15) or (adxSlope > 0 and adx > 12)

// 2. Fast Cloud Condition (The Ferrari Fix - ISS-12)
// Override: If Price is above BOTH maSprint and maHull, it IS an uptrend Cloud-wise.
isFastCloudConditionMetGlobal = (isFastUptrend or (close > maSprint and close > maHull)) or buyScore >= 95
isFastCloudConditionMetSellGlobal = (isFastDowntrend or (close < maSprint and close < maHull)) or sellScore >= 95

// 16.1. NORMALIZED SIGNAL STRENGTH
buySignalStrength = math.min(100, math.round(buyScore * 0.5 + signalQuality * 0.5))
sellSignalStrength = math.min(100, math.round(sellScore * 0.5 + signalQuality * 0.5))

// --- 17. FINAL SIGNAL SNIPER VALIDATION (MOVED FOR DEPENDENCY) ---
// Enforces strict proximity to support/resistance before validating signals.
// Sniper Tolerance: 0.5% proximity required for actionable trades.
priceAtSupportLong = close <= suggestedEntryLong * 1.005 
priceAtResistanceShort = close >= suggestedEntryShort * 0.995 

// Watchlist Tolerance: 2.0% (Loosened for visual "Faded" signals)
priceNearSupportLong = close <= suggestedEntryLong * 1.02

// --- DYNAMIC THRESHOLD TUNING (The "Lean Signal" Logic) ---
// 1. Base Threshold: User Input (e.g. 82)
// 2. Lean Override: If at Structural Support, drop to 60. (Structure > Score)
// 3. Power Override: If Rocket Momentum, drop to 50. (Momentum > Score)
// 4. Chop Penalty: If ADX < 20, raise to 90. (Avoid Whipsaws)

var int effectiveBuyThreshold = 82
var int effectiveSellThreshold = 82

bool leanLongSetup = priceAtSupportLong // Defined later, but logically prior
bool leanShortSetup = priceAtResistanceShort

int adxBuyThresh = adx > 20 ? scoreThreshold : 90 // Chop Gate
effectiveBuyThreshold := isPowerBreakout ? 50 : leanLongSetup ? 60 : adxBuyThresh
effectiveSellThreshold := isPowerBreakdown ? 50 : leanShortSetup ? 60 : adxBuyThresh

technicalValidationBuy = ((buyScore >= effectiveBuyThreshold and (not requireConfluence or confluenceMetBuy) and mtfValidBuy and signalQuality >= minSignalQuality and weinsteinValidBuy and impulseValidBuy and isAdxConditionMetGlobal and isFastCloudConditionMetGlobal) or (isReversionBuy and buyScore >= 1) or hasBullishPattern or isFastTriggerBuy) and close >= open and not hasUpperWickRejection

// ENHANCED SELL VALIDATION: Elder Impulse Protection
// Rule: Cannot trigger Trend/Pattern shorts if Elder is Green (Strong Bullish).
// Reversions (Extreme OB) are allowed if RSI is extreme (>80), otherwise blocked.
isSafeToShort = not impulseGreen or (isReversionSell and rsi > 80)
technicalValidationSell = ((sellScore >= effectiveSellThreshold and (not requireConfluence or confluenceMetSell) and mtfValidSell and signalQuality >= minSignalQuality and weinsteinValidSell and impulseValidSell and isAdxConditionMetSellGlobal and isFastCloudConditionMetSellGlobal) or (isReversionSell and sellScore >= 1) or hasBearishPattern or isFastTriggerSell) and close <= open and not hasLowerWickRejection and isSafeToShort

// PRELIMINARY SIGNALS
strongBuySignalBase = capitalProtectionPassed and technicalValidationBuy
strongSellSignalBase = capitalProtectionPassed and technicalValidationSell

// PART 9: MURPHY'S ENTRY/EXIT RULES (Timeframe-Specific)

// Calculate Entry based on Murphy's teachings
// Entry: Close above resistance for buy, close below support for sell
// nearSupport / nearResistance defined earlier for validation logic
// nearSupport = math.abs(close - ta.lowest(low, 20)) / close < 0.02
// nearResistance = math.abs(close - ta.highest(high, 20)) / close < 0.02

// Optimal Entry Points
optimalBuyEntry = strongBuySignalBase and (nearSupport or close > fib618 or bullishRSIDivergence)
optimalSellEntry = strongSellSignalBase and (nearResistance or close < fib382 or bearishRSIDivergence)



// Take Profit based on Fibonacci extensions and R:R ratio
nextResistance = ta.highest(high, 50)
nextSupport = ta.lowest(low, 50)

// Manual level identification removed - handled by shortAnchorName from clustering function directly.
// This preserves high-fidelity reasons like "Bearish FVG" or "Anchored VWAP".

// SCALED ENTRY LEVELS CALCULATION (3 Tranches) - WEINSTEIN/LIVERMORE METHOD
// "Add to winners, never to losers" - Stan Weinstein
// "I scale in as the position proves I'm right" - Jesse Livermore

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PART 9: FINAL SIGNALS & PRICE VALIDATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// (Moved to Line 4035 for dependency resolution)
priceNearResistanceShort = close >= suggestedEntryShort * 0.98

// FINAL SIGNALS
// Strict (Actionable): Enters when price is at support OR massive momentum (Score >= 90)
strongBuySignal = strongBuySignalBase and (priceAtSupportLong or buyScore >= 90)
strongSellSignal = strongSellSignalBase and (priceAtResistanceShort or sellScore >= 90)

// Potential (Visual Only)
potentialBuySignal = strongBuySignalBase and priceNearSupportLong
potentialSellSignal = strongSellSignalBase and priceNearResistanceShort

// PART 9: FINAL SIGNALS & PRICE VALIDATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Stop logic for reversion (Consolidated into global clamp below)

// Stop logic for short reversion (Consolidated into global clamp)

// Position Sizing Removed (Indicator Only)
positionSizeWarning = ''

// FINAL VALIDATED SIGNALS - Capital protection + Technical validation + SIGNAL COOLDOWN
// CRITICAL FIX: Prevent signal spam - only show NEW signals (not every bar signal is active)
// User makes final decision on position size

// Track bars since last DISPLAYED signal (not just when signal was true)
var int barsSinceLastBuyDisplay = 999
var int barsSinceLastSellDisplay = 999

// Increment counters every bar
barsSinceLastBuyDisplay := barsSinceLastBuyDisplay + 1
barsSinceLastSellDisplay := barsSinceLastSellDisplay + 1

// Signal can only fire if:
// 1. Base signal exists AND
// 2. Enough time has passed since last displayed signal (cooldown from input)
cooldownPassedBuy = barsSinceLastBuyDisplay >= signalCooldown
cooldownPassedSell = barsSinceLastSellDisplay >= signalCooldown

// ZONE STATE TRACKING - Prevent multiple signals in same consolidation zone
var float lastLongZoneActioned = na
var float lastShortZoneActioned = na

// Only allow signal if we're in a NEW zone (>1% away from last zone)
inNewLongZone = na(lastLongZoneActioned) or math.abs(suggestedEntryLong - lastLongZoneActioned) / suggestedEntryLong > 0.01
inNewShortZone = na(lastShortZoneActioned) or math.abs(suggestedEntryShort - lastShortZoneActioned) / suggestedEntryShort > 0.01

// ELDER TRIPLE SCREEN FILTER (Signal Quality)
// Buy signals: Must pass Screen 1 (Weekly UP) or be an exceptional score
// Sell signals: Must pass Screen 1 (Weekly DOWN) or be an exceptional score
// High score (98+) can bypass when catching a reversal (tightened from 95)
tripleScreenBuyPass = tripleScreenBuyValid or (buyScore >= 98)
tripleScreenSellPass = tripleScreenSellValid or (sellScore >= 98)

// SIGNAL CONFIRMATION GATES:
// 1. barstate.isconfirmed = Only fire on CLOSED bars (no false signals from incomplete candles)
// 2. ADX > 20 = Only trade in trending markets (avoid chop)
bool isConfirmedBar = barstate.isconfirmed
// Use existing isTrendingMarket (defined at ~3907) - no redefinition needed

strongBuySignalFinal = ((strongBuySignal and buyScore >= scoreThreshold) or (strongBuySignal and inNewLongZone)) and tripleScreenBuyPass and isConfirmedBar and isTrendingMarket and fvgAllowsBuy
strongSellSignalFinal = ((strongSellSignal and sellScore >= scoreThreshold) or (strongSellSignal and inNewShortZone)) and tripleScreenSellPass and isConfirmedBar and isTrendingMarket and fvgAllowsSell


// Potential Signals (passed through for visualization)
potentialBuySignalFinal = strongBuySignalBase and priceNearSupportLong
potentialSellSignalFinal = strongSellSignalBase and priceNearResistanceShort

// BOLINGER BAND TRUTH (Volatility Filter)
// Calculated in Part 4 (lines ~970)
// Logic: Don't buy in "no man's land". Buy at value (Lower Band) or Momentum (Upper Band Breakout).
isNearLowerBB = close <= bbLower * 1.02 // Within 2% of Lower Band
isNearUpperBB = close >= bbUpper * 0.98 // Within 2% of Upper Band
bbBandwidth = (bbUpper - bbLower) / bbMiddle
isBBExpanding = bbBandwidth > ta.sma(bbBandwidth, 20) // Volatility expanding (Breakout mode)

// Sniper Location: For Longs, we want Value (Lower BB) OR Breakout (Upper BB + Expansion)
isSniperLocLong = isNearLowerBB or (isNearUpperBB and isBBExpanding)
isSniperLocShort = isNearUpperBB or (isNearLowerBB and isBBExpanding)

// SNIPER CONFIRMATION LOGIC (Tier 1 Check)
// Requires: 1. Base Signal 2. Sniper Trend (VWMA) 3. Fast Trigger (HMA) 4. Volume Confidence 5. BB Location
sniperConfirmedBuy = strongBuySignalFinal and isSniperUptrend and isFastUptrend and isVolConfident and isSniperLocLong
sniperConfirmedSell = strongSellSignalFinal and isSniperDowntrend and isFastDowntrend and isVolConfident and isSniperLocShort

// Tier 2 (Strong) vs Tier 3 (Weak) Logic
// If not Sniper, check if at least Fast Trend aligns
isStrongBuy = strongBuySignalFinal and not sniperConfirmedBuy and isFastUptrend
isStrongSell = strongSellSignalFinal and not sniperConfirmedSell and isFastDowntrend

// Reset counter and mark zone when signal FIRES
if strongBuySignalFinal
    barsSinceLastBuyDisplay := 0
    lastLongZoneActioned := suggestedEntryLong

if strongSellSignalFinal
    barsSinceLastSellDisplay := 0
    lastShortZoneActioned := suggestedEntryShort

currentEntry = buyScore >= sellScore ? suggestedEntryLong : suggestedEntryShort
currentStopLoss = buyScore >= sellScore ? suggestedStopLossLong : suggestedStopLossShort
currentTakeProfit = buyScore >= sellScore ? suggestedTakeProfitLong : suggestedTakeProfitShort

// Direct assignment (Stateless)
displayEntry = currentEntry
displayStopLoss = currentStopLoss
displayTakeProfit = currentTakeProfit

// Trailing stop removed (Strategy specific)


// PREPARE BOTH LONG AND SHORT SETUPS FOR DISPLAY
// Show both setups so user can see all opportunities
// Entry logic is now CORRECT (support for longs, resistance for shorts)

// --- 22. FINAL VISUAL SETUP ---
// Variables for dashboard and rendering sync.

// (Unpacking moved to Global Zone Processing Loop - Line 3316)

// VISIBILITY FILTER: SCORE-BASED GATING (INTEGRATED LOGIC)
// Only enable the side that has the Dominant Score (Gap of 10+)
// OR if both are close, enable based on Trend.

scoreGap = 10
bullDominant = buyScore > (sellScore + scoreGap)
bearDominant = sellScore > (buyScore + scoreGap)

// Active Long if Bull Dominant OR (Scores Close AND Not Downtrend/Bearish)
// Added score check: Don't show Long if score is terrible (<15) - Threshold lowered to match raw score scale (Max ~25-30)
activeLong = (bullDominant or (not bearDominant and not downtrend)) and buyScore >= 15 and longSetupActive
activeShort = (bearDominant or (not bullDominant and not uptrend)) and sellScore >= 15 and shortSetupActive

// Added score check: Don't show Short if score is terrible (<15)

// If Price breaks 200 MA against the Stack, we enter Ghost Mode (Caution) until resolved.

// VISIBILITY FILTER: SCORE-BASED OPACITY (Graduated)
// 20 = Vivid (Strong Signal)
// 60 = Hazy (Weak Signal/Warning)
// 90 = Ghost (Inactive/Trend violation)

longOpacityBase = 90 // Default: Ghost
if activeLong
    if buyScore >= 80
        longOpacityBase := 20 // Strong: Vivid
    else if buyScore >= 50
        longOpacityBase := 60 // Moderate: Hazy
    else
        longOpacityBase := 80 // Weak: Ghostly

// Text follows opacity base to prevent "stray" labels from cluttering the chart
// SYNC: Colors and opacities are now handled by the Smart-Alpha block below.

bool longZoneCounterTrend = close < globalSma200  // Buying below 200 = counter-trend
bool shortZoneCounterTrend = close > globalSma200  // Shorting above 200 = counter-trend

// Zone colors: Assigned AFTER merge detection below

// LOGICAL DIRECTION FILTER (Proximity + Direction Check)
// For LONG: Zone must be BELOW price (support) AND within 3% of price
// For SHORT: Zone must be ABOVE price (resistance) AND within 3% of price
// This prevents stale zones from appearing when price has broken away.

// (Validation Flags calculated in Global Zone Processing Loop - Line 3316)

// (Zone Promotion Handled in Global Zone Processing Loop - Line 3316)

// Final validity check using the (potentially swapped) primary zones
bool validLongZone = primaryLongNearby and longZoneLow > close * 0.90
bool validShortZone = primaryShortNearby and shortZoneHigh < close * 1.10

// MUTUAL EXCLUSIVITY & MERGE CHECK (Prevents Color Overlap Bug | User Request: "Merged Weight")
// If both zones are valid AND they overlap in price range, merge them into a high-conviction solid zone.
bool zonesOverlap = validLongZone and validShortZone and not na(longZoneHigh) and not na(shortZoneLow) and (longZoneHigh >= shortZoneLow * 0.98 and shortZoneHigh >= longZoneLow * 0.98)

// We track the merged state to apply "Solid" (no transparency) look as requested.
bool isMergedLong = false
bool isMergedShort = false

if zonesOverlap
    // SINGLE-SIGNAL CLARITY: When zones overlap, show ONLY the dominant bias zone
    // The weaker side gets suppressed entirely to avoid confusion
    // Consolidate the range: Min Low to Max High
    float mergedHigh = math.max(longZoneHigh, shortZoneHigh)
    float mergedLow = math.min(longZoneLow, shortZoneLow)
    
    // WIDTH CAP: Merged zone max 1% of price (prevents 20-point wide zones on SPY)
    float mergedCenter = (mergedHigh + mergedLow) / 2
    float maxMergedWidth = close * 0.01  // 1% cap
    if (mergedHigh - mergedLow) > maxMergedWidth
        mergedHigh := mergedCenter + (maxMergedWidth / 2)
        mergedLow := mergedCenter - (maxMergedWidth / 2)
    
    // Prioritize the dominant bias - SUPPRESS the weaker side
    if sellScore > buyScore
        isMergedShort := true
        validLongZone := false  // SUPPRESS Long zone when Short dominates
        // Apply merged bounds to winning side
        shortZoneHigh := mergedHigh
        shortZoneLow := mergedLow
    else
        isMergedLong := true
        validShortZone := false // SUPPRESS Short zone when Long dominates
        // Apply merged bounds to winning side
        longZoneHigh := mergedHigh
        longZoneLow := mergedLow

// STALE ZONE LOGIC (Grey out if price has already broken through structural bounds)
// LONG: If price is BELOW the zone low (support broken)
// SHORT: If price is ABOVE the zone high (resistance broken)
bool isStaleLong = not na(longZoneLow) and close < (longZoneLow - (atr * 0.1))
bool isStaleShort = not na(shortZoneHigh) and close > (shortZoneHigh + (atr * 0.1))
bool isStaleLong2 = not na(longZoneLow2) and close < (longZoneLow2 - (atr * 0.1))
bool isStaleShort2 = not na(shortZoneHigh2) and close > (shortZoneHigh2 + (atr * 0.1))

// MULTI-TF CONFLUENCE BONUS (Institutional Levels)
// Research: 0.7% threshold is optimal for horizontal alignment
float htfTolerance = 0.007
float longZoneCenter = (longZoneHigh + longZoneLow) / 2
float shortZoneCenter = (shortZoneHigh + shortZoneLow) / 2

// Weekly Pivot Alignment - Boost zone scores
bool longAlignsWithWeeklyPivot = not na(weeklyLow) and not na(longZoneCenter) and math.abs(longZoneCenter - weeklyLow) / nz(weeklyLow, 1) < htfTolerance
bool shortAlignsWithWeeklyPivot = not na(weeklyHigh) and not na(shortZoneCenter) and math.abs(shortZoneCenter - weeklyHigh) / nz(weeklyHigh, 1) < htfTolerance

// Apply confluence bonus to zone scores (affects opacity/confidence)
if longAlignsWithWeeklyPivot
    longZoneScore := longZoneScore * 1.3 // 30% boost for Weekly confluence  
if shortAlignsWithWeeklyPivot
    shortZoneScore := shortZoneScore * 1.3

// PRIMARY Zone colors: Yellow (counter-trend) or Blue/Red (prime) - NO GREY
color longZoneColor = longZoneCounterTrend ? color.yellow : color.blue
color shortZoneColor = shortZoneCounterTrend ? color.yellow : color.red

// SECONDARY Zone colors: Yellow (counter-trend) or Blue/Red (normal) - NO GREY
color longZoneColor2 = longZoneCounterTrend ? color.yellow : color.blue
color shortZoneColor2 = shortZoneCounterTrend ? color.yellow : color.red
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FINAL ZONE SYNC (After ALL modifications - THIS HAS FINAL SAY)
// This MUST be the last code that touches zone bounds!
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
float finalZoneExpansion = atr * 0.2 // Tight zone: ~1% expansion
// Dynamic Box Width: Calculated based on true spread or minimum threshold
// We check if the suggested entry (center) is valid, then use the spread logic

// LONG
float minWidth = atr * 0.2
float currentSpreadLong = (not na(longZoneHigh) and not na(longZoneLow)) ? (longZoneHigh - longZoneLow) : 0.0
// If spread is too thin, expand around center
if currentSpreadLong < minWidth // Enforce minimum visibility
    longZoneHigh := suggestedEntryLong + (minWidth * 0.5)
    longZoneLow := suggestedEntryLong - (minWidth * 0.5)
// Else: Keep the granular spread we calculated in the cluster phase!

// SHORT
float currentSpreadShort = (not na(shortZoneHigh) and not na(shortZoneLow)) ? (shortZoneHigh - shortZoneLow) : 0.0
if currentSpreadShort < minWidth
    shortZoneHigh := suggestedEntryShort + (minWidth * 0.5)
    shortZoneLow := suggestedEntryShort - (minWidth * 0.5)

// FINAL WIDTH CAP (Sniper Safeguard - catches all code paths)
float atrFloorFinal = atr * 0.5
float atrCeilingFinal = atr * 0.8
float pctCeilingFinal = close * 0.01
float maxWidthFinal = math.max(atrFloorFinal, math.min(pctCeilingFinal, atrCeilingFinal))

// Clamp LONG zone
if (longZoneHigh - longZoneLow) > maxWidthFinal
    float centerL = (longZoneHigh + longZoneLow) / 2
    longZoneHigh := centerL + (maxWidthFinal / 2)
    longZoneLow := centerL - (maxWidthFinal / 2)

// Clamp SHORT zone
if (shortZoneHigh - shortZoneLow) > maxWidthFinal
    float centerS = (shortZoneHigh + shortZoneLow) / 2
    shortZoneHigh := centerS + (maxWidthFinal / 2)
    shortZoneLow := centerS - (maxWidthFinal / 2)

float finalLongZoneHigh = validLongZone ? longZoneHigh : na
float finalLongZoneLow = validLongZone ? longZoneLow : na
float finalShortZoneHigh = validShortZone ? shortZoneHigh : na
float finalShortZoneLow = validShortZone ? shortZoneLow : na

// Zone label text: Simplified - full info is in dashboard tooltips
string longZoneLabelText = longZoneCounterTrend ? "‚ö†Ô∏è BUY ZONE" : "BUY ZONE"
string shortZoneLabelText = shortZoneCounterTrend ? "‚ö†Ô∏è SELL ZONE" : "SELL ZONE"

// VISIBILITY LOGIC (Smart Filter)
// User Request: "I only told only the current cluster must be active"
// We hide zones that are on the wrong side of price (Support above, Resistance below)
bool isLongZoneActive = validLongZone and not na(longZoneHigh)
bool isShortZoneActive = validShortZone and not na(shortZoneHigh)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ZONE VISUALIZATION (Multi-Zone | Score-Based Opacity)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


// --- 21. STATISTICAL OPACITY ENGINE (Hysteresis) ---
// Maps cluster persistence and Z-score strength to visual transparency.

// 0. Primary Confidence (0-100%)
// ThresholdAdjusted is the current score required to trigger a trend signal
buyConfPct = math.min(100.0, math.round(buyScore / math.max(thresholdAdjusted, 1.0) * 100.0))
sellConfPct = math.min(100.0, math.round(sellScore / math.max(thresholdAdjusted, 1.0) * 100.0))

// 1. Persistence Tracking (Accumulation)
// Reset if zone is inactive or price moved too far
float currentAtr = nz(atr, 1.0)
displacementThreshold = currentAtr * 0.5

if activeLong and not na(suggestedEntryLong)
    if not na(lastLongClusterLevel) and math.abs(suggestedEntryLong - lastLongClusterLevel) < displacementThreshold
        longClusterPersistenceCount += 1
    else
        longClusterPersistenceCount := 1
    lastLongClusterLevel := suggestedEntryLong
else
    longClusterPersistenceCount := 0
    lastLongClusterLevel := na

if activeShort and not na(suggestedEntryShort)
    if not na(lastShortClusterLevel) and math.abs(suggestedEntryShort - lastShortClusterLevel) < displacementThreshold
        shortClusterPersistenceCount += 1
    else
        shortClusterPersistenceCount := 1
    lastShortClusterLevel := suggestedEntryShort
else
    shortClusterPersistenceCount := 0
    lastShortClusterLevel := na

// 2. Statistical Strength (Z-Score)
// We compare the CURRENT cluster score against the 50-bar historical distribution
// This makes the opacity RELATIVE to prior cluster formations.
longScoreEma   := (longScoreEma == 0) ? longZoneScore : (longScoreEma * 0.98) + (longZoneScore * 0.02)
longScoreStdev := ta.stdev(longZoneScore, 50)
shortScoreEma  := (shortScoreEma == 0) ? shortZoneScore : (shortScoreEma * 0.98) + (shortZoneScore * 0.02)
shortScoreStdev := ta.stdev(shortZoneScore, 50)

// Z-Score = (Current - Mean) / Stdev
float zScoreLong = (nz(longScoreStdev) > 0) ? (longZoneScore - longScoreEma) / longScoreStdev : 0.0
float zScoreShort = (nz(shortScoreStdev) > 0) ? (shortZoneScore - shortScoreEma) / shortScoreStdev : 0.0

// Maps 0-100% confidence to alpha, but shifted by Z-Score + Persistence
// Logic: If Z-Score > 1.5 (Significant) or Persistence > 5 (Accumulation), make Solid
float persistenceBonusLong = math.min(40.0, longClusterPersistenceCount * 4.0)
float persistenceBonusShort = math.min(40.0, shortClusterPersistenceCount * 4.0)

float zBonusLong = math.max(0.0, zScoreLong * 15.0)
float zBonusShort = math.max(0.0, zScoreShort * 15.0)

// --- 22. STRUCTURAL FORENSIC SAFETY ---
[isRiskZoneLong, isRiskZoneShort, adaptiveStickiness] = checkForensicSafety(close, globalSma200, rsi, ivRank, isToppingRaw, isOverextendedRaw, isBottomingRaw, isUnderExtended)

// Calculate Final Adjusted Confidence (for Opacity)
float adjustedConfLong = math.min(100.0, buyConfPct + persistenceBonusLong + zBonusLong)
float adjustedConfShort = math.min(100.0, sellConfPct + persistenceBonusShort + zBonusShort)

// 3. SAFETY CAP (Anti-False Confidence)
// Logic: If price is overextended or topping (MU 70+ RSI case), force a visual cap of 35.0% (Ghostly).
// Uses RAW signals (before Rocket suppression) and Nuclear RSI (70+) for absolute safety.
// This is the "Supreme Law of Visuals" - no solid boxes in a nuclear chase.
if isRiskZoneLong == true
    adjustedConfLong := math.min(35.0, adjustedConfLong)
if isRiskZoneShort == true
    adjustedConfShort := math.min(35.0, adjustedConfShort)

float baseAlphaLong = longZoneCounterTrend ? 40.0 : adjustedConfLong 
// Apply Confluence Bonus for Merged Zones (Overlap +15% Weight)
float finalConfLong = isMergedLong ? math.min(100.0, baseAlphaLong + 15.0) : baseAlphaLong
float alphaLong1 = calcZoneAlpha(finalConfLong)

// Secondary Zone Alpha (Capped during Nuclear Chase)
float rawAlphaLong2 = longZoneScore2 * 10.0
if isRiskZoneLong
    rawAlphaLong2 := math.min(35.0, rawAlphaLong2)
float alphaLong2 = calcZoneAlpha(math.min(100.0, rawAlphaLong2))

float baseAlphaShort = shortZoneCounterTrend ? 40.0 : adjustedConfShort
// Apply Confluence Bonus for Merged Zones (Overlap +15% Weight)
float finalConfShort = isMergedShort ? math.min(100.0, baseAlphaShort + 15.0) : baseAlphaShort
float alphaShort1 = calcZoneAlpha(finalConfShort)

// Secondary Zone Alpha (Capped during Nuclear Chase)
float rawAlphaShort2 = shortZoneScore2 * 10.0
if isRiskZoneShort
    rawAlphaShort2 := math.min(35.0, rawAlphaShort2)
float alphaShort2 = calcZoneAlpha(math.min(100.0, rawAlphaShort2))

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SMART OPACITY SYNC (Labels & Lines)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
longAlphaBox := baseAlphaLong // For label color consistency
shortAlphaBox := baseAlphaShort 
longAlphaLine := calcZoneAlpha(baseAlphaLong + 20) // Lines are naturally 20% more transparent
shortAlphaLine := calcZoneAlpha(baseAlphaShort + 20)

// Contrast Fix: Text is solid (0 transparency). Black for light colors, White for dense ones.
longTextColor := adjustedConfLong > 50 ? color.white : color.black 
shortTextColor := adjustedConfShort > 50 ? color.white : color.black

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// --- 23. SUPREME LAW: FINAL GLOBAL RISK CLAMP (3%) ---
// Enforces absolute safety limits on stop loss and target synchronization.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// 0. TOPOLOGICAL ENFORCEMENT (Visual Hierarchy & Logic)
// Stop Loss MUST be below the Entry Zone (for Longs) or above (for Shorts)
// This prevents overlapping labels and ensures logical risk structure.
if not na(longZoneLow) and not na(suggestedStopLossLong) and suggestedStopLossLong > (longZoneLow * 0.998)
    suggestedStopLossLong := longZoneLow * 0.995 // Force 0.5% below zone structure

if not na(shortZoneHigh) and not na(suggestedStopLossShort) and suggestedStopLossShort < (shortZoneHigh * 1.002)
    suggestedStopLossShort := shortZoneHigh * 1.005 // Force 0.5% above zone structure

// 1. Force Stop Placement (Existence Check)
finalEntryL_final = nz(suggestedEntryLong, 1) == 0 ? 1 : nz(suggestedEntryLong, 1)
finalEntryS_final = nz(suggestedEntryShort, 1) == 0 ? 1 : nz(suggestedEntryShort, 1)

if suggestedStopLossLong >= finalEntryL_final or na(suggestedStopLossLong)
    suggestedStopLossLong := finalEntryL_final * (1 - baseMaxRisk)
if suggestedStopLossShort <= finalEntryS_final or na(suggestedStopLossShort)
    suggestedStopLossShort := finalEntryS_final * (1 + baseMaxRisk)

// 2. Global Risk Clamp (Strictly Technical Entry - Mirror ms_bkup.pine)
// Note: We clamp stop to 3% as "Supreme Law", but this ALONE does not mean "Toxic".
// Toxicity is only flagged if the resulting stop is technically vulnerable (-100 score).
// 2. Global Risk Clamp (REMOVED: Handled internally by calcEntryExit)
// The "Toxic Risk" logic inside calcEntryExit now handles the 3%/5% clamp 
// and the score penalty (-100) simultaneously. We do not want to override it here.
    
// MAP TOXIC FLAGS TO SCORE (-100 means forced into danger zone)
toxicRiskLong := longZoneScore == -100
toxicRiskShort := shortZoneScore == -100

// 3. Target Priority & Sync (Smart Cascade - mirrors SL logic)
float finalRiskL_final = na
float finalRiskS_final = na

if not na(suggestedStopLossLong)
    finalRiskL_final := math.abs(finalEntryL_final - suggestedStopLossLong)
    
    // SMART TARGET CASCADE (Priority Order: Structure > Existing > R:R Fallback)
    float rrTargetL = finalEntryL_final + (finalRiskL_final * riskRewardTF)
    
    // 1. If keyResistance is valid and closer than R:R target, use it
    if not na(keyResistance) and keyResistance > finalEntryL_final and keyResistance < rrTargetL
        suggestedTakeProfitLong := keyResistance
    // 2. If existing target is NOT already structurally capped, use R:R fallback
    else if not (suggestedTakeProfitLong > finalEntryL_final and suggestedTakeProfitLong < rrTargetL)
        suggestedTakeProfitLong := rrTargetL

if not na(suggestedStopLossShort)
    finalRiskS_final := math.abs(suggestedStopLossShort - finalEntryS_final)
    
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// --- 24. FORENSIC SAFETY & RISK SYNC ---
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê



// 4. Update Final Decisions for Dashboard
// 4A. FORENSIC SAFETY OVERRIDE (Already defined at Line 5255)

// SIGMA OVERRIDE: If totalSigma >= 0 (bullish/neutral confluence), don't mark as dangerous
bool sigmaOverrideSafe = totalSigma >= 0
bool effectiveDangerous = isDangerous and not sigmaOverrideSafe

// SMART TOXIC CHECK: Only check the ACTIVE side's toxic flag
// NORMALIZATION: Ignore toxic flag during Power Moves (high volatility is expected)
bool isBullishBias = totalSigma >= 0 or uptrend
bool isBearishBias = totalSigma < 0 or downtrend // SCOPE FIX: Added for Bearish Branch
bool activeSideToxic = (isBullishBias ? toxicRiskLong : toxicRiskShort) and not (isPowerBreakout or isPowerBreakdown)

// FORMING SIGNAL LOGIC (Re-implemented for Scope Availability)
// Volatility contraction + High Volume Churn = Forming a move
float spread_local = high - low
float spreadAvg_local = ta.sma(spread_local, 20)
bool isSmallMove_local = spread_local < spreadAvg_local * 0.5
bool isHighVolume_local = volume > volAvg20 * 1.5
bool isFormingPattern = isSmallMove_local and isHighVolume_local // SCOPE FIX

// SYNC STRINGS WITH SCREENSHOTS (‚úì, üõë, !)
// Distinct directional extension warnings to prevent confusion during recovery bounces.
// AMNESIA LOGIC: If In Zone (Pullback), you CANNOT be Extended.
// GLOBAL ZONE DEFINITIONS (Already defined at Line 3316)
// float zoneToleranceGlobal = close * 0.003 (Using ATR based tolerance from above)
// inLongZone and inShortZone are now global

isExtendedLong = isRiskZoneLong == true and not inLongZone
isExtendedShort = isRiskZoneShort == true and not inShortZone

// R:R GUARD (Sniper Refinement)
// Only allow PRIME label if Risk:Reward >= 1.5
float longRisk = math.abs(nz(suggestedEntryLong, close) - nz(suggestedStopLossLong, close - atr))
float longReward = math.abs(nz(suggestedTakeProfitLong, close + atr * 2) - nz(suggestedEntryLong, close))
float longRR = longReward / math.max(0.01, longRisk)
bool longRRValid = longRR >= 1.5

float shortRisk = math.abs(nz(suggestedStopLossShort, close + atr) - nz(suggestedEntryShort, close))
float shortReward = math.abs(nz(suggestedEntryShort, close) - nz(suggestedTakeProfitShort, close - atr * 2))
float shortRR = shortReward / math.max(0.01, shortRisk)
bool shortRRValid = shortRR >= 1.5

// PROACTIVE STATE ENGINE (DUAL-COLUMN: Ternary-Optimized)
// Each column evaluates its own conditions regardless of market bias.
bool isStrongTrend = nz(adx) > 25


// LONG EVALUATION (Ternary Chain) - with R:R Guard
string actionStateLong = isPowerBreakout ? (isToppingFull ? '‚úì POWER (EXT)' : '‚úì POWER MOVE') : activeSideToxic ? 'üõë TOXIC RISK' : isTopping ? '‚ö†Ô∏è TOP WARNING' : zVelocity > 2.0 ? '‚ö†Ô∏è BLOW-OFF' : (zElasticity > 1.5 and not isStrongTrend) ? '‚ö†Ô∏è EXTENDED' : inLongZone ? (buyScore >= 80 and longRRValid ? '‚úì PRIME BUY' : buyScore >= 80 and not longRRValid ? '‚ö†Ô∏è LOW R:R' : buyScore >= 60 ? '‚úì LEAN BUY' : 'üëÄ STALKING') : isFormingPattern ? '‚ö†Ô∏è FORMING' : isExtendedLong ? '! EXTENDED' : 'WAIT'


// SHORT EVALUATION (Ternary Chain) - with R:R Guard
string actionStateShort = isPowerBreakdown ? (isBottomingFull ? '‚úì POWER (EXT)' : '‚úì POWER MOVE') : activeSideToxic ? 'üõë TOXIC RISK' : isBottoming ? '‚ö†Ô∏è BOT WARNING' : zVelocity < -2.0 ? '‚ö†Ô∏è CAPITULATION' : (zElasticity < -1.5 and not isStrongTrend) ? '‚ö†Ô∏è EXTENDED' : inShortZone ? (sellScore >= 80 and shortRRValid ? '‚úì PRIME SELL' : sellScore >= 80 and not shortRRValid ? '‚ö†Ô∏è LOW R:R' : sellScore >= 60 ? '‚úì LEAN SELL' : 'üëÄ STALKING') : (isFormingPattern or isConsolidating) ? '‚ö†Ô∏è FORMING' : isExtendedShort ? '! EXTENDED' : 'WAIT'

// GLOBAL DANGER OVERRIDE (Apply to Both)
actionStateLong := effectiveDangerous and actionStateLong != '‚úì POWER MOVE' and actionStateLong != '‚úì POWER (EXT)' ? 'üõë TOO DANGEROUS' : actionStateLong
actionStateShort := effectiveDangerous and actionStateShort != '‚úì POWER MOVE' and actionStateShort != '‚úì POWER (EXT)' ? 'üõë TOO DANGEROUS' : actionStateShort

// BACKWARD COMPATIBILITY: Keep actionState for other uses
string actionState = isBullishBias ? actionStateLong : actionStateShort

// COLOR MAPPING (includes LOW R:R warning)
// CENTER COLUMN LOGIC: Display STATUS (Bullish/Bearish) + Score, NOT the Signal
// Determining "Bias" based on score dominance
string biasScoreStr = isBullishBias ? str.tostring(math.round(buyScore)) : str.tostring(math.round(sellScore))
string biasText = (isBullishBias ? "BULLISH " : "BEARISH ") + biasScoreStr

// Use explicit signal if it's a critical danger/power event, otherwise show Bias.
tradingDecision := (str.contains(actionState, "POWER") or str.contains(actionState, "DANGEROUS") or str.contains(actionState, "TOXIC") or str.contains(actionState, "BLOW-OFF")) ? actionState : biasText

tradingDecisionColor := (tradingDecision == 'üõë TOXIC RISK' or tradingDecision == 'üõë TOO DANGEROUS' or tradingDecision == '‚ö†Ô∏è TOP WARNING' or tradingDecision == '‚ö†Ô∏è BLOW-OFF' or tradingDecision == '‚ö†Ô∏è CAPITULATION') ? color.new(color.red, 0) : (tradingDecision == '‚úì POWER MOVE' or tradingDecision == '‚úì POWER (EXT)' or tradingDecision == '‚úì PRIME BUY' or tradingDecision == '‚úì PRIME SELL') ? color.new(color.lime, 0) : (tradingDecision == '‚úì LEAN BUY' or tradingDecision == '‚úì LEAN SELL') ? color.new(color.yellow, 0) : (tradingDecision == 'üëÄ STALKING' or tradingDecision == '‚ö†Ô∏è FORMING' or tradingDecision == '‚ö†Ô∏è EXTENDED' or tradingDecision == '! EXTENDED' or tradingDecision == '‚ö†Ô∏è LOW R:R') ? color.new(color.orange, 0) : COL_ORANGE

// ADX-AWARE GHOSTING: Strong trends ghost counter-trend S/L and TP
// ADX > 25 = Strong Trend, ADX < 25 = Chop (keep both visible)
if isStrongTrend
    if isBullishBias
        // Ghost the SHORT S/L and TP when bullish and trending
        shortAlphaLine := 85.0
    else
        // Ghost the LONG S/L and TP when bearish and trending
        longAlphaLine := 85.0

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// --- 25. DYNAMIC UI RENDERING (Self-Healing) ---
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// --- 25. PERSISTENT UI RENDERING (Self-Healing & Movement-Aware) ---
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if barstate.islast
    int labelX = bar_index + FUTURE_OFFSET
    int lineX1 = bar_index - 20 // Widened from -5 for better zoom stability
    float labelAlpha = 20.0
    
    // 1. PRIMARY & SECONDARY ZONES (Zones that follow price structure)
    // Extract Secondary Zone Data from Persistent Array
    longZoneHigh2  := array.get(secondaryZoneInfo, 0)
    longZoneLow2   := array.get(secondaryZoneInfo, 1)
    longZoneScore2 := array.get(secondaryZoneInfo, 2)
    shortZoneHigh2 := array.get(secondaryZoneInfo, 3)
    shortZoneLow2  := array.get(secondaryZoneInfo, 4)
    shortZoneScore2:= array.get(secondaryZoneInfo, 5)

    // Dynamic Opacity for Zones
    // Dynamic Opacity for Zones
    float aLong1 = math.min(longAlphaBox, 85)
    float aShort1 = math.min(shortAlphaBox, 85)
    
    // A. üü¢ LONG ZONES
    if showEntryExit and isLongZoneActive and not na(finalLongZoneHigh) and not na(finalLongZoneLow) and math.abs(finalLongZoneHigh - close) < scaleGuardThreshold
        int lStart = na(longZoneStartIdx) ? bar_index : longZoneStartIdx
        if na(longZoneBox)
            longZoneBox := box.new(lStart, finalLongZoneHigh, labelX, finalLongZoneLow, border_color = color.new(longZoneColor, aLong1), border_width = 1, bgcolor = color.new(longZoneColor, aLong1))
        else
            box.set_lefttop(longZoneBox, lStart, finalLongZoneHigh)
            box.set_rightbottom(longZoneBox, labelX, finalLongZoneLow)
            box.set_bgcolor(longZoneBox, color.new(longZoneColor, aLong1))
            box.set_border_color(longZoneBox, color.new(longZoneColor, aLong1))
        
        if na(longZoneLabel)
            longZoneLabel := label.new(labelX, finalLongZoneHigh, longZoneLabelText, style = label.style_label_down, color = color.new(longZoneColor, labelAlpha), textcolor = color.white, size = size.small)
        else
            label.set_xy(longZoneLabel, labelX, finalLongZoneHigh)
            label.set_text(longZoneLabel, longZoneLabelText)
            label.set_color(longZoneLabel, color.new(longZoneColor, labelAlpha))
    else
        box.set_lefttop(longZoneBox, na, na), box.set_rightbottom(longZoneBox, na, na)
        label.set_xy(longZoneLabel, na, na)

    // Secondary Long Zone (ALWAYS visible if valid - not dependent on primary zone merge status)
    if showEntryExit and not na(longZoneHigh2) and not na(longZoneLow2) and longZoneScore2 > 0.0 and math.abs(longZoneHigh2 - close) < close * 0.5
        string lName2 = array.get(secondaryZoneNames, 0)
        string lLblText2 = "SECONDARY"
        bool lOverlap = not na(finalLongZoneHigh) and math.abs(longZoneHigh2 - finalLongZoneHigh) / finalLongZoneHigh < 0.02
        float lVal2 = lOverlap ? longZoneLow2 : longZoneHigh2
        string lStyle2 = lOverlap ? label.style_label_up : label.style_label_down
        
        if na(longZoneBox2)
            longZoneBox2 := box.new(bar_index, longZoneHigh2, labelX, longZoneLow2, border_color = color.new(longZoneColor2, 70), border_width = 1, bgcolor = color.new(longZoneColor2, 80))
        else
            box.set_lefttop(longZoneBox2, bar_index, longZoneHigh2)
            box.set_rightbottom(longZoneBox2, labelX, longZoneLow2)
            box.set_bgcolor(longZoneBox2, color.new(longZoneColor2, 80))
            box.set_border_color(longZoneBox2, color.new(longZoneColor2, 70))
        
        if na(longZoneLabel2)
            longZoneLabel2 := label.new(labelX, lVal2, lLblText2, style = lStyle2, color = color.new(longZoneColor2, labelAlpha), textcolor = color.white, size = size.tiny)
        else
            label.set_xy(longZoneLabel2, labelX, lVal2)
            label.set_text(longZoneLabel2, lLblText2)
            label.set_style(longZoneLabel2, lStyle2)
    else
        box.set_lefttop(longZoneBox2, na, na), box.set_rightbottom(longZoneBox2, na, na)
        label.set_xy(longZoneLabel2, na, na)

    // B. üî¥ SHORT ZONES
    if showEntryExit and isShortZoneActive and not na(finalShortZoneHigh) and not na(finalShortZoneLow) and math.abs(finalShortZoneHigh - close) < scaleGuardThreshold
        int sStart = na(shortZoneStartIdx) ? bar_index : shortZoneStartIdx
        if na(shortZoneBox)
            shortZoneBox := box.new(sStart, finalShortZoneHigh, labelX, finalShortZoneLow, border_color = color.new(shortZoneColor, aShort1), border_width = 1, bgcolor = color.new(shortZoneColor, aShort1))
        else
            box.set_lefttop(shortZoneBox, sStart, finalShortZoneHigh)
            box.set_rightbottom(shortZoneBox, labelX, finalShortZoneLow)
            box.set_bgcolor(shortZoneBox, color.new(shortZoneColor, aShort1))
            box.set_border_color(shortZoneBox, color.new(shortZoneColor, aShort1))
        
        if na(shortZoneLabel)
            shortZoneLabel := label.new(labelX, finalShortZoneLow, shortZoneLabelText, style = label.style_label_up, color = color.new(shortZoneColor, labelAlpha), textcolor = color.white, size = size.small)
        else
            label.set_xy(shortZoneLabel, labelX, finalShortZoneLow)
            label.set_text(shortZoneLabel, shortZoneLabelText)
            label.set_color(shortZoneLabel, color.new(shortZoneColor, labelAlpha))
    else
        box.set_lefttop(shortZoneBox, na, na), box.set_rightbottom(shortZoneBox, na, na)
        label.set_xy(shortZoneLabel, na, na)

    // Secondary Short Zone (ALWAYS visible if valid - not dependent on primary zone merge status)
    // GUARD: shortZoneHigh2 must be ABOVE price (resistance)
    if showEntryExit and not na(shortZoneHigh2) and not na(shortZoneLow2) and shortZoneScore2 > 0.0 and shortZoneHigh2 >= close and math.abs(shortZoneHigh2 - close) < close * 0.5
        string sName2 = array.get(secondaryZoneNames, 1)
        string sLblText2 = "SECONDARY"
        bool sOverlap = not na(finalShortZoneLow) and math.abs(shortZoneLow2 - finalShortZoneLow) / finalShortZoneLow < 0.02
        float sVal2 = sOverlap ? shortZoneHigh2 : shortZoneLow2
        string sStyle2 = sOverlap ? label.style_label_down : label.style_label_up

        if na(shortZoneBox2)
            shortZoneBox2 := box.new(bar_index, shortZoneHigh2, labelX, shortZoneLow2, border_color = color.new(shortZoneColor2, 70), border_width = 1, bgcolor = color.new(shortZoneColor2, 80))
        else
            box.set_lefttop(shortZoneBox2, bar_index, shortZoneHigh2)
            box.set_rightbottom(shortZoneBox2, labelX, shortZoneLow2)
            box.set_bgcolor(shortZoneBox2, color.new(shortZoneColor2, 80))
            box.set_border_color(shortZoneBox2, color.new(shortZoneColor2, 70))
        
        if na(shortZoneLabel2)
            shortZoneLabel2 := label.new(labelX, sVal2, sLblText2, style = sStyle2, color = color.new(shortZoneColor2, labelAlpha), textcolor = color.white, size = size.tiny)
        else
            label.set_xy(shortZoneLabel2, labelX, sVal2)
            label.set_text(shortZoneLabel2, sLblText2)
            label.set_style(shortZoneLabel2, sStyle2)
    else
        box.set_lefttop(shortZoneBox2, na, na), box.set_rightbottom(shortZoneBox2, na, na)
        label.set_xy(shortZoneLabel2, na, na)

    // 2. INTERACTIVE BUNDLES (Standard lines following price)
    // Long Bundle
    if showEntryExit and isLongZoneActive
        color lEntryColor = color.new(longZoneColor, longAlphaBox)
        // Visual entry at zone boundary: LONG = buy at support (bottom)
        float visualEntryLong = na(finalLongZoneLow) ? suggestedEntryLong : finalLongZoneLow
        line.set_xy1(lEntryLine_P, lineX1, visualEntryLong)
        line.set_xy2(lEntryLine_P, labelX, visualEntryLong)
        line.set_color(lEntryLine_P, lEntryColor)
        
        label.set_xy(lEntryLbl_P, labelX, visualEntryLong)
        label.set_text(lEntryLbl_P, "LONG ENTRY")
        label.set_color(lEntryLbl_P, lEntryColor)
        label.set_textcolor(lEntryLbl_P, longTextColor)
        label.set_tooltip(lEntryLbl_P, longTooltip)
        
        if showStopLoss
            string lStopText = (not na(suggestedStopLossLong) and not na(longZoneLow) and suggestedStopLossLong > (longZoneLow * 1.01)) ? 'LONG STOP (‚Üë)' : 'LONG STOP'
            line.set_xy1(lStopLine_P, lineX1, suggestedStopLossLong), line.set_xy2(lStopLine_P, labelX, suggestedStopLossLong)
            label.set_xy(lStopLbl_P, labelX, suggestedStopLossLong)
            label.set_text(lStopLbl_P, lStopText)
            label.set_color(lStopLbl_P, color.new(color.red, longAlphaLine))
            label.set_tooltip(lStopLbl_P, 'LONG STOP $' + str.tostring(suggestedStopLossLong, '#.##'))
            
            line.set_xy1(lTargetLine_P, lineX1, suggestedTakeProfitLong), line.set_xy2(lTargetLine_P, labelX, suggestedTakeProfitLong)
            label.set_xy(lTargetLbl_P, labelX, suggestedTakeProfitLong)
            label.set_text(lTargetLbl_P, "LONG TARGET")
            label.set_color(lTargetLbl_P, color.new(color.green, longAlphaLine))
            label.set_tooltip(lTargetLbl_P, 'LONG TARGET $' + str.tostring(suggestedTakeProfitLong, '#.##'))
        else
            line.set_xy1(lStopLine_P, na, na), line.set_xy2(lStopLine_P, na, na)
            label.set_xy(lStopLbl_P, na, na)
            line.set_xy1(lTargetLine_P, na, na), line.set_xy2(lTargetLine_P, na, na)
            label.set_xy(lTargetLbl_P, na, na)
    else
        line.set_xy1(lEntryLine_P, na, na), line.set_xy2(lEntryLine_P, na, na)
        label.set_xy(lEntryLbl_P, na, na)
        line.set_xy1(lStopLine_P, na, na), line.set_xy2(lStopLine_P, na, na)
        label.set_xy(lStopLbl_P, na, na)
        line.set_xy1(lTargetLine_P, na, na), line.set_xy2(lTargetLine_P, na, na)
        label.set_xy(lTargetLbl_P, na, na)

    // Short Bundle
    if showEntryExit and isShortZoneActive
        color sEntryColor = color.new(shortZoneColor, shortAlphaBox)
        // Visual entry at zone boundary: SHORT = sell at resistance (top)
        float visualEntryShort = na(finalShortZoneHigh) ? suggestedEntryShort : finalShortZoneHigh
        line.set_xy1(sEntryLine_P, lineX1, visualEntryShort)
        line.set_xy2(sEntryLine_P, labelX, visualEntryShort)
        line.set_color(sEntryLine_P, sEntryColor)
        
        label.set_xy(sEntryLbl_P, labelX, visualEntryShort)
        label.set_text(sEntryLbl_P, "SHORT ENTRY")
        label.set_color(sEntryLbl_P, sEntryColor)
        label.set_textcolor(sEntryLbl_P, shortTextColor)
        label.set_tooltip(sEntryLbl_P, shortTooltip)
        
        if showStopLoss
            string sStopText = (not na(suggestedStopLossShort) and not na(shortZoneLow) and suggestedStopLossShort < (shortZoneHigh * 0.99)) ? 'SHORT STOP (‚Üì)' : 'SHORT STOP'
            line.set_xy1(sStopLine_P, lineX1, suggestedStopLossShort), line.set_xy2(sStopLine_P, labelX, suggestedStopLossShort)
            label.set_xy(sStopLbl_P, labelX, suggestedStopLossShort)
            label.set_text(sStopLbl_P, sStopText)
            label.set_color(sStopLbl_P, color.new(color.red, shortAlphaLine))
            label.set_tooltip(sStopLbl_P, 'SHORT STOP $' + str.tostring(suggestedStopLossShort, '#.##'))
            
            line.set_xy1(sTargetLine_P, lineX1, suggestedTakeProfitShort), line.set_xy2(sTargetLine_P, labelX, suggestedTakeProfitShort)
            label.set_xy(sTargetLbl_P, labelX, suggestedTakeProfitShort)
            label.set_text(sTargetLbl_P, "SHORT TARGET")
            label.set_color(sTargetLbl_P, color.new(color.green, shortAlphaLine))
            label.set_tooltip(sTargetLbl_P, 'SHORT TARGET $' + str.tostring(suggestedTakeProfitShort, '#.##'))
        else
            line.set_xy1(sStopLine_P, na, na), line.set_xy2(sStopLine_P, na, na)
            label.set_xy(sStopLbl_P, na, na)
            line.set_xy1(sTargetLine_P, na, na), line.set_xy2(sTargetLine_P, na, na)
            label.set_xy(sTargetLbl_P, na, na)
    else
        line.set_xy1(sEntryLine_P, na, na), line.set_xy2(sEntryLine_P, na, na)
        label.set_xy(sEntryLbl_P, na, na)
        line.set_xy1(sStopLine_P, na, na), line.set_xy2(sStopLine_P, na, na)
        label.set_xy(sStopLbl_P, na, na)
        line.set_xy1(sTargetLine_P, na, na), line.set_xy2(sTargetLine_P, na, na)
        label.set_xy(sTargetLbl_P, na, na)

    // 3. DARVAS BOX PERSISTENCE
    if darvasBoxValid and math.abs(currentBoxTop - close) < scaleGuardThreshold and math.abs(currentBoxBottom - close) < scaleGuardThreshold
        if na(darvasBoxTopLine)
            darvasBoxTopLine := line.new(lineX1, currentBoxTop, labelX, currentBoxTop, color = color.new(COL_ORANGE, 30), width = 2, style = line.style_dashed)
        else
            line.set_xy1(darvasBoxTopLine, lineX1, currentBoxTop), line.set_xy2(darvasBoxTopLine, labelX, currentBoxTop)
        
        if na(darvasBoxBottomLine)
            darvasBoxBottomLine := line.new(lineX1, currentBoxBottom, labelX, currentBoxBottom, color = color.new(COL_ORANGE, 30), width = 2, style = line.style_dashed)
        else
            line.set_xy1(darvasBoxBottomLine, lineX1, currentBoxBottom), line.set_xy2(darvasBoxBottomLine, labelX, currentBoxBottom)
        
        darvasTopTooltip = 'Darvas Box: Nicolas Darvas pattern\nTop: ' + str.tostring(currentBoxTop, '#.##') + '\nBot: ' + str.tostring(currentBoxBottom, '#.##')
        if na(darvasTopLabel)
            darvasTopLabel := label.new(labelX, currentBoxTop, 'BOX TOP', tooltip = darvasTopTooltip, style = labelStyleToUse, color = color.new(COL_ORANGE, 30), textcolor = color.white, size = size.small)
        else
            label.set_xy(darvasTopLabel, labelX, currentBoxTop), label.set_text(darvasTopLabel, 'BOX TOP [' + darvasStatus + ']')
            
        if na(darvasBottomLabel)
            darvasBottomLabel := label.new(labelX, currentBoxBottom, 'BOX BOT', tooltip = 'Darvas Box Bottom', style = labelStyleToUse, color = color.new(COL_ORANGE, 30), textcolor = color.white, size = size.small)
        else
            label.set_xy(darvasBottomLabel, labelX, currentBoxBottom)
    else
        line.set_xy1(darvasBoxTopLine, na, na), line.set_xy2(darvasBoxTopLine, na, na)
        line.set_xy1(darvasBoxBottomLine, na, na), line.set_xy2(darvasBoxBottomLine, na, na)
        label.set_xy(darvasTopLabel, na, na)
        label.set_xy(darvasBottomLabel, na, na)

    // 4. GHOST TITANIUM LEVELS
    renderGhostTitaniumLevels(ghostLines, ghostLabels)

// --- 24. ALERTS & LOGGING ---

// Update labels on last bar (Consolidated above)

// --- 26. BUY/SELL SIGNAL EXECUTION (Historical & Real-time) ---

// Only show label on FIRST bar of signal (not every bar while signal stays true)
buySignalNew = strongBuySignalFinal and not strongBuySignalFinal[1]
sellSignalNew = strongSellSignalFinal and not strongSellSignalFinal[1]

// GLOBAL DEBUG TOOLTIPS (Persisted for Dashboard)
var string lastBuyTooltip = "Waiting for Buy Signal..."
var string lastSellTooltip = "Waiting for Sell Signal..."

// Series data needs to be calculated in global scope
highestBuyScore3 = ta.highest(buyScore, 3)
highestSellScore3 = ta.highest(sellScore, 3)
var string buyTooltip = ""
var string sellTooltip = ""
var color buyLabelColor = color.gray
var color sellLabelColor = color.gray

// --- 27. UI FORMATTING CONSTANTS ---
string sep = "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
string sweepMsg = "\n\nüíé PREDICTION: LIQUIDITY SWEEP\nSmart Money Trap"
string fadedMsg = "\n\n‚õî SIGNAL FADED (Lower Confidence)"
string choppyMessageString = ": CHOPPY MARKET (Efficiency Low)\nStrategy:"
string choppyBase = "\n\n‚ö†Ô∏è CONTEXT " + choppyMessageString
string choppyCaution = "\n\n‚ö†Ô∏è CAUTION " + choppyMessageString
string cloudFilterStr = "‚Ä¢ Fast Cloud: "
string adxFilterStr = "‚Ä¢ Adx: "

// Draw labels with dynamic text for buy/sell signals (only on NEW signals)
if buySignalNew and (barstate.islast or bar_index > last_bar_index - maxLabelHistory)
    // Determine Trigger Reason
    triggerType = isReversionBuy ? "REVERSION (Dip Buy)" : hasBullishPattern ? "PATTERN (Breakout)" : "TREND FOLLOW (Breakout)"
    shortType = isReversionBuy ? "(Dip)" : "(Trend)"
    
    // QUALIFIED FLAGS (Middleground: Power Overrides Topping)
    isQualifiedStrongBuyGlobal = (buyScore >= 90) and (not isTopping or isPowerBreakout) and isFastCloudConditionMetGlobal and isAdxConditionMetGlobal
    isParabolicBuy = buyScore >= 90 and not priceAtSupportLong and uptrend
    
    // Build Detailed Tooltip
    buyTooltip := "üöÄ BUY SIGNAL TRIGGERED\n" + sep
    buyTooltip := buyTooltip + "üìä BUY SCORE: " + fmt0(buyScore) + " | SELL SCORE: " + fmt0(sellScore) + "\n" + sep
    buyTooltip := buyTooltip + "Type: " + triggerType + "\n"
    buyTooltip := buyTooltip + "Logic: " + entryReasonLong + "\n\n"
    
    // Add predictive setup info if any active (BUY-ONLY: Accumulating ONLY, no neutral signals)
    // Neutral signals (Squeeze, Range Contracted) removed - they are direction-agnostic
    if predictiveStatusBull != ""
        buyTooltip := buyTooltip + "‚îÅ‚îÅ‚îÅ SETUP ‚îÅ‚îÅ‚îÅ\n"
        buyTooltip := buyTooltip + predictiveStatusBull + "\n"
    
    if isReversionBuy
        buyTooltip := buyTooltip + "REASON: Price Reversal at Support\n"
        buyTooltip := buyTooltip + "‚Ä¢ Hammer Candle: " + (isHammer ? "YES ‚úÖ" : "NO") + "\n"
        buyTooltip := buyTooltip + "‚Ä¢ Near Support: " + (nearSupport ? "YES ‚úÖ" : "NO") + "\n"
        buyTooltip := buyTooltip + "‚Ä¢ Darvas Breakout: " + (darvasBreakout ? "YES ‚úÖ" : "NO") + "\n"

    else
        buyTooltip := buyTooltip + "REASON: Strong Trend Continuation\n"
        buyTooltip := buyTooltip + "SCORE BREAKDOWN (" + fmt0(buyScore) + "/" + fmt0(thresholdAdjusted) + "):\n"
        
        if buyTrendScore > 0
            buyTrendText = (buyTrend1 ? "MA Cross " : "") + (buyTrend2 ? "Golden Cross " : "") + (buyTrend3 ? "Strong Trend " : "") + (buyTrend4 ? "MTF Align " : "") + (buyTrend5 ? "Major Align " : "") + (buyTrend6 ? "Stage 2" : "")
            buyTooltip := buyTooltip + "‚Ä¢ Trend (" + fmt0(buyTrendScore) + "): " + buyTrendText + "\n"
        if buyMomentumScore > 0
            buyMomentumText = (buyMomentum1 ? "RSI OS " : "") + (buyMomentum2 ? "MACD+ " : "") + (buyMomentum3 ? "Stoch " : "") + (buyMomentum4 ? "Mom+ " : "") + (buyMomentum5 ? "MACD Cont " : "") + (buyMomentum6 ? "RSI Rise " : "") + (buyMomentum7 ? "Force " : "") + (buyMomentum9 ? "Impulse" : "")
            buyTooltip := buyTooltip + "‚Ä¢ Momentum (" + fmt0(buyMomentumScore) + "): " + buyMomentumText + "\n"
        if buyVolumeScore > 0
            buyTooltip := buyTooltip + "‚Ä¢ Volume (" + fmt0(buyVolumeScore) + "): OBV Bullish\n"
        if buyVolatilityScore > 0
            buyVolText = (buyVolatility1 ? "MA Bounce " : "") + (buyVolatility2 ? "PSAR " : "") + (buyVolatility3 ? "Fib " : "") + (buyVolatility7 ? "Darvas" : "")
            buyTooltip := buyTooltip + "‚Ä¢ Support (" + fmt0(buyVolatilityScore) + "): " + buyVolText + "\n"
        if buyDivergenceScore > 0
            buyTooltip := buyTooltip + "‚Ä¢ Divergence: Bullish\n"
            
        // PATTERN MATCHING (TA)
        if bullFlag
            buyTooltip := buyTooltip + "‚Ä¢ Pattern: Bull Flag ‚úÖ\n"
        if bullishSweep
            buyTooltip := buyTooltip + "‚Ä¢ Pattern: Liq Sweep ‚úÖ\n"

            
    buyTooltip := buyTooltip + "\nFILTERS:\n"
    buyTooltip := buyTooltip + cloudFilterStr + (isFastCloudConditionMetGlobal ? "GREEN/PASSED ‚úÖ" : "RED ‚ùå") + "\n"
    buyTooltip := buyTooltip + adxFilterStr + (isAdxConditionMetGlobal ? "Strong/Passed ‚úÖ" : "Weak ‚ùå") + "\n"
    
    // COOLDOWN WARNING
    if not cooldownPassedBuy and not isReversionBuy
        buyTooltip := buyTooltip + "\nTIMEOUT WARNING: Signal active (High Frequency) ‚ö†Ô∏è"

    // Warnings
    if close < open
        buyTooltip := buyTooltip + "\n‚ö†Ô∏è WARNING: Red Candle (Weak Close)"
        
    // Bounce Analysis
    if not na(keySupport) and math.abs(close - keySupport) / keySupport < 0.005
        buyTooltip := buyTooltip + "\n‚úÖ BOUNCE: Price responding to KEY SUPPORT"
    
    // Confidence Logic (Refined)
    // If it's a Qualified Strong Buy or Rocket, Confidence is HIGH regardless of the slower Supertrend.
    isHighConfidence = (uptrend and close >= open) or isQualifiedStrongBuyGlobal or buyScore >= 95
    buyTooltip := buyTooltip + "\n\nConfidence: " + (isHighConfidence ? "HIGH" : "MODERATE (Faded)")
    
    // Store for Dashboard
    lastBuyTooltip := buyTooltip
    visualStrongBuy = isHighConfidence
    buyLabelColor := visualStrongBuy ? color.new(color.green, 0) : color.new(color.green, 80)
    
    // FORMING vs CONFIRMED: Gray for unconfirmed bars, solid for confirmed
    bool isFormingBuySignal = not barstate.isconfirmed
    formingBuyColor = isFormingBuySignal ? color.gray : buyLabelColor
    formingBuyTextColor = isFormingBuySignal ? color.black : color.white
    formingPrefix = isFormingBuySignal ? '‚è≥ ' : ''
    formingTooltipSuffix = isFormingBuySignal ? '\n\n‚è≥ FORMING - Wait for bar close to confirm.' : ''
    
    // LABEL GENERATION (With Stacking Protection for Terminal Bar)
    label l = na
    if isParabolicBuy and isFastCloudConditionMetGlobal and isAdxConditionMetGlobal
        buyTooltip := buyTooltip + "\n\n‚ö†Ô∏è PARABOLIC MODE (Score > 90)\nLogic filtered STRICT support requirement. High Risk / Climax Move." + formingTooltipSuffix
        l := label.new(bar_index - 1, na, formingPrefix + 'üöÄ ROCKET', color = formingBuyColor, style = label.style_label_up, textcolor = formingBuyTextColor, size = size.small, tooltip = buyTooltip, yloc = yloc.belowbar)
    else if isQualifiedStrongBuyGlobal
        buyTooltip := buyTooltip + formingTooltipSuffix
        l := label.new(bar_index - 1, na, formingPrefix + 'üíé STRONG BUY', color = formingBuyColor, style = label.style_label_up, textcolor = formingBuyTextColor, size = size.small, tooltip = buyTooltip, yloc = yloc.belowbar)
    else if buyScore >= 90
        buyTooltip := buyTooltip + "\n\n‚ö†Ô∏è HIGH SCORE BUT WEAK FILTERS\nFast Cloud: " + (isFastCloudConditionMetGlobal ? "PASSED ‚úÖ" : "RED ‚ùå") + "\nADX: " + (isAdxConditionMetGlobal ? "PASSED ‚úÖ" : "Weak ‚ùå") + formingTooltipSuffix
        weakBuyColor = isFormingBuySignal ? color.gray : color.new(color.yellow, 20)
        l := label.new(bar_index - 1, na, formingPrefix + 'üìà BUY ‚ö†Ô∏è', color = weakBuyColor, style = label.style_label_up, textcolor = color.black, size = size.small, tooltip = buyTooltip, yloc = yloc.belowbar)
    else
        buyTooltip := buyTooltip + formingTooltipSuffix
        l := label.new(bar_index - 1, na, formingPrefix + 'üìà BUY', color = formingBuyColor, style = label.style_label_up, textcolor = formingBuyTextColor, size = size.small, tooltip = buyTooltip, yloc = yloc.belowbar)
    
    // Stacking Protection
    if barstate.islast
        if not na(discoverySignalLbl) and label.get_x(discoverySignalLbl) == bar_index - 1
            label.delete(discoverySignalLbl)
        discoverySignalLbl := l

// Trade plan labels are now consolidated in Section 25 (islast)

// PERFORMANCE OPTIMIZATION: Check history limit first
if sellSignalNew and (barstate.islast or bar_index > last_bar_index - maxLabelHistory)
    // Determine Trigger Reason
    triggerType = isReversionSell ? "REVERSION (Top Short)" : hasBearishPattern ? "PATTERN (Breakdown)" : "TREND FOLLOW (Breakdown)"
    shortType = isReversionSell ? "(Rev)" : "(Trend)"
    
    // QUALIFIED FLAGS (For Labels/Confidence)
    isQualifiedStrongSellGlobal = sellScore >= 90 and isFastCloudConditionMetSellGlobal and isAdxConditionMetSellGlobal
    isParabolicSell = sellScore >= 90 and not priceAtResistanceShort and downtrend
    
    // Build Detailed Tooltip
    sellTooltip := "üìâ SELL SIGNAL TRIGGERED\n" + sep
    sellTooltip := sellTooltip + "üìä SELL SCORE: " + fmt0(sellScore) + " | BUY SCORE: " + fmt0(buyScore) + "\n" + sep
    sellTooltip := sellTooltip + "Type: " + triggerType + "\n"
    sellTooltip := sellTooltip + "Logic: " + entryReasonShort + "\n\n"
    
    // Add predictive setup info if any active
    if predictiveStatusBear != ""
        sellTooltip := sellTooltip + "‚îÅ‚îÅ‚îÅ SETUP ‚îÅ‚îÅ‚îÅ\n"
        sellTooltip := sellTooltip + predictiveStatusBear + "\n"
    
    if isReversionSell
        sellTooltip := sellTooltip + "REASON: Rejection at Resistance\n"
        sellTooltip := sellTooltip + "‚Ä¢ Shooting Star: " + (isShootingStar ? "YES ‚úÖ" : "NO") + "\n"
        sellTooltip := sellTooltip + "‚Ä¢ Near Resistance: " + (nearResistance ? "YES ‚úÖ" : "NO") + "\n"
        sellTooltip := sellTooltip + "‚Ä¢ Darvas Breakdown: " + (darvasBreakdown ? "YES ‚úÖ" : "NO") + "\n"
        if darvasFakeout
            sellTooltip := sellTooltip + "‚Ä¢ FAKEOUT: Gap Up & Fail ‚úÖ\n"
    else
        sellTooltip := sellTooltip + "REASON: Strong Trend Breakdown\n"
        sellTooltip := sellTooltip + "SCORE BREAKDOWN (" + fmt0(sellScore) + "/" + fmt0(thresholdAdjusted) + "):\n"
        
        if sellTrendScore > 0
            sellTrendText = (sellTrend1 ? "MA Cross " : "") + (sellTrend2 ? "Death Cross " : "") + (sellTrend3 ? "Strong Downtrend " : "") + (sellTrend4 ? "MTF Align " : "") + (sellTrend5 ? "Major Align " : "") + (sellTrend6 ? "Stage 4" : "")
            sellTooltip := sellTooltip + "‚Ä¢ Trend (" + fmt0(sellTrendScore) + "): " + sellTrendText + "\n"
        if sellMomentumScore > 0
            sellMomentumText = (sellMomentum1 ? "RSI OB " : "") + (sellMomentum2 ? "MACD- " : "") + (sellMomentum3 ? "Stoch " : "") + (sellMomentum5 ? "MACD Cont " : "") + (sellMomentum7 ? "Force " : "") + (sellMomentum8 ? "Impulse" : "")
            sellTooltip := sellTooltip + "‚Ä¢ Momentum (" + fmt0(sellMomentumScore) + "): " + sellMomentumText + "\n"
        if sellVolumeScore > 0
            sellTooltip := sellTooltip + "‚Ä¢ Volume (" + fmt0(sellVolumeScore) + "): OBV Bearish\n"
        if sellVolatilityScore > 0
            sellVolText = (sellVolatility1 ? "BB Rej " : "") + (sellVolatility2 ? "PSAR " : "") + (sellVolatility3 ? "Fib " : "") + (sellVolatility6 ? "Darvas" : "")
            sellTooltip := sellTooltip + "‚Ä¢ Resistance (" + fmt0(sellVolatilityScore) + "): " + sellVolText + "\n"
        if sellDivergenceScore > 0
            sellTooltip := sellTooltip + "‚Ä¢ Divergence: Bearish\n"

        if bearFlag
            sellTooltip := sellTooltip + "‚Ä¢ Pattern: Bear Flag ‚úÖ\n"
        if bearishSweep
            sellTooltip := sellTooltip + "‚Ä¢ Pattern: Liq Sweep ‚úÖ\n"

    sellTooltip := sellTooltip + "\nFILTERS:\n"
    sellTooltip := sellTooltip + cloudFilterStr + (isFastCloudConditionMetSellGlobal ? "RED/PASSED ‚úÖ" : "GREEN ‚ùå") + "\n"
    sellTooltip := sellTooltip + adxFilterStr + (isAdxConditionMetSellGlobal ? "Strong/Passed ‚úÖ" : "Weak ‚ùå") + "\n"
    
    if not cooldownPassedSell and not isReversionSell
        sellTooltip := sellTooltip + "\nTIMEOUT WARNING: Signal active (High Frequency) ‚ö†Ô∏è"

    if close > open
        sellTooltip := sellTooltip + "\n‚ö†Ô∏è WARNING: Green Candle (Buyers Winning)"

    isHighConfidenceSell = (downtrend and close <= open) or isQualifiedStrongSellGlobal or sellScore >= 95
    sellTooltip := sellTooltip + "\n\nConfidence: " + (isHighConfidenceSell ? "HIGH" : "MODERATE (Faded)")
    
    lastSellTooltip := sellTooltip
    visualStrongSell = isHighConfidenceSell
    sellLabelColor := visualStrongSell ? color.new(color.red, 0) : color.new(color.red, 80)
    
    // FORMING vs CONFIRMED: Gray for unconfirmed bars, solid for confirmed
    bool isFormingSellSignal = not barstate.isconfirmed
    formingSellColor = isFormingSellSignal ? color.gray : sellLabelColor
    formingSellTextColor = isFormingSellSignal ? color.black : color.white
    formingSellPrefix = isFormingSellSignal ? '‚è≥ ' : ''
    formingSellTooltipSuffix = isFormingSellSignal ? '\n\n‚è≥ FORMING - Wait for bar close to confirm.' : ''
    
    // LABEL GENERATION
    label ls = na
    if isParabolicSell and isFastCloudConditionMetSellGlobal and isAdxConditionMetSellGlobal
        sellTooltip := sellTooltip + "\n\n‚ö†Ô∏è PARABOLIC MODE (Score > 90)\nLogic filtered STRICT resistance requirement. High Risk / Climax Move." + formingSellTooltipSuffix
        ls := label.new(bar_index - 1, na, formingSellPrefix + '‚òÑÔ∏è CRASH', color = formingSellColor, style = label.style_label_down, textcolor = formingSellTextColor, size = size.small, tooltip = sellTooltip, yloc = yloc.abovebar)
    else if isQualifiedStrongSellGlobal
        sellTooltip := sellTooltip + formingSellTooltipSuffix
        ls := label.new(bar_index - 1, na, formingSellPrefix + 'üíé STRONG SELL', color = formingSellColor, style = label.style_label_down, textcolor = formingSellTextColor, size = size.small, tooltip = sellTooltip, yloc = yloc.abovebar)
    else if sellScore >= 90
        sellTooltip := sellTooltip + "\n\n‚ö†Ô∏è HIGH SCORE BUT WEAK FILTERS\nFast Cloud: " + (isFastCloudConditionMetSellGlobal ? "PASSED ‚úÖ" : "GREEN ‚ùå") + "\nADX: " + (isAdxConditionMetSellGlobal ? "PASSED ‚úÖ" : "Weak ‚ùå") + formingSellTooltipSuffix
        weakSellColor = isFormingSellSignal ? color.gray : color.new(color.yellow, 20)
        ls := label.new(bar_index - 1, na, formingSellPrefix + 'üìâ SELL ‚ö†Ô∏è', color = weakSellColor, style = label.style_label_down, textcolor = color.black, size = size.small, tooltip = sellTooltip, yloc = yloc.abovebar)
    else
        sellTooltip := sellTooltip + formingSellTooltipSuffix
        ls := label.new(bar_index - 1, na, formingSellPrefix + 'üìâ SELL', color = formingSellColor, style = label.style_label_down, textcolor = formingSellTextColor, size = size.small, tooltip = sellTooltip, yloc = yloc.abovebar)

    // Stacking Protection
    if barstate.islast
        if not na(discoverySignalLbl) and label.get_x(discoverySignalLbl) == bar_index - 1
            label.delete(discoverySignalLbl)
        discoverySignalLbl := ls

// SIGNAL FADING PROTECTION (Terminal Bar Cleanup)
if barstate.islast and not strongBuySignalFinal and not strongSellSignalFinal
    // If we have a discovery label that was created for the current terminal candle (offset -1)
    // but the signal is now false, clean it up.
    if not na(discoverySignalLbl) and label.get_x(discoverySignalLbl) >= bar_index - 1
        label.delete(discoverySignalLbl)
        discoverySignalLbl := na

// Build decision explanation strings
var string entryReason = ''
// (Lines 3220-3223: Other Vars)

if barstate.islast
    // WHY this Entry Price?
    isBuy = buyScore >= sellScore
    // Use the dynamic tooltips we generated!
    entryReason := isBuy ? lastBuyTooltip : lastSellTooltip
    
    // Fallback if no recent signal or waiting message
    if entryReason == "" or str.contains(entryReason, "Waiting")
        entryReason := "No Signal Active.\nMonitoring market conditions..."

// CAPITAL PROTECTION WARNINGS (Show when signal exists but blocked by risk)
// Dynamic Failure Reason Tooltip (Calculated Every Bar for History)
string failReason = "Blocked by Validation:\n"

if isDangerous
    failReason := failReason + "‚Ä¢ Capital Protection (Market Extended)\n"
else
    // BOOLEAN FAILURE FLAGS (Precise Diagnostics)
    bool failSupport = strongBuySignalBase and not (priceAtSupportLong or buyScore >= 90)
    bool failSupportShort = strongSellSignalBase and not (priceAtResistanceShort or sellScore >= 90)
    
    bool failZone = strongBuySignal and not inNewLongZone
    bool failCooldown = strongBuySignal and not (cooldownPassedBuy or isReversionBuy)
    
    bool failZoneShort = strongSellSignal and not inNewShortZone
    bool failCooldownShort = strongSellSignal and not (cooldownPassedSell or isReversionSell)

    // Tactical Filters
    bool failTripleLong = strongBuySignal and not tripleScreenBuyPass
    bool failTripleShort = strongSellSignal and not tripleScreenSellPass
    bool failTrending = (strongBuySignal or strongSellSignal) and not isTrendingMarket
    bool failFVGLong = strongBuySignal and not fvgAllowsBuy
    bool failFVGShort = strongSellSignal and not fvgAllowsSell
    string entryZoneStart = "‚Ä¢ Entry Zone: Price not at "
    string dedupMsg = "‚Ä¢ Dedup: Still in previous Signal Zone\n"
    string cooldownMsg = "‚Ä¢ Cooldown: Signal active (Bars < "

    if failSupport
        failReason := failReason + entryZoneStart + "Support (Wait for pullback)\n"
    if failSupportShort
        failReason := failReason + entryZoneStart + "Resistance (Wait for bounce)\n"
    if failZone or failZoneShort
        failReason := failReason + dedupMsg
    if failCooldown or failCooldownShort
        failReason := failReason + cooldownMsg + fmt0(signalCooldown) + ")\n"
    if failTripleLong or failTripleShort
        failReason := failReason + "‚Ä¢ Triple Screen: HTF Trend Mismatch ‚ùå\n"
    if failTrending
        failReason := failReason + "‚Ä¢ Trend Quality: Market Choppy (ADX < " + fmt0(adxTrendThresh) + ") ‚ö†Ô∏è\n"
    if failFVGLong or failFVGShort
        failReason := failReason + "‚Ä¢ FVG Filter: Trading against active GAP üõë\n"
            
    if strongBuySignalBase and buySignalSource != ""
        failReason := failReason + "‚Ä¢ Source: " + buySignalSource + "\n"
    if strongSellSignalBase and sellSignalSource != ""
        failReason := failReason + "‚Ä¢ Source: " + sellSignalSource + "\n"
    if (buyScore > 0 and buyScore < thresholdAdjusted) or (sellScore > 0 and sellScore < thresholdAdjusted)
        failReason := failReason + "‚Ä¢ Note: Score Low (" + fmt0(math.max(buyScore, sellScore)) + "/" + fmt0(thresholdAdjusted) + "), triggered via Pattern/Reversion.\n"

// Fallback for safety
if failReason == "Blocked by Validation:\n"
    failReason := failReason + "‚Ä¢ Unknown (Check Log/Dashboard)\n"

bool isPendingVal = not barstate.isconfirmed
string pendingValTooltip = "‚è≥ SIGNAL PENDING\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nBar has not closed yet.\n\nCurrent Status:\n" + failReason

if (strongBuySignal and not strongBuySignalFinal and not isPowerBreakout and not strongBuySignalFinal[1]) or (strongSellSignal and not strongSellSignalFinal and not isPowerBreakdown and not strongSellSignalFinal[1])
    if barstate.islast
        bool isBuyF = strongBuySignal and not strongBuySignalFinal and not isPowerBreakout
        float lY_Val = isBuyF ? low : high
        string lTxt_Val = isPendingVal ? "‚è≥ PENDING" : (isDangerous ? "üõë TOO RISKY" : "‚ö†Ô∏è FAILED VALIDATION")
        color lCol_Val = isPendingVal ? color.yellow : color.red
        color lTCol_Val = isPendingVal ? color.black : color.white
        string lTooltip_Val = isPendingVal ? pendingValTooltip : failReason
        string lStyle_Val = isBuyF ? label.style_label_up : label.style_label_down

        if na(failedValidationLbl)
            failedValidationLbl := label.new(bar_index, lY_Val, lTxt_Val, color = lCol_Val, style = lStyle_Val, textcolor = lTCol_Val, size = size.small, tooltip = lTooltip_Val)
        else
            label.set_xy(failedValidationLbl, bar_index, lY_Val)
            label.set_text(failedValidationLbl, lTxt_Val)
            label.set_color(failedValidationLbl, lCol_Val)
            label.set_textcolor(failedValidationLbl, lTCol_Val)
            label.set_style(failedValidationLbl, lStyle_Val)
            label.set_tooltip(failedValidationLbl, lTooltip_Val)
else
    if barstate.islast and not na(failedValidationLbl)
        label.delete(failedValidationLbl)
        failedValidationLbl := na


// --- 30. INSTITUTIONAL QUALITY SCORE ---

// Calculate overall stock quality score (0-100)
// TECHNICAL SCORE (50 points max) - Short term tradability
trendScore = uptrend ? 12 : downtrend ? 0 : 6
momentumScore = (rsi > 50 ? 8 : 0) + (macdLine > signalLine ? 5 : 0)
volumeScore = volume > volAvg20 ? 8 : 4
strengthScore = adx > 25 ? 10 : adx > 15 ? 5 : 0
volatilityScoreTech = atr < ta.sma(atr, 50) ? 7 : 4

technicalScore = trendScore + momentumScore + volumeScore + strengthScore + volatilityScoreTech

// COMBINED SCORE: Technical Only (Fundamentals removed)
overallScore = technicalScore * 2

// Quality Assessment
stockQuality = overallScore >= 75 ? 'EXCELLENT ‚≠ê‚≠ê‚≠ê' : overallScore >= 60 ? 'GOOD ‚≠ê‚≠ê' : overallScore >= 40 ? 'AVERAGE ‚≠ê' : overallScore >= 20 ? 'POOR ‚ùå' : 'VERY POOR ‚õî'
qualityColor = overallScore >= 75 ? color.new(color.lime, 70) : overallScore >= 60 ? color.new(color.green, 70) : overallScore >= 40 ? color.new(color.yellow, 70) : overallScore >= 20 ? color.new(COL_ORANGE, 70) : color.new(color.red, 70)

// Label
qualityLabel = 'Technical Quality'

// Integrated Decision Metrics
// Information now in TOOLTIPS of the Main Dashboard.



// ENTRY ZONES AND CONFIRMATION (needed by dashboard and strategy)
// Professional traders use entry ZONES, not exact prices
// These variables are used by both the dashboard display AND strategy execution
entryTolerancePct = 0.2
enableRetestRequirement = true
requireVolumeConfirmation = true
requireRTConfirmation = true


// Entry helper: adaptive tolerance based on volatility and structure
calcTouchTolerance(baseTolerance) =>
    atrPct = atr > 0 ? (atr / close) : 0.0
    adaptive = math.max(baseTolerance, atrPct * 0.5) // widen up to 50% of ATR percent if higher than base
    // Ensure minimum tolerance (0.1%) and cap at 1% to avoid chasing
    math.min(math.max(adaptive, 0.001), 0.01)

// Entry helper: check price touch with optional retest requirement
priceTouchedLevel(lowPrice, highPrice, level, tolerance, requireRetest, isLong) =>
    touched = lowPrice <= level * (1 + tolerance) and highPrice >= level * (1 - tolerance)
    // Retest logic: prior bar must be away from level (above for longs, below for shorts)
    priorBarAway = isLong ? lowPrice[1] > level * (1 + tolerance) : highPrice[1] < level * (1 - tolerance)
    requireRetest ? (touched and priorBarAway) : touched

// Entry helper: assess volume confirmation at level with Z-SCORE
volumeSupportsEntry(isLong) =>
    volSma = volAvg20
    obvCheck = isLong ? obvBullish : obvBearish
    
    // Z-Score for volume (adaptive threshold)
    volumeMean = ta.sma(volume, 252)
    volumeStdDev = ta.stdev(volume, 252)
    volumeZScore = volumeStdDev > 0 ? (volume - volumeMean) / volumeStdDev : 0
    
    // Adaptive volume confirmation: 0.5 std dev above mean (moderate increase)
    isHighVolume = volumeZScore > 0.5
    
    not requireVolumeConfirmation or isHighVolume or obvCheck

// Extract ta.lowest for consistency
squeezeSupportLevel = ta.lowest(low, 20)



// Entry helper: prioritize structure-specific levels
dominantStructureAdjustment(isLong, defaultLevel, toleranceMultiplier) =>
    // DISABLE HARD OVERRIDE
    // We now rely on the Clustering Algorithm (with 3x Structure weight) to pick the winner.
    // The Dashboard should reflect the Cluster Winner, not force a separate logic.
    defaultLevel

// Entry helper: build confirmation bundle
calcEntryConfirmation(isLong, toleranceMultiplier) =>
    baseLevel = isLong ? suggestedEntryLong : suggestedEntryShort
    adjustedLevel = dominantStructureAdjustment(isLong, baseLevel, toleranceMultiplier)
    touchTol = calcTouchTolerance(math.max(toleranceMultiplier, 0.0))
    lowPrice = low
    highPrice = high
    touched = priceTouchedLevel(lowPrice, highPrice, adjustedLevel, touchTol, enableRetestRequirement, isLong)
    candleCheck = isLong ? close > open : close < open
    strongClose = isLong ? close > (high + low) / 2 : close < (high + low) / 2
    volumeCheck = volumeSupportsEntry(isLong)
    confirmation = (candleCheck or strongClose) and touched and volumeCheck
    [adjustedLevel, confirmation, touched]

// Function to calculate entry zones and confirmations
calcEntryZones() =>
    toleranceMultiplier = entryTolerancePct / 100.0

    [longAdjustedLevel, longConfRaw, longTouched] = calcEntryConfirmation(true, toleranceMultiplier)
    [shortAdjustedLevel, shortConfRaw, shortTouched] = calcEntryConfirmation(false, toleranceMultiplier)

    longEntryZoneLower = longAdjustedLevel
    longEntryZoneUpper = longAdjustedLevel * (1 + toleranceMultiplier)
    priceNearT1Long = close >= longEntryZoneLower and close <= longEntryZoneUpper and longTouched

    shortEntryZoneLower = shortAdjustedLevel * (1 - toleranceMultiplier)
    shortEntryZoneUpper = shortAdjustedLevel
    priceNearT1Short = close >= shortEntryZoneLower and close <= shortEntryZoneUpper and shortTouched

    // Build bullish confirmation (price action + structure + volume + RT indicators)
    // Fixed: Renamed variables to avoid conflict and removed undefined vars
    bullishConfirmation = 
         longConfRaw and
         (rtBullishSignal or not requireRTConfirmation)  // NEW: Real-time confirmation

    // Build bearish confirmation (price action + structure + volume + RT indicators)
    bearishConfirmation = 
         shortConfRaw and
         (rtBearishSignal or not requireRTConfirmation)  // NEW: Real-time confirmation

    // Build bullish confirmation variables
    
    // ACTIONABLE (Strict)
    longEntryWithConfirmation = strongBuySignalFinal and bullishConfirmation
    shortEntryWithConfirmation = strongSellSignalFinal and bearishConfirmation
    
    // VISUAL (Potential)
    longEntryPotential = potentialBuySignalFinal and bullishConfirmation
    shortEntryPotential = potentialSellSignalFinal and bearishConfirmation

    [longEntryZoneLower, longEntryZoneUpper, shortEntryZoneLower, shortEntryZoneUpper, priceNearT1Long, priceNearT1Short, bullishConfirmation, bearishConfirmation, longEntryWithConfirmation, shortEntryWithConfirmation, longEntryPotential, shortEntryPotential]

// Call function and unpack results
[longEntryZoneLower, longEntryZoneUpper, shortEntryZoneLower, shortEntryZoneUpper, priceNearT1Long, priceNearT1Short, bullishConfirmation, bearishConfirmation, longEntryWithConfirmation, shortEntryWithConfirmation, longEntryPotential, shortEntryPotential] = calcEntryZones()

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 3. DASHBOARD CORE ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Pattern detection removed - variables no longer needed

// Initialize table
var table dashboard = table.new(position.top_right, 3, 16, bgcolor = color.new(color.black, 0), border_width = 1, border_color = color.blue)

// Calculate targets for tooltips
t1TargetLong = suggestedTakeProfitLong
t1TargetShort = suggestedTakeProfitShort

// MTF Alignment display variables
// MTF Alignment Formatting
mtfStatusLong  = 'M ' + (monthlyUptrend ? '‚úì' : 'X') + ' W ' + (weeklyUptrend ? '‚úì' : 'X') + ' D ' + (dailyUptrend ? '‚úì' : 'X')
mtfStatusShort = (monthlyDowntrend ? '‚úì' : 'X') + 'M ' + (weeklyDowntrend ? '‚úì' : 'X') + 'W ' + (dailyDowntrend ? '‚úì' : 'X') + 'D'
mtfColorLong = allTimeframesAlignedBullish ? color.lime : majorTimeframesAlignedBullish ? color.yellow : color.gray
mtfColorShort = allTimeframesAlignedBearish ? color.red : majorTimeframesAlignedBearish ? COL_ORANGE : color.gray
mtfTooltip = 'MTF Align\nM/W/D\nQual: ' + str.tostring(signalQuality, '#') + '%'
// RISK & TREND (Compact + Tooltips)
trendText = uptrend ? 'BULL' : downtrend ? 'BEAR' : 'SIDE'
trendColor = uptrend ? color.lime : downtrend ? color.red : color.yellow

// WARNINGS & WEAKNESS LOGIC
spread = high - low
spreadAvg = ta.sma(spread, 20) // Use local calculation to be safe/independent
volAvgForLie = volAvg20

isBigMove = spread > spreadAvg * 1.5
isSmallMove = spread < spreadAvg * 0.5
isHighVolume = volume > volAvgForLie * 1.5

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PREDICTIVE TRAP DETECTION (Wick-Based, Not Lagging)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Fires on the CURRENT bar if wick touched key level but price rejected.
// WEAKNESS LOGIC (Visual Overlays)
weakBreakout = isBigMove and isLowVolumeTrap and not bullTrap and not bearTrap
churn = isSmallMove and isHighVolume

// FORMING vs CONFIRMED States
bool isFormingSignal = not barstate.isconfirmed

// VISUALS: Institutional Fatigue & Traps
if bullTrap
    trapLabelColor = isFormingSignal ? color.gray : color.red
    trapTextColor = isFormingSignal ? color.black : color.white
    trapPrefix = isFormingSignal ? '‚è≥\n' : '‚ö†Ô∏è\n'
    label.new(bar_index, high, trapPrefix + 'BULL TRAP', color=trapLabelColor, style=label.style_label_down, textcolor=trapTextColor, size=size.tiny, tooltip='Wick touched resistance but rejected on low volume.\n\n' + (isFormingSignal ? '‚è≥ FORMING - Wait for bar close.' : '‚úì CONFIRMED - High probability reversal.'))
else if isResistanceWeakened and high > keyResistance * 0.99
    label.new(bar_index, high, 'üß± WEAK RES', color=color.new(color.orange, 20), style=label.style_label_down, textcolor=color.black, size=size.tiny, tooltip='Resistance has been tested too many times. High risk of breakout.')
else if bearTrap
    trapLabelColor = isFormingSignal ? color.gray : color.green
    trapTextColor = isFormingSignal ? color.black : color.white
    trapPrefix = isFormingSignal ? '‚è≥\n' : '‚ö†Ô∏è\n'
    label.new(bar_index, low, trapPrefix + 'BEAR TRAP', color=trapLabelColor, style=label.style_label_up, textcolor=trapTextColor, size=size.tiny, tooltip='Wick touched support but bounced on low volume.\n\n' + (isFormingSignal ? '‚è≥ FORMING - Wait for bar close.' : '‚úì CONFIRMED - High probability reversal.'))
else if isSupportWeakened and low < keySupport * 1.01
    label.new(bar_index, low, 'üß± WEAK SUPPORT', color=color.new(color.red, 20), style=label.style_label_up, textcolor=color.white, size=size.tiny, tooltip='Support has been tested too many times. High risk of breakdown. DO NOT BUY THE DIP.')
else if bullishHikkake
    label.new(bar_index, low, 'HIKKAKE', color=color.green, style=label.style_label_up, textcolor=color.white, size=size.tiny, tooltip='HIKKAKE (Bullish): Failed Inside Bar Breakout.\n\nPrice broke low, trapped sellers, and reversed up.\nHigh probability reversal pattern.')
else if bearishHikkake
    label.new(bar_index, high, 'HIKKAKE', color=color.red, style=label.style_label_down, textcolor=color.white, size=size.tiny, tooltip='HIKKAKE (Bearish): Failed Inside Bar Breakout.\n\nPrice broke high, trapped buyers, and reversed down.\nHigh probability reversal pattern.')
else if failedBullishSweep
    label.new(bar_index, high, 'üíé FAILURE SWEEP', color=color.new(color.red, 0), style=label.style_label_down, textcolor=color.white, size=size.tiny, tooltip='FAILED BULLISH SWEEP: Price broke below the sweep low.\n\nIndicates trapped buyers and high-probability breakdown.')
else if failedBearishSweep
    label.new(bar_index, low, 'üíé FAILURE SWEEP', color=color.new(color.lime, 0), style=label.style_label_up, textcolor=color.white, size=size.tiny, tooltip='FAILED BEARISH SWEEP: Price broke above the sweep high.\n\nIndicates trapped sellers and high-probability breakout.')
else if bullishPinBar and (close < keySupport * 1.03 or inLongZone)
    label.new(bar_index, low, 'üìç PIN BAR', color=color.new(color.lime, 0), style=label.style_label_up, textcolor=color.white, size=size.tiny, tooltip='BULLISH PIN BAR: Long lower wick rejecting lows.\n\nIndicates strong buying pressure at support.')
else if bearishPinBar and (close > keyResistance * 0.97 or inShortZone)
    label.new(bar_index, high, 'üìç PIN BAR', color=color.new(color.red, 0), style=label.style_label_down, textcolor=color.white, size=size.tiny, tooltip='BEARISH PIN BAR: Long upper wick rejecting highs.\n\nIndicates strong selling pressure at resistance.')
else if bullishEngulfingStrict and (close < keySupport * 1.03 or inLongZone)
    label.new(bar_index, low, 'üî• ENGULF', color=color.new(color.lime, 0), style=label.style_label_up, textcolor=color.white, size=size.tiny, tooltip='BULLISH ENGULFING: Strong green candle engulfed the previous red candle.\n\nMomentum shift signaling potential reversal.')
else if bearishEngulfingStrict and (close > keyResistance * 0.97 or inShortZone)
    label.new(bar_index, high, 'üî• ENGULF', color=color.new(color.red, 0), style=label.style_label_down, textcolor=color.white, size=size.tiny, tooltip='BEARISH ENGULFING: Strong red candle engulfed the previous green candle.\n\nMomentum shift signaling potential reversal.')
else if weakBreakout
    // Gray if forming, Orange if confirmed
    pulseColor = isFormingSignal ? color.gray : COL_ORANGE
    pulsePrefix = isFormingSignal ? '‚è≥\n' : '‚ö°\n'
    label.new(bar_index, high, pulsePrefix + 'WEAK PULSE', color=pulseColor, style=label.style_label_down, textcolor=color.black, size=size.tiny, tooltip='Big move on low volume. Lacks conviction.' + (isFormingSignal ? '\n\n‚è≥ FORMING - Wait for bar close.' : ''))
if churn
    churnColor = isFormingSignal ? color.gray : ((uptrend or downtrend) ? color.new(color.yellow, 0) : color.new(color.yellow, 50))
    churnConf = (uptrend or downtrend) ? 'High (Trend Active)' : 'Low (Choppy)'
    churnPrefix = isFormingSignal ? '‚è≥\n' : '‚ö°\n'
    label.new(bar_index, high, churnPrefix + 'CHURN', color=churnColor, style=label.style_label_down, textcolor=color.black, size=size.tiny, tooltip='Churn: High volume but price is stuck.\n\nConfidence: ' + churnConf + (isFormingSignal ? '\n\n‚è≥ FORMING - Wait for bar close.' : ''))



dashboardScoreDiv = close > close[10] and (buyScore < buyScore[10])
isMomentumWarning = (bullishRSIDivergence or bearishRSIDivergence)
internalWeakness = dashboardScoreDiv or isMomentumWarning or weakBreakout or churn or failedBullishSweep or failedBearishSweep

// --- 32. DASHBOARD TABLE ASSEMBLY (MODULARIZED) ---

// FIX: Initialize arrays globally to satisfy function signature on every bar
bool[] bSigs = array.new_bool(0)
bool[] sSigs = array.new_bool(0)
float[] mtrArr = array.new_float(0)
float[] lvlArr = array.new_float(0)
string[] sArr = array.new_string(0)

if barstate.islast
    // Group signals (Populate only on last bar)
    bSigs := array.from(buyTrend1, buyTrend2, buyTrend3, buyTrend4, buyTrend5, buyTrend6, buyMomentum1, buyMomentum2, buyMomentum3, buyMomentum4, buyMomentum5, buyMomentum6, buyMomentum7, buyMomentum8, buyMomentum9, buyVolatility1, buyVolatility2, buyVolatility3, buyVolatility4, buyVolatility5, buyVolatility6, buyVolatility7, buyVolume1, buyVolume2, buyVolume3, buyVolume4, hasBullishPattern, activeLong)
    sSigs := array.from(sellTrend1, sellTrend2, sellTrend3, sellTrend4, sellTrend5, sellTrend6, sellMomentum1, sellMomentum2, sellMomentum3, sellMomentum5, sellMomentum7, sellMomentum8, sellVolatility1, sellVolatility2, sellVolatility3, sellVolatility4, sellVolatility5, sellVolatility6, sellVolume1, sellVolume2, sellVolume3, sellVolume4, hasBearishPattern, activeShort)

    mtrArr := array.from(buyScore, sellScore, signalQuality, adx, rsi, riskRewardTF, buyTrendScore, buyMomentumScore, buyVolumeScore, buyVolatilityScore, buyDivergenceScore, sellTrendScore, sellMomentumScore, sellVolumeScore, sellVolatilityScore, sellDivergenceScore, ivRank, finalIV30, ivHvSpread, totalSigma, hasRelStrength ? 1.0 : 0.0, isAccelerating ? 1.0 : 0.0)
    lvlArr := array.from(longZoneLow, longZoneHigh, finalLongZoneLow, finalLongZoneHigh, shortZoneLow, shortZoneHigh, finalShortZoneLow, finalShortZoneHigh, suggestedEntryLong, suggestedStopLossLong, suggestedTakeProfitLong, suggestedEntryShort, suggestedStopLossShort, suggestedTakeProfitShort, longZoneLow2, longZoneHigh2, longZoneScore2, shortZoneLow2, shortZoneHigh2, shortZoneScore2)
    sArr := array.from(weinsteinStageLabel, darvasStatus, tradingDecision, longTooltipAnchor, shortTooltipAnchor, longAnchorName, shortAnchorName, longAnchorName2, shortAnchorName2, tradingDecision, longDisplayAnchor, shortDisplayAnchor, entryReasonLong, entryReasonShort, resistanceWarningLong, resistanceWarningShort, mtfStatusLong, mtfStatusShort, mtfTooltip)

// FIX: Call Function on Every Bar (but it returns early if !islast)
renderMainDashboard(dashboard, trendText, tfDisplay, bSigs, sSigs, mtrArr, lvlArr, sArr, tradingDecisionColor, mtfColorLong, mtfColorShort, uptrend, downtrend, isTopping, isBottoming, isRiskZoneLong, isRiskZoneShort, longTargetNearResistance, shortTargetNearSupport, actionStateLong, actionStateShort, tradingDecision, effectiveDangerous, isSupportWeakened, isResistanceWeakened, zVelocity, zElasticity, trendBarsUp, keySupport, keyResistance, revScoreLong, revScoreShort, inLongZone, inShortZone)

